<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/Redis/"/>
    <url>/2021/09/26/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="需要知道"><a href="#需要知道" class="headerlink" title="需要知道"></a>需要知道</h2><p>Redis单条命令是保证原子性的，但是事务不保证原子性。</p><p>一次性，顺序性，排他性，没有隔离级别的概念，</p><p>Redis是单线程的：因为CPU处理速度不是Redis的瓶颈，Redis是基于内存操作的，它的瓶颈是机器的内存和网络带宽，单线程足够快了。</p><p>Redis为什么这么快？</p><p>Redis是将所有数据保存在内存中的，使用多线程的话CPU上下文切换也是很耗时的，使用单线程反而效率更高。</p><p>Redis可以用来做数据库，缓存和消息中间件MQ，</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>select 3                    选择第3号数据库</p><p>dbsize                        查看当前数据库大小</p><p>set key value            设置字段key的值为value</p><p>flushdb                        清空当前数据库</p><p>flushall                        清空所有数据库</p><p>keys *                            查看拥有的所有字段</p><p>exists                            是否含有某key</p><p>move key                        移除</p><p>expire key  10                  设置过期时间    </p><p>ttl key                        查看过期剩余时间</p><p>type key                    查看key类型</p><p>append key “value”            没有就set</p><p>strlen key</p><p>incr</p><p>decr</p><p>incrby</p><p>decrby</p><p>getrange key 0 3</p><p>getrange key 0 -1</p><p>setrange key 3 value</p><p>setex key 30 value</p><p>setnx key value</p><p>mset </p><p>mget</p><p>msetnx 原子性</p><p>getset</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>l(r)push list value</p><p>l(r)range list 0 1</p><p>l(r)index list 1</p><p>llen list</p><p>lrem list 3 value</p><p>ltrem list 1 2</p><p>rpoplpush list1 list2</p><p>exists list</p><p>lset list 0 value</p><p>linsert list </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>sadd set value</p><p>smembers set</p><p>sismember set value</p><p>scard set，所有元素个数</p><p>srem set value</p><p>srandmember set 2</p><p>spop 随机移除</p><p>smove set1 set2 value</p><p>sdiff set1 set2 </p><p>sinter set1 set2</p><p>sunion set1 set2</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>hset hashset field1 value1</p><p>hget hashset field</p><p> hmset</p><p> hgetall hashset</p><p>hdelete hashset filed1</p><p>  hsetnx hashset  </p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>在set基础上加了个字段 xxx</p><p>zadd</p><p>zrenge xxx </p><p>zrevrenge xxx</p><p>zrangebyscore xxx </p><p>zcard xxx</p><p>zcount xxx</p><h3 id="geospatial（底层是zset）"><a href="#geospatial（底层是zset）" class="headerlink" title="geospatial（底层是zset）"></a>geospatial（底层是zset）</h3><p>geoadd</p><p>geopos</p><p>geodist</p><p>georadius </p><p>georadiusbymember</p><h3 id="hyperloglog-不精确"><a href="#hyperloglog-不精确" class="headerlink" title="hyperloglog(不精确)"></a>hyperloglog(不精确)</h3><p>面试题：网页的UV：同一个人访问网站多次，怎么确认是同一个人的登录。</p><p>1.set保存下用户id。</p><p>2.</p><p>pfadd</p><p>pfcount</p><p>pfmerge</p><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>setbit </p><p>getbit</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>开启事务 multi</p><p>命令入队</p><p>执行 exec</p><p>放弃 discard</p><p>编译型错误，不执行</p><p>运行时错误，仍然执行正确的部分</p><p>悲观锁：很谨慎，感觉怎么都会出问题，任何时候都加锁</p><p>乐观锁：感觉不会有任何问题，不上锁，但是如果操作数据有变化，会被告知执行失败</p><p>watch，实现乐观锁，如果执行失败，unwatch解锁，再重新监视最新的值，watch</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>maven 导入Jedis依赖</p><p>new Jedis(“127.0.0.1”, “6379”)对象</p><p>其余操作和redis命令行一样。</p><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><p>初始化勾选Nosql的redis</p><p>把jedis换成了lettuce. 封装在redisTemplate中，</p><p>jedis是线程不安全的，想要变得安全要使用jedis pool，更像BIO模式</p><p>lettuce采用的是netty，实例可以在多个栈中进行分享，不存在县城不安全的情况，可以减少线程数据了，更像NIO模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>RedisTemplate redisTamplate;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function">viod <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    redisTemplate.opsForList().list的方法<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关于对象的序列化"><a href="#关于对象的序列化" class="headerlink" title="关于对象的序列化"></a>关于对象的序列化</h4><p>要么转化成json，要么就是类实现序列化（JDK 序列化implements Serializable），或者（推荐）直接在配置类中配置序列化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">templete.setKeySerialzer(<span class="hljs-keyword">new</span> xxxSerializer())<br></code></pre></td></tr></table></figure><h4 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h4><p>一般公司都会自己写一个根据自己业务的特点搞一个自己的工具类</p><h2 id="Redis-值钱的东西"><a href="#Redis-值钱的东西" class="headerlink" title="Redis 值钱的东西"></a>Redis 值钱的东西</h2><p>上面讲的都是使用Redis的基本操作</p><h3 id="Redis-config"><a href="#Redis-config" class="headerlink" title="Redis.config"></a>Redis.config</h3><p>配置文件对大小写不敏感。</p><p>包含，可以用 import 进行引用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">绑定端口</span><br>bind ipaddress<br><span class="hljs-meta">#</span><span class="bash">开启保护模式</span><br>protected-mode yes<br><span class="hljs-meta">#</span><span class="bash">设置端口</span><br>port xxxx<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">以守护进程的方式运行（后台运行）</span><br>deamonize yes<br><span class="hljs-meta">#</span><span class="bash">如果以后台方式运行，我们需要指定pid进程文件</span><br>profile /var/run/redis_6379.pid<br><span class="hljs-meta">#</span><span class="bash">日志，有多种日志级别</span><br>loglevel notice  #生产环境使用<br><span class="hljs-meta">#</span><span class="bash">日志的文件名</span><br>logfile &quot;&quot;  #空的话代表不保存直接输出<br><span class="hljs-meta">#</span><span class="bash">数据库数量</span><br>database 16<br><br><br>快照<br><span class="hljs-meta">#</span><span class="bash">持久化(防止内存数据库断电失去),在规定的时间内，执行了多少次操作会持久化到文件</span><br><span class="hljs-meta">#</span><span class="bash">900秒内，如果至少有一个key进行了修改，就要进行持久化</span><br>save 900 1<br>save 300 10<br>save 60 10000<br><span class="hljs-meta">#</span><span class="bash">持久化出错是否继续工作</span><br>stop-write-bgsave-error yes<br><span class="hljs-meta">#</span><span class="bash">是否压缩rdb文件（持久化文件），会占用CPU资源</span><br>rdbcompression yes<br><span class="hljs-meta">#</span><span class="bash">是否校验rdb文件（）</span><br>rdbchecksum yes<br><span class="hljs-meta">#</span><span class="bash">rdb文件保存目录</span><br>dir ./<br><br>RDB（下文单讲）<br><br>安全<br>requirepass xxx<br><span class="hljs-meta">#</span><span class="bash">或者在命令行config <span class="hljs-built_in">set</span> requirepass xxxx</span><br><span class="hljs-meta">#</span><span class="bash">认证</span><br>auth &quot;xxxx&quot;<br><br><br>客户端<br><span class="hljs-meta">#</span><span class="bash">了解一下</span><br>maxclients 1000<br>maxmemory &lt;bytes&gt;<br><span class="hljs-meta">#</span><span class="bash">内存满了使用什么策略处理</span><br>maxmemory-policy noeviction<br><br><br>APPEND ONLY模式 aof（持久化方式2） 配置<br>appendonly no #默认使用rdb方式持久化，大多数情况下rdf够用。<br>appendfilename &quot;appendonly.aof&quot;#持久化的文件名<br><span class="hljs-meta">#</span><span class="bash">每秒执行一次同步（可能丢失这个时候的数据）可以设置为no,always</span><br>appendfsync everysec<br></code></pre></td></tr></table></figure><h3 id="持久化RDB"><a href="#持久化RDB" class="headerlink" title="持久化RDB"></a>持久化RDB</h3><p>RDB就是Redis Database；保存的文件叫dump.rdb。</p><p>可以自定义一个save</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save 60 5<br></code></pre></td></tr></table></figure><ol><li><p>save设置的规则满足的情况下，会自动触发rdb规则。</p></li><li><p>执行flushall也会触发rdb规则</p></li><li><p>退出redis也会产生。</p></li></ol><p>如何回复？</p><ol><li><p>把文件放在redis的启动位置就好了，redis启动会自动检查dump.rdb文件并恢复数据。</p></li><li><p>config get dir  #自动扫描/usr/local/bin下存在的dump.rdb</p></li></ol><p>rdb的优缺点：</p><ol><li>优点：<ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高的时候使用</li></ol></li><li>缺点<ol><li>需要一定的时间间隔进程操作！如果redis意外宕机，最后一次修改的数据就没有了</li><li>fork进程的时候，会赵勇一定的内存空间！！</li></ol></li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>记录所有写操作，默认关闭</p><p>append only file</p><p>appendfsync everysec  #每秒同步</p><p>如果恶意破坏aof文件则没法恢复，使用下面的语句修复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-check-aof --fix appendonly.aof<br></code></pre></td></tr></table></figure><p>aof的优缺点：(?????????????????????)</p><ol><li>优点：<ol><li>每一次修改都同步（always），文件的完整性更好</li><li></li></ol></li><li>缺点<ol><li></li><li></li></ol></li></ol><h3 id="消息发布与订阅（还是交给专门的中间件来做吧）"><a href="#消息发布与订阅（还是交给专门的中间件来做吧）" class="headerlink" title="消息发布与订阅（还是交给专门的中间件来做吧）"></a>消息发布与订阅（还是交给专门的中间件来做吧）</h3><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>redis一般是集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">info replication<span class="hljs-comment">#查看当前库的主从信息</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/Netty%E7%9F%A5%E6%A0%B9%E7%9F%A5%E5%BA%95/"/>
    <url>/2021/09/26/Netty%E7%9F%A5%E6%A0%B9%E7%9F%A5%E5%BA%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty知根知底"><a href="#Netty知根知底" class="headerlink" title="Netty知根知底"></a>Netty知根知底</h1><p>Netty是网络编程基本框架，Java开发流行的Redis缓存的主从复制，分布式的RPC的底层通讯都使用Netty网络通讯。</p><h2 id="NIO是个什么玩意"><a href="#NIO是个什么玩意" class="headerlink" title="NIO是个什么玩意"></a>NIO是个什么玩意</h2><p>NIO(non-blocking-io，非阻塞io)</p><p><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20210925163226750.png" alt="image-20210925163226750"></p><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20210925163239860.png" alt="image-20210925163239860" style="zoom:200%;" /><p><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20210925163521053.png" alt="image-20210925163521053"></p><p><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20210925163857831.png" alt="image-20210925163857831"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/Mybatis%E4%B8%8EJDBC/"/>
    <url>/2021/09/26/Mybatis%E4%B8%8EJDBC/</url>
    
    <content type="html"><![CDATA[<p>title: Hello World</p><h2 id="Mybatis与JDBC"><a href="#Mybatis与JDBC" class="headerlink" title="Mybatis与JDBC"></a>Mybatis与JDBC</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC，Java Database Connectivity，舰名思意，Java数据库连接，一般操作的步骤如下：</p><p>1，根据四要素（Driver-Class，url，username，password）获得连接，</p><p>2，编写sql语句，</p><p>3，获取preparedStatement，预编译sql语句，</p><p>4，获取并处理结果集</p><p>5，关闭资源</p><p>使用第三方数据库连接池时需要配置dataSource。</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>Mybatis算是一个ORM框架，说到底内部也是封装了JDBC的，但是简化了很多操作，它的操作步骤：</p><p>1，sqlSessionFactory获取一个sqlSession,（session.getMapper）</p><p>2，编写@Mapper的mapper接口（DAO）</p><p>3，编写xml映射文件（包括sql语句，返回封装的Bean）          —————-与数据库交互</p><p>4，编写@Service的service业务逻辑代码</p><h3 id="JDBC与Mybatis比有哪些局限性呢"><a href="#JDBC与Mybatis比有哪些局限性呢" class="headerlink" title="JDBC与Mybatis比有哪些局限性呢"></a>JDBC与Mybatis比有哪些局限性呢</h3><p>1.数据库连接池（减少数据库关闭开启时数据库的资源浪费）：</p><p>2.SQL配置文件（减少硬编码）：原生JDBC直接在java中写sql语句，及其不好维护。</p><p>3.动态SQL语句（只专注写sql，各干各的事，专一）</p><p>4.映射（resultset直接转为java对象）：不用再操作底层的ResultSet。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/%E6%9D%82%E8%B0%88/"/>
    <url>/2021/09/26/%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><h2 id="关于Spring“自动”这件事"><a href="#关于Spring“自动”这件事" class="headerlink" title="关于Spring“自动”这件事"></a>关于Spring“自动”这件事</h2><p>下面说的三种时期亦或是三种方式，知识入口不同而已，容器底层启动的过程是一样的，方式有早期和主流之分，但在开发中多是灵活搭配的，例如早期的代码融入新技术实现的代码（Import）。</p><h3 id="1-XML配置时期"><a href="#1-XML配置时期" class="headerlink" title="1.XML配置时期"></a>1.XML配置时期</h3><p>最开始使用Spring的时候，也是早期主流的使用方式，我们需要在beans.xml中创建<bean>标签，并在子标签中对相应属性进行赋值，常用的方式有：</p><p>传值三种方式：按参数索引，按参数类型，按参数名</p><p>1.构造器注入（bean类中有相应的构造器）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentConstruct2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;domain.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.set注入（bean类中有相应的set方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;domain.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;11&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以该文件为参数传入ClassPathXmlApplicationContext会得到一个applicationContext的上下文容器对象。</p><p>从容器中获取bean并强转到原类型就能从容器中拿到该已赋值的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取applicationContext</span><br>ClassPathXmlApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br><span class="hljs-comment">//传入beanId, 获取bean</span><br>Student studentNoValue = (Student) applicationContext.getBean(<span class="hljs-string">&quot;student&quot;</span>);<br></code></pre></td></tr></table></figure><p>这种方式摆脱了奴役我们很久的new对象的方式，尽管这种方式看起来很麻烦，（重要的是思想，等我复习了再补充）</p><h3 id="2-Autowired-Bean时期"><a href="#2-Autowired-Bean时期" class="headerlink" title="2.@Autowired@Bean时期"></a>2.@Autowired@Bean时期</h3><p>在spring的一个叫做核心配置文件的东西中配置自动扫描哪些包下面的bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">#配置自动扫描包路径<br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.lunfee.beans&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>于此同时</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br></code></pre></td></tr></table></figure><h3 id="3-Java-Config时期（SpringBoot）"><a href="#3-Java-Config时期（SpringBoot）" class="headerlink" title="3.Java Config时期（SpringBoot）"></a>3.Java Config时期（SpringBoot）</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/"/>
    <url>/2021/09/26/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="请求转发，刷新页面"><a href="#请求转发，刷新页面" class="headerlink" title="请求转发，刷新页面"></a>请求转发，刷新页面</h2><p>在页面的跳转中，如果使用return”页面名”，默认走的是请求转发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&#123;&quot;/login&quot;,&quot;/&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLoginPage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@PostMapping(&quot;/index&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndexPage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--login表单提交走post请求，跳转到/index 控制器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-signin&quot;</span>  <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/index&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这种情况下，刷新页面会重新提交表单，要避免这种情况要使用重定向方法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/%E5%A5%BD%E5%BA%B7%E7%9A%84/"/>
    <url>/2021/09/26/%E5%A5%BD%E5%BA%B7%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="好康的"><a href="#好康的" class="headerlink" title="好康的"></a>好康的</h1><h2 id="关于-和-equals-的区别"><a href="#关于-和-equals-的区别" class="headerlink" title="关于==和.equals()的区别"></a>关于==和.equals()的区别</h2><p>其实很多人对于这个问题的答案可能就是一句简单的：双=号比较的是在堆内存中的地址值，equals()方法比较的是内容值。但是面试官要听的可不是这句话，或者他一定会问更深，更底层的问题，这里面牵扯了很多底层的计算机或者Java虚拟机的内容，下面先浅显的做一个梳理，后面有机会的话再修改补充。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>内存作为一个存储数据的存在， 有一个很重要的特性， 就是内存里的数据能被cpu直接访问（或者说被CPU的高速缓存区直接访问），所以内存才是计算机系统的主存储器， 而硬盘是外部存储器。</p><p>我们把内存分成了以字节为单位的结构， 但是实际上内存里还是有非常多的字节的，例如64MB内存就有 64 × 1024 × 1024 个字节，如果cpu要查找1个变量， 还是要1个个字节去找到话，时一个很浪费时间的行为，所以为了避免去遍历内存，计算机系统就引入了内存地址这个概念。在32位操作系统中，<strong>内存的地址就是32位的2进制数</strong>， 所以32位的地址范围就是从 0000 0000 0000 0000 0000 0000 0000 0000 到 1111 1111 1111 1111 1111 1111 1111 1111 （ox00000000 - oxFFFFFFFF)， 共2^32个内存地址，也就是 4GB，所以如果你给32位的系统配上了8GB的内存， 操作系统最多也只能给其中4GB 分配地址， 其余 4GB 是没有地址， 因为地址不够用啊， 所以32位系统最多支持4GB内存就是这样来的。 </p><p>说了这么多就是想讲在32位系统和64位系统中，指针的大小实际上是不一样的，因为指针时存放内存地址的，这么讲是针对C语言而言的，JAVA是不能直接操作计算机内存空间的。</p><h3 id="JVM的变量存储"><a href="#JVM的变量存储" class="headerlink" title="JVM的变量存储"></a>JVM的变量存储</h3><p>首先，我们先大概知道一下JVM的内存模型和Java的四类八种基本数据类型。</p><p>需要指出的是，java 在不同位的机器上执行时，</p><p><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20210923120220226.png" alt="image-20210923120220226"></p><p>在JVM内存模型中，方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就是局部变量只能在方法中有效的原因。</p><p>方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。</p><p>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）都是放在方法栈中</p><p>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p><p>类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</p><p>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量</p><p>​    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的</p><p>​    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。</p><h3 id="和-equals"><a href="#和-equals" class="headerlink" title="==和.equals()"></a>==和.equals()</h3><p>基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。</p><p>引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是<strong>堆内存</strong>地址）。</p><p>对于引用数据类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。<strong>因为每new一次，都会重新开辟堆内存空间</strong>。</p><p>JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    <span class="hljs-comment">//this - s1    //obj - s2    </span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。 </p><p>所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。我们对上面的两段内容做个总结吧： <strong>== 的作用：</strong></p><p>　　基本类型：比较的就是值是否相同</p><p>　　引用类型：比较的就是地址值是否相同</p><p>String类的equals()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>              String anotherString = (String)anObject;<br>              <span class="hljs-keyword">int</span> n = value.length;<br>              <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>                  <span class="hljs-keyword">char</span> v1[] = value;<br>                 <span class="hljs-keyword">char</span> v2[] = anotherString.value;<br>                 <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>                 <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                     <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                     i++;<br>                 &#125;<br>                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>     &#125;<br></code></pre></td></tr></table></figure><p>所以很明显比较的是两个String的值是否相同。说到这里感觉已经把==和.equals()的区别讲差不多了。</p><p>参考：<a href="https://www.zhihu.com/search?q===%E5%92%8Cequals&amp;utm_content=search_history&amp;type=content">https://www.zhihu.com/search?q=%3D%3D%E5%92%8Cequals&amp;utm_content=search_history&amp;type=content</a></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/27626724">https://zhuanlan.zhihu.com/p/27626724</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/26/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="关于计算机网络"><a href="#关于计算机网络" class="headerlink" title="关于计算机网络"></a>关于计算机网络</h1><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>IP地址用于确定主机</p><p>端口号用于区分主机上的不同应用。</p><p>TCP（Transmission Control Protocol, 传输控制协议）是基于数据流的协议，它是可靠的。</p><p>UDP是基于报文传输的协议，它不是可靠的但是高效，经常用于像视频聊天这种实时性高但可靠性要求不高的通信，即使再视频语音通话中，有少数的丢帧也不影响通话的整体效果。</p><p>Socket（插座）建立不同主机，不同应用间点对点的虚拟数据通道。</p><p>TCP和UDP是两种常用的socket。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment">#下面建立一个简单的socket连接</span><br><span class="hljs-comment">#第一个参数传入AF_INET代表使用ipv4地址家族，第二个参数SOCK_STREAM表示传输类型使用流传输，第三个参数为传输协议，缺省则使用第二个参数默认的，如SOCK_STREAM默认使用TCP协议传输，如果手动使用UDP会报错。</span><br><span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> s:<br><span class="hljs-comment">#ip绑定0.0.0.0表示如果服务器端有两个或以上的ip地址，那么两个都可以被识别；</span><br>    s.bind((<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">1234</span>))<br>    <span class="hljs-comment">#建立好ssocket后要对socket进行监听，s是专门负责监听连接的socket</span><br>    s.listen()<br>    <span class="hljs-comment">#当有客户端发来请求时，使用accept建立新的连接socket，用来处理消息的收发</span><br>    c, addr = s.accept()<br>    <span class="hljs-built_in">print</span>(addr, <span class="hljs-string">&quot;connected&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#消息接收与回传</span><br>        data = c.recv(<span class="hljs-number">1024</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">break</span><br>        c.sendall(data)<br></code></pre></td></tr></table></figure><p>在linux中进行测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash\">$nc 10.133.45.184 1234<br>hello<br>hello<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/Thymeleaf/"/>
    <url>/2021/09/26/Thymeleaf/</url>
    
    <content type="html"><![CDATA[<p>Thymeleaf </p><p>Thymeleaf 自动配置里面添加了默认的前后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.html&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">th:action=&quot;@&#123;/index&#125;      使用模板引擎定向controller<br>th:text=&quot;$&#123;&#125;&quot;             向model中取值//也可以像request中取值，一次request对应一个model//zh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/SpringMVC/"/>
    <url>/2021/09/26/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC原理"><a href="#SpringMVC原理" class="headerlink" title="SpringMVC原理"></a>SpringMVC原理</h1><h2 id="SpringMVC架构："><a href="#SpringMVC架构：" class="headerlink" title="SpringMVC架构："></a>SpringMVC架构：</h2><p>所有的WEB MVC框架都是这么设计的：一个中央Servlet程序，用于把请求分发到相应的控制器，实现业务逻辑与跳转。由于SpringMVC整合了Spring IoC容器，所以它具有Spring的所有功能。Spring的Servlet的实现类是DispatcherServlet，具有更强大的功能。</p><h3 id="DispatcherServlet："><a href="#DispatcherServlet：" class="headerlink" title="DispatcherServlet："></a>DispatcherServlet：</h3><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20210908095953054.png" alt="image-20210908095953054" style="zoom: 80%;" /><h3 id="浏览器访问流程："><a href="#浏览器访问流程：" class="headerlink" title="浏览器访问流程："></a>浏览器访问流程：</h3><p>用户向服务器发送HTTP请求，DispatcherServlet根据请求的信息通过Mapping寻找到处理请求的处理器，并返回到DispatcherServlet；HandlerAdapter再根据请求参数适配到指定的方法处理service业务，结果以mv的形式回传；View对mv进行渲染返回给客户。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/Springboot%20%E4%B8%AD,%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/09/26/Springboot%20%E4%B8%AD,%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Springboot-中-和-的区别"><a href="#Springboot-中-和-的区别" class="headerlink" title="Springboot 中/**,/和/*的区别"></a>Springboot 中/**,/和/*的区别</h2><p>Springboot 中经常使用拦截器，过滤器处理掉一部分请求操作，在设置拦截域的时候使用/**,/和/*拦截的效果是不同的</p><p>/**：拦截所有文件，包括文件夹下的子文件夹，包括静态资源，因此在拦截的时候需要放行如.css文件等的静态资源</p><p>/*：拦截该文件夹下所有的文件路径，不包含子文件夹，包涵页面。</p><p>/：拦截该文件夹下的所有文件路径，不包含页面</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/Springboot%20Mybaits%20%E6%95%B4%E5%90%88%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/09/26/Springboot%20Mybaits%20%E6%95%B4%E5%90%88%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot-Mybaits-整合记录"><a href="#Springboot-Mybaits-整合记录" class="headerlink" title="Springboot Mybaits 整合记录"></a>Springboot Mybaits 整合记录</h1><p>新建项目，添加组件</p><p>导入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入mybatis--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置数据源信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/lou_springboot?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.alibaba.druid.proxy.DruidDriver</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">lunfee</span><br></code></pre></td></tr></table></figure><p>配置服务器访问端口</p><p>配置要么写在配置文件中，要么就写配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yam">server:<br>  port: 80<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/26/session,cookie,request%E5%9F%9F/"/>
    <url>/2021/09/26/session,cookie,request%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="session-cookie-request域"><a href="#session-cookie-request域" class="headerlink" title="session,cookie,request域"></a>session,cookie,request域</h2><p>他们的作用都是保存页面的信息，</p><h3 id="sessi0n"><a href="#sessi0n" class="headerlink" title="sessi0n"></a>sessi0n</h3><p>用于存放不同页面的公共信息，比如登录信息，比如在商品页面添加到心愿单的商品，在跳转到购物车页面的时候任然可以获取到；</p><p>作用域：session 的作用域是一个会话</p><p>原理：用户发送一个请求访问到 Servlet，在服务器上找一块内存，实际上是一个键值对，前面是 String name，后面是Object value，每一个客户端都有一个session，每个客户端之间，当服务器为客户端下发一个临时的cookie（浏览器的内存中），名字叫JSESSIONID，是一组字母加数字的序列，表示访问服务器session内存的“凭证”，客户端通过JSESSIONID这个凭证访问自己对应的服务器存储session的内存。</p><p>失效：  1、客户端关闭浏览器程序，造成了JSESSIONID凭证丢失<br>                    2、时效性，session超时（会话超时）：a、客户端关闭后，一段时间内没有访问过该session内存，服务器会清理。b、或者一段时间内没有访问过该session内存，服务器会清理。c、会话超时的时间，默认是30分钟，只要发起请求，会话时间从0重新计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//页面1</span><br>session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;苹果&quot;</span>);<br><span class="hljs-comment">//页面2</span><br>session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>在 Springboot 中，只用在配置文件中配置就可以实现改变 session 的生命周期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pro">server.servlet.session.timeout=60  #单位分钟<br></code></pre></td></tr></table></figure><h3 id="requset"><a href="#requset" class="headerlink" title="requset"></a>requset</h3><p>常用于服务器间同一请求不同页面之间的参数传递，常应用于表单的控件值传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">request.setAttribute(); <br>request.getAttribute();<br>request.removeAttribute();<br>request.getParameter().<br></code></pre></td></tr></table></figure><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><p>model仅在一次request中有效，所以也存放临时值</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/26/hello-world/"/>
    <url>/2021/09/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
