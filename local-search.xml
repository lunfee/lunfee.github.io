<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/10/18/dp/"/>
    <url>/2021/10/18/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>动态规划，简称 dp，它的思想是通过状态方程把现有的问题转化成子问题，子问题再用同样的方法转化成子子问题，可能听起来像是递归，但是递归解决起来和带有递归性质的树，链表这一类的题目不同，它会做到很多重复的运算，无疑会导致算法效率低下，所以动态规划的一个重要的思想就是用空间换时间。我们把状态转移方程右边需要的状态提前计算出来，另外开辟空间来存储查询，就避免了重复计算的问题；</p><h2 id="适用题型"><a href="#适用题型" class="headerlink" title="适用题型"></a>适用题型</h2><p>dp适用于求解如最多，最少，最大，多少种，能不能……之类的问题，一般是可以对子问题的状态进行存储的。</p><h2 id="一般步骤（不是流程-）"><a href="#一般步骤（不是流程-）" class="headerlink" title="一般步骤（不是流程 ）"></a>一般步骤（不是流程 ）</h2><ul><li>确定状态：需要开辟额外的空间（数组）来存储子问题的状态，因此首先要确定每个数组元素的意义（最有子问题）。</li><li>确定状态转移方程</li><li>初始条件，边界情况（问题规模）</li><li>确定计算顺序</li></ul><h2 id="剑指offer2-103-最少的硬币数"><a href="#剑指offer2-103-最少的硬币数" class="headerlink" title="剑指offer2 103 最少的硬币数"></a>剑指offer2 103 最少的硬币数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>       <span class="hljs-comment">//amount is the  value of all selected coins</span><br>        <span class="hljs-comment">//define a zone for storing the status</span><br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br><br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//record every status </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++)&#123;<br>            f[i] = Integer.MAX_VALUE;<br>            <span class="hljs-comment">//f[x] = min&#123;f[x - coins[1]], f[x - coins[2] .....] &#125; + 1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>; j &lt; coins.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i - coins[j] &gt;= <span class="hljs-number">0</span> &amp;&amp;  f[i - coins[j] ] != Integer.MAX_VALUE)&#123;<br>                    f[i] = Math.min(f[i], f[i - coins[j]] + <span class="hljs-number">1</span> ) ;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[amount] == Integer.MAX_VALUE? -<span class="hljs-number">1</span> : f[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-62-不同路径"><a href="#LeetCode-62-不同路径" class="headerlink" title="LeetCode 62 不同路径"></a>LeetCode 62 不同路径</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//initialize a space to store the status of every subproblem</span><br>        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-comment">//initialize the status</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j== <span class="hljs-number">0</span>)&#123;<br>                    f[i][j] = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span><br>                    f[i][j] = f[i-<span class="hljs-number">1</span>][j] + f[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>        <br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\lunfee\Desktop\snipaste_20211019_200701.jpg" alt="snipaste_20211019_200701"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2021/10/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/10/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>计算机操作系统的可执行文件是由一行行代码或指令组成，这些静态的指令与数据文件在计算机中叫一个程序。</p><p>想要运行一个<strong>程序</strong>就必须要把这些指令集加载到机器的CPU中，同时将数据加载到内存，运行起来的程序叫做<strong>进程</strong>，进程是用来加载指令，管理IO，管理内存的。同一个程序如果允许多次执行，就形成了多个进程。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可以包括多个线程（Windows进程就是一个线程容器）</p><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行</p><h3 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h3><p>在Java中，线程是最小的<strong>调度</strong>单位，进程是资源分配的最小单位。</p><p>进程是相互独立的，而线程存在于进程内，是进程的一个子集</p><p>进程内存在共享资源，供内部线程共享使用</p><p>多线程：一个进程内同时并行执行多个线程，每个线程各自有一套虚拟机栈和程序计数器。</p><p>多线程的优势：</p><ol><li><p>用户使用图形化界面完成不同任务的必须。</p></li><li><p>可以提高CPU利用率（尽管对于单核会降低速度）</p></li><li><p>复杂的进程分为多线程，单独启动易于管理，优化结构。</p></li></ol><p>何时使用多线程：</p><ol><li><p>程序需要同时执行两个或多个任务</p></li><li><p>程序需要实现一些需要等待的任务，比如网络加载，输入，读写文件等 </p></li></ol><p>后台执行任务。</p><p>进程间的通信：同一台计算机之间进程的通讯成为IPC(Inter-Process Communication)</p><p>​                         不同计算机之间的进程通讯，需要走网络并遵守协议</p><p>线程间的通讯：线程共享方法区和堆，可以实现进程间高效通信。</p><p>上下文切换：</p><ol><li>线程间的上下文切换主要是对指令的临时存储，开销较小</li><li>进程间的上下文切换涉及到资源的临时存储，开销较大</li></ol><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>并发(Concurent)的概念是建立在单个处理器上，在逻辑（时间）上好像多个线程在同步运行，实际上是在不同线程间不停切换。处理器核心为不同线程分发时间片，CPU在不同的线程见轮询（Windows下最短时间片为15ms)</p><p>并行是物理意义上的同步运行，基于多个处理器（核心），单核处理器无法实现并行。</p><p>计算机的任务处理是并行域并发同时发生的，因为大多数情况下，计算机需要处理的线程数要大于计算机的总处理器核数。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>任务执行的同步与异步：</p><ol><li>需要等待结果返回才能继续运行就是同步</li><li>不要等待结果返回就能继续运行就是同步</li></ol><p>Java多线程的同步：让多个线程步调一致</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>在单核CPU下，多线程并不能提高实际的效率，只是为了在不同的任务之间转换，不同线程轮流使用CPU，避免单线程工作，其他线程等待。</li><li>对于多核CPU而言，处理任务是否可以拆分，是否需要拆分都需要根据实际情况确定。</li><li>IO操作是不占用CPU的，但是如果使用<strong>阻塞IO</strong>，相当于线程虽然不用CPU，但是需要一直等待IO操作结束，没有充分的利用线程，所以才有后面的<strong>非阻塞IO</strong>和<strong>异步IO</strong>（NIO）.</li></ol><h2 id="JAVA线程基础"><a href="#JAVA线程基础" class="headerlink" title="JAVA线程基础"></a>JAVA线程基础</h2><h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><h4 id="方法1：使用Thread（继承Threada类，重写run-方法）"><a href="#方法1：使用Thread（继承Threada类，重写run-方法）" class="headerlink" title="方法1：使用Thread（继承Threada类，重写run()方法）"></a>方法1：使用Thread（继承Threada类，重写run()方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建线程对象</span><br><span class="hljs-comment">//使用匿名内部类的方式创建Thread，因为只用一次，直接在new的时候覆盖run()方法。</span><br>Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        log.debug(<span class="hljs-string">&quot;thread1 run&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//交给任务调度器调度分配时间片，由CPU执行。</span><br>t1.start();<br></code></pre></td></tr></table></figure><h4 id="方法2；使用Runnable配合Thread"><a href="#方法2；使用Runnable配合Thread" class="headerlink" title="方法2；使用Runnable配合Thread"></a>方法2；使用Runnable配合Thread</h4><ol><li>把线程和任务分离</li><li>Tread表示线程，Runnable表示可运行的任务，线程要执行的代码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable task = <span class="hljs-keyword">new</span> Runnable()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        log.debug(<span class="hljs-string">&quot;task run&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//也可以交给线程池处理</span><br>Thread t2 = Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><h5 id="新知识"><a href="#新知识" class="headerlink" title="新知识"></a>新知识</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Runnable接口源码</span><br><span class="hljs-meta">@FunctionlInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>@FunctionalInterface注解使用在仅有一个抽象方法的接口上，在Java8 以上的版本中可以使用lambda表达式简写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable task = () -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;task run&quot;</span>);<br>&#125;<br><span class="hljs-comment">//也可以交给线程池处理</span><br>Thread t2 = Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><h4 id="方法3：FutureTssk配合Thread（）"><a href="#方法3：FutureTssk配合Thread（）" class="headerlink" title="方法3：FutureTssk配合Thread（）"></a>方法3：FutureTssk配合Thread（）</h4><p>从Runnable接口源码可以看出，Runnable接口的run()方法没有返回值，无法进行线程间数据的传输共享。</p><p><img src="https://i.loli.net/2021/10/17/5kzyDTlpFstjhu6.png" alt="image-20211017171615846"></p><p>FutureTask类可以返回线程的执行结果，它的继承关系如图：</p><p><img src="https://i.loli.net/2021/10/17/ZH2raKA4k6JvITS.png" alt="image-20211017172252995"></p><p>继承的Future接口中有get()方法，能实现返回，除此之外，FutureTask需要搭配Callable接口（有返回值）：</p><p><img src="https://i.loli.net/2021/10/17/kqhrBep91x4o85i.png" alt="image-20211017172157201"></p><p>一个代码示例（之前在尚硅谷记的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableThtread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//3.create the instance of call class</span><br>        NumberThresd numberThresd = <span class="hljs-keyword">new</span> NumberThresd();<br>        <span class="hljs-comment">//4.use the futuretask tool</span><br>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(numberThresd);<br>        <span class="hljs-comment">//5.create new thread</span><br>        <span class="hljs-keyword">new</span> Thread(futureTask).start();<br>        <span class="hljs-comment">//6.call get method if you need the return value of call</span><br>        Object o = futureTask.get();<br>        System.out.println(o);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//1.create a class implements Callable interface and Override call method</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThresd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//2.return Object, Integer is the subclass of Object, int sum is turned into Integer automatically</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                sum += i;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于为什么使用Future命名，从官方对Future的解释可以看出，get()方法可能需要阻塞等待执行结果(未来的结果)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready.<br></code></pre></td></tr></table></figure><h3 id="线程和进程的查看"><a href="#线程和进程的查看" class="headerlink" title="线程和进程的查看"></a>线程和进程的查看</h3><p>在Windows下提供了查看所有进程与线程的cmd命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tasklist   //显示所有任务<br>taskkill   //通过pid杀死某个进程<br>tasklist | findstr java    //通过管道方法搜索带有java字段的任务<br></code></pre></td></tr></table></figure><p>Linus下对线程的查看操作更为丰富</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -fe | grep java    //管道筛选所有Java字段的进程<br>kill pid              //杀死进程<br>top//动态采集进程运行情况，包括CPU占用和MER占用<br>top -H -p pid //显示进程中所有线程的信息(-H 表示查看线程)<br></code></pre></td></tr></table></figure><p>JDK也提供了一套可以用来专门查看Java线程的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jps       //查看所有java进程<br></code></pre></td></tr></table></figure><h3 id="线程的运行底层原理"><a href="#线程的运行底层原理" class="headerlink" title="线程的运行底层原理"></a>线程的运行底层原理</h3><p>Java Virtual Machine Stacks(Java 虚拟机栈)</p><p><img src="https://i.loli.net/2021/10/17/OjnMUfIxRTkZlLc.png" alt="image-20211017200109319"></p><p>JVM是由堆，栈，方法区组成，其中栈时线程私有的，每个线程启动，虚拟机都会为其分配一块栈内存，</p><p>每个栈由多个栈帧(Frame)组成，对应这每次方法调用时所占用的内存。</p><p>每个线程只有一个活动的栈帧，对应着当前正在执行的那个方法。</p><p>单个线程的运行时栈内存和栈帧内存的使用情况：</p><p><img src="https://i.loli.net/2021/10/17/5HFDiwARtGZXpNB.png" alt="image-20211017194407325"></p><p>多个线程的情况下，各个线程之间有各自的占内存，栈帧是相互独立的，</p><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><p>上下文切换的具体情况：</p><p><img src="https://i.loli.net/2021/10/17/hYEj1pHd9OZxJyA.png" alt="image-20211017201009754"></p><h3 id="线程常用方法讲解"><a href="#线程常用方法讲解" class="headerlink" title="线程常用方法讲解"></a>线程常用方法讲解</h3><h4 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h4><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h4 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h4><p><strong>sleep</strong> (使线程阻塞)</p><ol><li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span><br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//休眠一分钟</span><br>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><p>yield （让出当前线程）</p><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能(机会)被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-regexp">//</span>设置为优先级最高<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h4><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用t1.join()，则是主线程等待t1线程结束</p><p>join() 方法可用于<strong>线程的同步</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>();<br><span class="hljs-comment">//等待thread线程执行结束</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>();<br><span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h4 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h4><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。</li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>用于查看打断标记，返回值被boolean类型<br>t1.isInterrupted();Copy<br></code></pre></td></tr></table></figure><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>) &#123;<br>        break;<br>    &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="https://i.loli.net/2021/10/21/i3pkemhWc6UvSBr.png" alt="img"></a></p><p><strong>代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Monitor</span>();<br>monitor.<span class="hljs-built_in">start</span>();<br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">3500</span>);<br>monitor.<span class="hljs-built_in">stop</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;</span><br><br>Thread monitor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>() &#123;<br>@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">//判断当前线程是否被打断了</span><br><span class="hljs-keyword">if</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">isInterrupted</span>()) &#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-comment">//终止线程执行</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>e.<span class="hljs-built_in">printStackTrace</span>();<br><span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">interrupt</span>();<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.<span class="hljs-built_in">interrupt</span>();<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h4><ul><li>stop方法 停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）/resume（恢复线程）方法</li></ul><h4 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h4><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//将线程设置为守护线程, 默认为<span class="hljs-literal">false</span><br><span class="hljs-literal">monitor</span>.setDaemon(<span class="hljs-literal">true</span>);Copy<br></code></pre></td></tr></table></figure><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><h4 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h4><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="https://i.loli.net/2021/10/21/UhMp4cRNVS9GPmK.png" alt="img"></a></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h4 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h4><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png"><img src="https://i.loli.net/2021/10/21/B4N6WdloD83burT.png" alt="img"></a></p><ul><li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><p><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20211021171451941.png" alt="image-20211021171451941"></p>]]></content>
    
    
    
    <tags>
      
      <tag>线程，并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20211006</title>
    <link href="/2021/10/06/20211006/"/>
    <url>/2021/10/06/20211006/</url>
    
    <content type="html"><![CDATA[<p>我也不知道 Typora 发生了什么事情，本来是想来记个日记的，发现了一个 bug，就是写完 yaml 之后正文第一个字符必须是英文，不管那么多了，正文开始吧….</p><p>今天是国庆假期的倒数第二天了，虽然学校只放三天的假期，但是我四号赶来学校的时候实验室其实没什么人过来，说来是有点自私的，我也知道可以晚点来学校，多陪陪家人，奈何我的心里面想的工作学习的事情也怕被耽搁，其实差不多了，这几天过的还算充实。只是突然回来学校有点找不到原来的方向了，尽管在离校前，对我的当时任务做了个入栈操作，如图所示：</p><p><img src="https://i.loli.net/2021/10/06/owERgTnqdJcF7LB.png" alt="image-20211006171648690"></p><p>除了这些，我其实还需要搞机器人，以应付胡**的突然“关心”，说实话从读研到现在我的学术进展几乎为零，也没有头绪，没有心思确定未来我要做什么发小论文和毕业，到底是不是机器人啊，一年后我就有答案了啊哈哈，因为那个时候就是迫在眉睫了。现在我就安心的想我的工作吧，科研这条路不是每个人都适合，更不是每个人都有机遇。可能我遇到一个好的导师，我就……就可以读博了，别，感觉在这个学校或者说国内这个环境下（国外不知道），真的没那么多人喜欢科研，不过是混个学历罢了。我就勉为其难掩盖我的科研素养，好好利用这最后的学历光环搞钱吧。</p><p>可能对于我个人而言，生活的开心快乐真的比什么都重要，但是我也知道，快乐可以是纯粹的，也可以是物质的，我也知道，纯粹的快乐是最持久的，但是我仍然义无反顾的追求物质的快乐，直白点就是金钱。可能超脱物质的那种人真的存在，但那必不是我。从小长大的环境告诉我，没有金钱就没有自信，尽管这个事实被我的学历冲淡了那么一点点，但其实只是把金钱的价值转移到了具有强大购买了的高学历上了，我不否认这一点，因为这太正常不过了。</p><p>有钱可以让我对得起自己的亲情（良心），比如不会表达的我可以靠买一些生活用品啊，小礼物啊来慰藉自己的父母，奶奶，以及几个宝贝；比如可以毫不吝啬的买高铁票飞机票回家，而不用抉择这路途如此艰难究竟要不要回家；比如父母的体检费啊，以后难免可能有高昂的医药费啊，我想毫不犹豫的说，治，都少钱都给我治，但拿需要底气——来自于金钱。</p><p>我一点也不心虚的觉得我很爱我的家人，尤其心疼我的父母，有物质层面的有精神层面的甚至是知识层面上。物质上，他们挣钱真的太不容易了，尽管最近几年在花销上大了不少，但依旧是省吃俭用，工作也是普通劳动人民，尽管我也是如此，省吃俭用，未来的新型劳动人民，但这种心疼是油然而生的，这种心疼源自生为他们一点一点用心养大的儿子的我的生活质量要比他们高出很多上，源自工作的体面程度上，源自社会地位上，不过也还好有我，尽管算是在这残酷的世界上苟且偷生吧，让他们有一点骄傲和慰藉，这一点真的有在精神层面弥补到他们，我确定。关于精神层面的心疼和知识层面的下次再写吧。</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Object类</title>
    <link href="/2021/09/27/Object%E7%B1%BB/"/>
    <url>/2021/09/27/Object%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2021/09/26/Netty%E7%9F%A5%E6%A0%B9%E7%9F%A5%E5%BA%95/"/>
    <url>/2021/09/26/Netty%E7%9F%A5%E6%A0%B9%E7%9F%A5%E5%BA%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty知根知底"><a href="#Netty知根知底" class="headerlink" title="Netty知根知底"></a>Netty知根知底</h1><h2 id="学前问题"><a href="#学前问题" class="headerlink" title="学前问题"></a>学前问题</h2><p>netty线程模型</p><p>NIO为什么这么快，是否高效，和IO的区别</p><p>NIO和BIO和IO</p><p>NIO原理</p><p>NIO究竟怎么实现非阻塞的</p><p>java里面哪些用到了NIO</p><p>TCP粘包拆包</p><p>Netty是网络编程基本框架，Java开发流行的Redis缓存的主从复制，分布式的RPC的底层通讯都使用Netty网络通讯。</p><h2 id="NIO是个什么玩意"><a href="#NIO是个什么玩意" class="headerlink" title="NIO是个什么玩意"></a>NIO是个什么玩意</h2><p>NIO(non-blocking-io，非阻塞io)</p><p><img src="https://i.loli.net/2021/09/27/Ld7zph2ajmvIwMF.png" alt="image-20210925163226750"></p><img src="https://i.loli.net/2021/09/27/7YfjtHqBmRCKgVo.png" alt="image-20210925163239860" style="zoom:200%;" /><p><img src="https://i.loli.net/2021/09/27/mwPBF2r46MYpZLg.png" alt="image-20210925163521053"></p><p><img src="https://i.loli.net/2021/09/27/dHwjf7kBD3XoMVc.png" alt="image-20210925163857831"></p><p>拆包粘包问题，</p>]]></content>
    
    
    
    <tags>
      
      <tag>nio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/25/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/25/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="关于计算机网络"><a href="#关于计算机网络" class="headerlink" title="关于计算机网络"></a>关于计算机网络</h1><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>IP地址用于确定主机</p><p>端口号用于区分主机上的不同应用。</p><p>TCP（Transmission Control Protocol, 传输控制协议）是基于数据流的协议，它是可靠的。</p><p>UDP是基于报文传输的协议，它不是可靠的但是高效，经常用于像视频聊天这种实时性高但可靠性要求不高的通信，即使再视频语音通话中，有少数的丢帧也不影响通话的整体效果。</p><p>Socket（插座）建立不同主机，不同应用间点对点的虚拟数据通道。</p><p>TCP和UDP是两种常用的socket。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment">#下面建立一个简单的socket连接</span><br><span class="hljs-comment">#第一个参数传入AF_INET代表使用ipv4地址家族，第二个参数SOCK_STREAM表示传输类型使用流传输，第三个参数为传输协议，缺省则使用第二个参数默认的，如SOCK_STREAM默认使用TCP协议传输，如果手动使用UDP会报错。</span><br><span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> s:<br><span class="hljs-comment">#ip绑定0.0.0.0表示如果服务器端有两个或以上的ip地址，那么两个都可以被识别；</span><br>    s.bind((<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">1234</span>))<br>    <span class="hljs-comment">#建立好ssocket后要对socket进行监听，s是专门负责监听连接的socket</span><br>    s.listen()<br>    <span class="hljs-comment">#当有客户端发来请求时，使用accept建立新的连接socket，用来处理消息的收发</span><br>    c, addr = s.accept()<br>    <span class="hljs-built_in">print</span>(addr, <span class="hljs-string">&quot;connected&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#消息接收与回传</span><br>        data = c.recv(<span class="hljs-number">1024</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">break</span><br>        c.sendall(data)<br></code></pre></td></tr></table></figure><p>在linux中进行测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash\">$nc 10.133.45.184 1234<br>hello<br>hello<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2021/09/24/Redis/"/>
    <url>/2021/09/24/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="需要知道"><a href="#需要知道" class="headerlink" title="需要知道"></a>需要知道</h2><p>Redis单条命令是保证原子性的，但是事务不保证原子性。</p><p>一次性，顺序性，排他性，没有隔离级别的概念，</p><p>Redis是单线程的：因为CPU处理速度不是Redis的瓶颈，Redis是基于内存操作的，它的瓶颈是机器的内存和网络带宽，单线程足够快了。</p><p>Redis为什么这么快？</p><p>Redis是将所有数据保存在内存中的，使用多线程的话CPU上下文切换也是很耗时的，使用单线程反而效率更高。</p><p>Redis可以用来做数据库，缓存和消息中间件MQ，</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>select 3                    选择第3号数据库</p><p>dbsize                        查看当前数据库大小</p><p>set key value            设置字段key的值为value</p><p>flushdb                        清空当前数据库</p><p>flushall                        清空所有数据库</p><p>keys *                            查看拥有的所有字段</p><p>exists                            是否含有某key</p><p>move key                        移除</p><p>expire key  10                  设置过期时间    </p><p>ttl key                        查看过期剩余时间</p><p>type key                    查看key类型</p><p>append key “value”            没有就set</p><p>strlen key</p><p>incr</p><p>decr</p><p>incrby</p><p>decrby</p><p>getrange key 0 3</p><p>getrange key 0 -1</p><p>setrange key 3 value</p><p>setex key 30 value</p><p>setnx key value</p><p>mset </p><p>mget</p><p>msetnx 原子性</p><p>getset</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>l(r)push list value</p><p>l(r)range list 0 1</p><p>l(r)index list 1</p><p>llen list</p><p>lrem list 3 value</p><p>ltrem list 1 2</p><p>rpoplpush list1 list2</p><p>exists list</p><p>lset list 0 value</p><p>linsert list </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>sadd set value</p><p>smembers set</p><p>sismember set value</p><p>scard set，所有元素个数</p><p>srem set value</p><p>srandmember set 2</p><p>spop 随机移除</p><p>smove set1 set2 value</p><p>sdiff set1 set2 </p><p>sinter set1 set2</p><p>sunion set1 set2</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>hset hashset field1 value1</p><p>hget hashset field</p><p> hmset</p><p> hgetall hashset</p><p>hdelete hashset filed1</p><p>  hsetnx hashset  </p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>在set基础上加了个字段 xxx</p><p>zadd</p><p>zrenge xxx </p><p>zrevrenge xxx</p><p>zrangebyscore xxx </p><p>zcard xxx</p><p>zcount xxx</p><h3 id="geospatial（底层是zset）"><a href="#geospatial（底层是zset）" class="headerlink" title="geospatial（底层是zset）"></a>geospatial（底层是zset）</h3><p>geoadd</p><p>geopos</p><p>geodist</p><p>georadius </p><p>georadiusbymember</p><h3 id="hyperloglog-不精确"><a href="#hyperloglog-不精确" class="headerlink" title="hyperloglog(不精确)"></a>hyperloglog(不精确)</h3><p>面试题：网页的UV：同一个人访问网站多次，怎么确认是同一个人的登录。</p><p>1.set保存下用户id。</p><p>2.</p><p>pfadd</p><p>pfcount</p><p>pfmerge</p><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>setbit </p><p>getbit</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>开启事务 multi</p><p>命令入队</p><p>执行 exec</p><p>放弃 discard</p><p>编译型错误，不执行</p><p>运行时错误，仍然执行正确的部分</p><p>悲观锁：很谨慎，感觉怎么都会出问题，任何时候都加锁</p><p>乐观锁：感觉不会有任何问题，不上锁，但是如果操作数据有变化，会被告知执行失败</p><p>watch，实现乐观锁，如果执行失败，unwatch解锁，再重新监视最新的值，watch</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>maven 导入Jedis依赖</p><p>new Jedis(“127.0.0.1”, “6379”)对象</p><p>其余操作和redis命令行一样。</p><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><p>初始化勾选Nosql的redis</p><p>把jedis换成了lettuce. 封装在redisTemplate中，</p><p>jedis是线程不安全的，想要变得安全要使用jedis pool，更像BIO模式</p><p>lettuce采用的是netty，实例可以在多个栈中进行分享，不存在县城不安全的情况，可以减少线程数据了，更像NIO模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>RedisTemplate redisTamplate;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function">viod <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    redisTemplate.opsForList().list的方法<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关于对象的序列化"><a href="#关于对象的序列化" class="headerlink" title="关于对象的序列化"></a>关于对象的序列化</h4><p>要么转化成json，要么就是类实现序列化（JDK 序列化implements Serializable），或者（推荐）直接在配置类中配置序列化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">templete.setKeySerialzer(<span class="hljs-keyword">new</span> xxxSerializer())<br></code></pre></td></tr></table></figure><h4 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h4><p>一般公司都会自己写一个根据自己业务的特点搞一个自己的工具类</p><h2 id="Redis-值钱的东西"><a href="#Redis-值钱的东西" class="headerlink" title="Redis 值钱的东西"></a>Redis 值钱的东西</h2><p>上面讲的都是使用Redis的基本操作</p><h3 id="Redis-config"><a href="#Redis-config" class="headerlink" title="Redis.config"></a>Redis.config</h3><p>配置文件对大小写不敏感。</p><p>包含，可以用 import 进行引用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">绑定端口</span><br>bind ipaddress<br><span class="hljs-meta">#</span><span class="bash">开启保护模式</span><br>protected-mode yes<br><span class="hljs-meta">#</span><span class="bash">设置端口</span><br>port xxxx<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">以守护进程的方式运行（后台运行）</span><br>deamonize yes<br><span class="hljs-meta">#</span><span class="bash">如果以后台方式运行，我们需要指定pid进程文件</span><br>profile /var/run/redis_6379.pid<br><span class="hljs-meta">#</span><span class="bash">日志，有多种日志级别</span><br>loglevel notice  #生产环境使用<br><span class="hljs-meta">#</span><span class="bash">日志的文件名</span><br>logfile &quot;&quot;  #空的话代表不保存直接输出<br><span class="hljs-meta">#</span><span class="bash">数据库数量</span><br>database 16<br><br><br>快照<br><span class="hljs-meta">#</span><span class="bash">持久化(防止内存数据库断电失去),在规定的时间内，执行了多少次操作会持久化到文件</span><br><span class="hljs-meta">#</span><span class="bash">900秒内，如果至少有一个key进行了修改，就要进行持久化</span><br>save 900 1<br>save 300 10<br>save 60 10000<br><span class="hljs-meta">#</span><span class="bash">持久化出错是否继续工作</span><br>stop-write-bgsave-error yes<br><span class="hljs-meta">#</span><span class="bash">是否压缩rdb文件（持久化文件），会占用CPU资源</span><br>rdbcompression yes<br><span class="hljs-meta">#</span><span class="bash">是否校验rdb文件（）</span><br>rdbchecksum yes<br><span class="hljs-meta">#</span><span class="bash">rdb文件保存目录</span><br>dir ./<br><br>RDB（下文单讲）<br><br>安全<br>requirepass xxx<br><span class="hljs-meta">#</span><span class="bash">或者在命令行config <span class="hljs-built_in">set</span> requirepass xxxx</span><br><span class="hljs-meta">#</span><span class="bash">认证</span><br>auth &quot;xxxx&quot;<br><br><br>客户端<br><span class="hljs-meta">#</span><span class="bash">了解一下</span><br>maxclients 1000<br>maxmemory &lt;bytes&gt;<br><span class="hljs-meta">#</span><span class="bash">内存满了使用什么策略处理</span><br>maxmemory-policy noeviction<br><br><br>APPEND ONLY模式 aof（持久化方式2） 配置<br>appendonly no #默认使用rdb方式持久化，大多数情况下rdf够用。<br>appendfilename &quot;appendonly.aof&quot;#持久化的文件名<br><span class="hljs-meta">#</span><span class="bash">每秒执行一次同步（可能丢失这个时候的数据）可以设置为no,always</span><br>appendfsync everysec<br></code></pre></td></tr></table></figure><h3 id="持久化RDB"><a href="#持久化RDB" class="headerlink" title="持久化RDB"></a>持久化RDB</h3><p>RDB就是Redis Database；保存的文件叫dump.rdb。</p><p>可以自定义一个save</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save 60 5<br></code></pre></td></tr></table></figure><ol><li><p>save设置的规则满足的情况下，会自动触发rdb规则。</p></li><li><p>执行flushall也会触发rdb规则</p></li><li><p>退出redis也会产生。</p></li></ol><p>如何回复？</p><ol><li><p>把文件放在redis的启动位置就好了，redis启动会自动检查dump.rdb文件并恢复数据。</p></li><li><p>config get dir  #自动扫描/usr/local/bin下存在的dump.rdb</p></li></ol><p>rdb的优缺点：</p><ol><li>优点：<ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高的时候使用</li></ol></li><li>缺点<ol><li>需要一定的时间间隔进程操作！如果redis意外宕机，最后一次修改的数据就没有了</li><li>fork进程的时候，会赵勇一定的内存空间！！</li></ol></li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>记录所有写操作，默认关闭</p><p>append only file</p><p>appendfsync everysec  #每秒同步</p><p>如果恶意破坏aof文件则没法恢复，使用下面的语句修复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-check-aof --fix appendonly.aof<br></code></pre></td></tr></table></figure><p>aof的优缺点：(?????????????????????)</p><ol><li>优点：<ol><li>每一次修改都同步（always），文件的完整性更好</li><li></li></ol></li><li>缺点<ol><li></li><li></li></ol></li></ol><h3 id="消息发布与订阅（还是交给专门的中间件来做吧）"><a href="#消息发布与订阅（还是交给专门的中间件来做吧）" class="headerlink" title="消息发布与订阅（还是交给专门的中间件来做吧）"></a>消息发布与订阅（还是交给专门的中间件来做吧）</h3><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>redis一般是集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">info replication<span class="hljs-comment">#查看当前库的主从信息</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis与JDBC</title>
    <link href="/2021/09/23/Mybatis%E4%B8%8EJDBC/"/>
    <url>/2021/09/23/Mybatis%E4%B8%8EJDBC/</url>
    
    <content type="html"><![CDATA[<h2 id="Mybatis与JDBC"><a href="#Mybatis与JDBC" class="headerlink" title="Mybatis与JDBC"></a>Mybatis与JDBC</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC，Java Database Connectivity，舰名思意，Java数据库连接，一般操作的步骤如下：</p><p>1，根据四要素（Driver-Class，url，username，password）获得连接，</p><p>2，编写sql语句，</p><p>3，获取preparedStatement，预编译sql语句，</p><p>4，获取并处理结果集</p><p>5，关闭资源</p><p>使用第三方数据库连接池时需要配置dataSource。</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>Mybatis算是一个ORM框架，说到底内部也是封装了JDBC的，但是简化了很多操作，它的操作步骤：</p><p>1，sqlSessionFactory获取一个sqlSession,（session.getMapper）</p><p>2，编写@Mapper的mapper接口（DAO）</p><p>3，编写xml映射文件（包括sql语句，返回封装的Bean）          —————-与数据库交互</p><p>4，编写@Service的service业务逻辑代码</p><h3 id="JDBC与Mybatis比有哪些局限性呢"><a href="#JDBC与Mybatis比有哪些局限性呢" class="headerlink" title="JDBC与Mybatis比有哪些局限性呢"></a>JDBC与Mybatis比有哪些局限性呢</h3><p>1.数据库连接池（减少数据库关闭开启时数据库的资源浪费）：</p><p>2.SQL配置文件（减少硬编码）：原生JDBC直接在java中写sql语句，及其不好维护。</p><p>3.动态SQL语句（只专注写sql，各干各的事，专一）</p><p>4.映射（resultset直接转为java对象）：不用再操作底层的ResultSet。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2021/09/20/SpringMVC/"/>
    <url>/2021/09/20/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC原理"><a href="#SpringMVC原理" class="headerlink" title="SpringMVC原理"></a>SpringMVC原理</h1><h2 id="SpringMVC架构："><a href="#SpringMVC架构：" class="headerlink" title="SpringMVC架构："></a>SpringMVC架构：</h2><p>所有的WEB MVC框架都是这么设计的：一个中央Servlet程序，用于把请求分发到相应的控制器，实现业务逻辑与跳转。由于SpringMVC整合了Spring IoC容器，所以它具有Spring的所有功能。Spring的Servlet的实现类是DispatcherServlet，具有更强大的功能。</p><h3 id="DispatcherServlet："><a href="#DispatcherServlet：" class="headerlink" title="DispatcherServlet："></a>DispatcherServlet：</h3><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20210908095953054.png" alt="image-20210908095953054" style="zoom: 80%;" /><h3 id="浏览器访问流程："><a href="#浏览器访问流程：" class="headerlink" title="浏览器访问流程："></a>浏览器访问流程：</h3><p>用户向服务器发送HTTP请求，DispatcherServlet根据请求的信息通过Mapping寻找到处理请求的处理器，并返回到DispatcherServlet；HandlerAdapter再根据请求参数适配到指定的方法处理service业务，结果以mv的形式回传；View对mv进行渲染返回给客户。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Mybatis</title>
    <link href="/2021/09/19/Springboot%20Mybaits%20%E6%95%B4%E5%90%88%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/09/19/Springboot%20Mybaits%20%E6%95%B4%E5%90%88%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot-Mybaits-整合记录"><a href="#Springboot-Mybaits-整合记录" class="headerlink" title="Springboot Mybaits 整合记录"></a>Springboot Mybaits 整合记录</h1><p>新建项目，添加组件</p><p>导入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入mybatis--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置数据源信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/lou_springboot?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.alibaba.druid.proxy.DruidDriver</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">lunfee</span><br></code></pre></td></tr></table></figure><p>配置服务器访问端口</p><p>配置要么写在配置文件中，要么就写配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yam">server:<br>  port: 80<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2021/09/19/Springboot%20%E4%B8%AD,%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/09/19/Springboot%20%E4%B8%AD,%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Springboot-中-和-的区别"><a href="#Springboot-中-和-的区别" class="headerlink" title="Springboot 中/**,/和/*的区别"></a>Springboot 中/**,/和/*的区别</h2><p>Springboot 中经常使用拦截器，过滤器处理掉一部分请求操作，在设置拦截域的时候使用/**,/和/*拦截的效果是不同的</p><p>/**：拦截所有文件，包括文件夹下的子文件夹，包括静态资源，因此在拦截的时候需要放行如.css文件等的静态资源</p><p>/*：拦截该文件夹下所有的文件路径，不包含子文件夹，包涵页面。</p><p>/：拦截该文件夹下的所有文件路径，不包含页面</p>]]></content>
    
    
    
    <tags>
      
      <tag>/*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好康的</title>
    <link href="/2021/09/16/%E5%A5%BD%E5%BA%B7%E7%9A%84/"/>
    <url>/2021/09/16/%E5%A5%BD%E5%BA%B7%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="好康的"><a href="#好康的" class="headerlink" title="好康的"></a>好康的</h1><h2 id="关于-和-equals-的区别"><a href="#关于-和-equals-的区别" class="headerlink" title="关于==和.equals()的区别"></a>关于==和.equals()的区别</h2><p>其实很多人对于这个问题的答案可能就是一句简单的：双=号比较的是在堆内存中的地址值，equals()方法比较的是内容值。但是面试官要听的可不是这句话，或者他一定会问更深，更底层的问题，这里面牵扯了很多底层的计算机或者Java虚拟机的内容，下面先浅显的做一个梳理，后面有机会的话再修改补充。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>内存作为一个存储数据的存在， 有一个很重要的特性， 就是内存里的数据能被cpu直接访问（或者说被CPU的高速缓存区直接访问），所以内存才是计算机系统的主存储器， 而硬盘是外部存储器。</p><p>我们把内存分成了以字节为单位的结构， 但是实际上内存里还是有非常多的字节的，例如64MB内存就有 64 × 1024 × 1024 个字节，如果cpu要查找1个变量， 还是要1个个字节去找到话，时一个很浪费时间的行为，所以为了避免去遍历内存，计算机系统就引入了内存地址这个概念。在32位操作系统中，<strong>内存的地址就是32位的2进制数</strong>， 所以32位的地址范围就是从 0000 0000 0000 0000 0000 0000 0000 0000 到 1111 1111 1111 1111 1111 1111 1111 1111 （ox00000000 - oxFFFFFFFF)， 共2^32个内存地址，也就是 4GB，所以如果你给32位的系统配上了8GB的内存， 操作系统最多也只能给其中4GB 分配地址， 其余 4GB 是没有地址， 因为地址不够用啊， 所以32位系统最多支持4GB内存就是这样来的。 </p><p>说了这么多就是想讲在32位系统和64位系统中，指针的大小实际上是不一样的，因为指针时存放内存地址的，这么讲是针对C语言而言的，JAVA是不能直接操作计算机内存空间的。</p><h3 id="JVM的变量存储"><a href="#JVM的变量存储" class="headerlink" title="JVM的变量存储"></a>JVM的变量存储</h3><p>首先，我们先大概知道一下JVM的内存模型和Java的四类八种基本数据类型。</p><p>需要指出的是，java 在不同位的机器上执行时，</p><p><img src="https://i.loli.net/2021/09/27/hvOpPICSVGeJyRl.png" alt="image-20210923120220226"></p><p>在JVM内存模型中，方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就是局部变量只能在方法中有效的原因。</p><p>方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。</p><p>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）都是放在方法栈中</p><p>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p><p>类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</p><p>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量</p><p>​    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的</p><p>​    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。</p><h3 id="和-equals"><a href="#和-equals" class="headerlink" title="==和.equals()"></a>==和.equals()</h3><p>基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。</p><p>引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是<strong>堆内存</strong>地址）。</p><p>对于引用数据类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。<strong>因为每new一次，都会重新开辟堆内存空间</strong>。</p><p>JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    <span class="hljs-comment">//this - s1    //obj - s2    </span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。 </p><p>所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。我们对上面的两段内容做个总结吧： <strong>== 的作用：</strong></p><p>　　基本类型：比较的就是值是否相同</p><p>　　引用类型：比较的就是地址值是否相同</p><p>String类的equals()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>              String anotherString = (String)anObject;<br>              <span class="hljs-keyword">int</span> n = value.length;<br>              <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>                  <span class="hljs-keyword">char</span> v1[] = value;<br>                 <span class="hljs-keyword">char</span> v2[] = anotherString.value;<br>                 <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>                 <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                     <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                     i++;<br>                 &#125;<br>                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>     &#125;<br></code></pre></td></tr></table></figure><p>所以很明显比较的是两个String的值是否相同。说到这里感觉已经把==和.equals()的区别讲差不多了。</p><p>参考：<a href="https://www.zhihu.com/search?q===%E5%92%8Cequals&amp;utm_content=search_history&amp;type=content">https://www.zhihu.com/search?q=%3D%3D%E5%92%8Cequals&amp;utm_content=search_history&amp;type=content</a></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/27626724">https://zhuanlan.zhihu.com/p/27626724</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>equals</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈</title>
    <link href="/2021/09/14/%E6%9D%82%E8%B0%88/"/>
    <url>/2021/09/14/%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><h2 id="关于Spring“自动”这件事"><a href="#关于Spring“自动”这件事" class="headerlink" title="关于Spring“自动”这件事"></a>关于Spring“自动”这件事</h2><p>下面说的三种时期亦或是三种方式，知识入口不同而已，容器底层启动的过程是一样的，方式有早期和主流之分，但在开发中多是灵活搭配的，例如早期的代码融入新技术实现的代码（Import）。</p><h3 id="1-XML配置时期"><a href="#1-XML配置时期" class="headerlink" title="1.XML配置时期"></a>1.XML配置时期</h3><p>最开始使用Spring的时候，也是早期主流的使用方式，我们需要在beans.xml中创建<bean>标签，并在子标签中对相应属性进行赋值，常用的方式有：</p><p>传值三种方式：按参数索引，按参数类型，按参数名</p><p>1.构造器注入（bean类中有相应的构造器）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentConstruct2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;domain.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.set注入（bean类中有相应的set方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;domain.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;11&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以该文件为参数传入ClassPathXmlApplicationContext会得到一个applicationContext的上下文容器对象。</p><p>从容器中获取bean并强转到原类型就能从容器中拿到该已赋值的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取applicationContext</span><br>ClassPathXmlApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br><span class="hljs-comment">//传入beanId, 获取bean</span><br>Student studentNoValue = (Student) applicationContext.getBean(<span class="hljs-string">&quot;student&quot;</span>);<br></code></pre></td></tr></table></figure><p>这种方式摆脱了奴役我们很久的new对象的方式，尽管这种方式看起来很麻烦，（重要的是思想，等我复习了再补充）</p><h3 id="2-Autowired-Bean时期"><a href="#2-Autowired-Bean时期" class="headerlink" title="2.@Autowired@Bean时期"></a>2.@Autowired@Bean时期</h3><p>在spring的一个叫做核心配置文件的东西中配置自动扫描哪些包下面的bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">#配置自动扫描包路径<br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.lunfee.beans&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>于此同时</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br></code></pre></td></tr></table></figure><h3 id="3-Java-Config时期（SpringBoot）"><a href="#3-Java-Config时期（SpringBoot）" class="headerlink" title="3.Java Config时期（SpringBoot）"></a>3.Java Config时期（SpringBoot）</h3>]]></content>
    
    
    
    <tags>
      
      <tag>关于Spring的一些理解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thymeleaf</title>
    <link href="/2021/09/11/Thymeleaf/"/>
    <url>/2021/09/11/Thymeleaf/</url>
    
    <content type="html"><![CDATA[<p>Thymeleaf </p><p>Thymeleaf 自动配置里面添加了默认的前后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.html&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">th:action=&quot;@&#123;/index&#125;      使用模板引擎定向controller<br>th:text=&quot;$&#123;&#125;&quot;             向model中取值//也可以像request中取值，一次request对应一个model//zh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Session,Cookie,Request</title>
    <link href="/2021/09/11/session,cookie,request%E5%9F%9F/"/>
    <url>/2021/09/11/session,cookie,request%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="session-cookie-request域"><a href="#session-cookie-request域" class="headerlink" title="session,cookie,request域"></a>session,cookie,request域</h2><p>他们的作用都是保存页面的信息，</p><h3 id="sessi0n"><a href="#sessi0n" class="headerlink" title="sessi0n"></a>sessi0n</h3><p>用于存放不同页面的公共信息，比如登录信息，比如在商品页面添加到心愿单的商品，在跳转到购物车页面的时候任然可以获取到；</p><p>作用域：session 的作用域是一个会话</p><p>原理：用户发送一个请求访问到 Servlet，在服务器上找一块内存，实际上是一个键值对，前面是 String name，后面是Object value，每一个客户端都有一个session，每个客户端之间，当服务器为客户端下发一个临时的cookie（浏览器的内存中），名字叫JSESSIONID，是一组字母加数字的序列，表示访问服务器session内存的“凭证”，客户端通过JSESSIONID这个凭证访问自己对应的服务器存储session的内存。</p><p>失效：  1、客户端关闭浏览器程序，造成了JSESSIONID凭证丢失<br>                    2、时效性，session超时（会话超时）：a、客户端关闭后，一段时间内没有访问过该session内存，服务器会清理。b、或者一段时间内没有访问过该session内存，服务器会清理。c、会话超时的时间，默认是30分钟，只要发起请求，会话时间从0重新计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//页面1</span><br>session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;苹果&quot;</span>);<br><span class="hljs-comment">//页面2</span><br>session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>在 Springboot 中，只用在配置文件中配置就可以实现改变 session 的生命周期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pro">server.servlet.session.timeout=60  #单位分钟<br></code></pre></td></tr></table></figure><h3 id="requset"><a href="#requset" class="headerlink" title="requset"></a>requset</h3><p>常用于服务器间同一请求不同页面之间的参数传递，常应用于表单的控件值传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">request.setAttribute(); <br>request.getAttribute();<br>request.removeAttribute();<br>request.getParameter().<br></code></pre></td></tr></table></figure><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><p>model仅在一次request中有效，所以也存放临时值</p>]]></content>
    
    
    
    <tags>
      
      <tag>域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于请求转发</title>
    <link href="/2021/09/11/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/"/>
    <url>/2021/09/11/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="请求转发，刷新页面"><a href="#请求转发，刷新页面" class="headerlink" title="请求转发，刷新页面"></a>请求转发，刷新页面</h2><p>在页面的跳转中，如果使用return”页面名”，默认走的是请求转发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&#123;&quot;/login&quot;,&quot;/&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLoginPage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@PostMapping(&quot;/index&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndexPage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--login表单提交走post请求，跳转到/index 控制器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-signin&quot;</span>  <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/index&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这种情况下，刷新页面会重新提交表单，要避免这种情况要使用重定向方法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
