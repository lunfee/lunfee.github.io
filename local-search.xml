<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/20/chao/java%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/20/chao/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h4 id="String，StringBuider，StringBuffer"><a href="#String，StringBuider，StringBuffer" class="headerlink" title="String，StringBuider，StringBuffer"></a>String，StringBuider，StringBuffer</h4><p>String 的 “+” ：创建一个新对象，改变指针</p><p>SB append   ：调整 char 型数组长度，原地拼接</p><blockquote><p>底层都是使用 char 型数组实现的，只不过 String 使用 final 修饰，StringBuffer 没有</p><ul><li>不可变性，拼接效率</li><li>线程安全性，</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/05/03/chao/Main/"/>
    <url>/2022/05/03/chao/Main/</url>
    
    <content type="html"><![CDATA[<h3 id="AQS-amp-ReentrantLock"><a href="#AQS-amp-ReentrantLock" class="headerlink" title="AQS &amp; ReentrantLock"></a>AQS &amp; ReentrantLock</h3><h4 id="AQS概念"><a href="#AQS概念" class="headerlink" title="AQS概念"></a>AQS概念</h4><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/Aqs.drawio.png" alt="Aqs.drawio"> </p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/ReentrantLock%E8%8E%B7%E5%8F%96%E9%94%81.drawio.png" alt="ReentrantLock获取锁.drawio"></p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><a href="https://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&mid=2247491733&idx=1&sn=2a4efe9f12a6d3009d89d703e7dadaa5&chksm=c1618decf61604fa0eb46bb65e31248db2bd555527dc558b19c5a60a2be634a24e5e1bc79e0c&scene=21#wechat_redirect">ThreadLocal</a></h3><p>demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YesThreadLocal</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; threadLocalName = ThreadLocal.withInitial(() -&gt; Thread.currentThread().getName());<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;threadName: &quot;</span> + threadLocalName.get());<br>            &#125;, <span class="hljs-string">&quot;yes-thread-&quot;</span> + i).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>使用资源本地化的方式来避免线程争抢的问题，也避免了锁消耗（比如用户私有的信息）不同的线程在 get 的时候 get 到的是当前线程的值（多个线程（请求）都会使用同一个变量，但是又不共享，可以设置为每个线程独自的变量，线程间互补干扰；）</li><li>设置一个线程域的变量，线程内处处可以访问，较少方法的过度封装。</li></ol><h4 id="为什么一般为static"><a href="#为什么一般为static" class="headerlink" title="为什么一般为static"></a>为什么一般为static</h4><p>一个成员变量是否为 static 修饰决定了它时实例变量还是静态变量，ThreadLocal 的语义和作用是使这个变量成为 per-thread 而不是 per-instance 的。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-comment">// 每个线程内部有一个ThreadLocalMap 类型的 threadLocals 用来存储本地变量</span><br>    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220506151825348.png" alt="image-20220506151825348" style="zoom:80%;" /> <p>在 Thread 中维护一个 ThreadLocalMap 变量，以ThreadLocal 作为 key，以对应的值作为 value </p><p>如何找到：</p><p>通过 ThreadLocal 变量的 get 方法，Thread  —-&gt;   ThreadLocalMap   —-&gt;   getEntry(this)   —-&gt;   return entry.value</p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220506151949360.png" alt="image-20220506151949360" style="zoom:80%;" /> <h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>ThreadLocalMap 解决哈希冲突的方式是开放地址法（线性探测），如果当前索引发生哈希冲突，则线性的寻找下一个位置</p><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220506152035366.png" alt="image-20220506152035366"> </p><p>这样做肯定没有 HashMap 的拉链法效率高，但是ThreadLocalMap 存的数目有限，再把加载因子降低一些(2/3)，冲突的可能性就降低了，方式简单而且避免使用指针。</p><h4 id="弱引用与内存泄漏"><a href="#弱引用与内存泄漏" class="headerlink" title="弱引用与内存泄漏"></a>弱引用与内存泄漏</h4><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220506152557731.png" alt="image-20220506152557731" style="zoom:80%;" /> <p>ThreadLocal 变量是作用在一个线程里的，当一个线程销毁，这些变量自然的被回收掉，但是一<strong>般使用线程池的时候，线程是常驻的</strong>，这种情况下如果不做一些附加操作的话，工作线程的 ThreadLocalMap 中的数据可能会保留很多无用的数据，由于和线程之间有引用链，因此可能永远不会被垃圾回收掉。</p><p>因此 ThreadLocalMap 中的 Entry 继承了 WeakReference&lt;ThreadLocal&lt;?&gt;&gt; 弱引用，在实例化的时候使用 super(key) 将 key 对threadLocal 变量的引用设为弱引用，当不存在其它强引用的时候，该 key 锁对应的 ThreadLocal 对象将被回收，在 ThreadLocalMap 后续的 set() 操作或者是扩容的过程中遇到 key 为空的 Entry 会进行清理，但是 ThreadLocal 的数据较少，清理的概率较低，仍然有较大的可能发生内存泄漏，<strong>所以最规范的操作就是在执行完相应的功能后进行手动的 remove() 。</strong></p><p><strong>为什么不把 value 设为弱引用</strong>，我觉有两个方面的原因，第一，Map 结构是通过 key 查询 value 的，也就是说，<strong>外界引用一般作用在 key 上</strong>，所以通过 key 的引用更具有”Entry无用“的代表性；第二点，如果将 value 设为弱引用，可能会 get() 到空值，<strong>引发空指针异常</strong>。</p><p><strong>为什么不用软引用？</strong>我个人理解是根据 ThreadLocal 的语义，当一个请求或者，一个任务结束，ThreadLocalMap 中的 key 不再存在任何强的引用，这个时候就应该立马将其判定为可回收的状态，在下次垃圾回收时，直接将其回收掉。SoftReference 更没有那么强烈的清理欲望，而是等到内存即将溢出时才回收，这中非即时性会导致原本依靠概率的减少内存泄漏的问题更加严重</p><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><p>这玩意可以理解为就是可以把父线程的 threadlocal 传递给子线程，所以如果要这样传递就用 InheritableThreadLocal ，不要用 threadlocal。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h4><ol><li>创建/销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程</strong>。（一个请求对应一个线程）</li><li><strong>控制并发的数量</strong>。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li><li><strong>可以对线程做统一管理</strong>。</li></ol><h4 id="线程池组成"><a href="#线程池组成" class="headerlink" title="线程池组成"></a>线程池组成</h4><p>工作线程：为了避免线程的频繁创建和销毁，线程池“缓存”了一些工作线程。</p><p>任务阻塞队列：（<strong>生产者消费者模式</strong>）线程池将任务入队（offer），工作线程从队列中取(poll)任务执行（<strong>如何复用，保持存活，超时销毁</strong>）</p><p><strong>原子类 ctl：记录线程池的状态和线程数（高3 state，低29 线程数）</strong></p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220505110327150.png" alt="image-20220505110327150" style="zoom: 80%;" /> <h4 id="阻塞队列的作用"><a href="#阻塞队列的作用" class="headerlink" title="阻塞队列的作用"></a>阻塞队列的作用</h4><ol><li>实现线程复用</li><li>保持核心线程数存活（take()）</li><li>控制非核心线程销毁（take()）</li></ol><p>ArrayBlockingQueue</p><p>LinkedBlockingQueue</p><p><a href="https://blog.csdn.net/yanyan19880509/article/details/52562039">SynchronousQueue</a></p><p>DelayBlockingQueue</p><h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><ul><li><p><strong>int corePoolSize</strong>：<strong>核心线程数最大值</strong></p><blockquote><p>核心线程：默认一直运行，即使没有任务也不销毁</p><p>非核心线程：在 poll() 时，如果超过指定阻塞时间就会被销毁</p></blockquote></li><li><p><strong>int maximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong> 。</p><blockquote><p>该值等于核心线程数量 + 非核心线程数量。</p></blockquote></li><li><p><strong>long keepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong>。</p><blockquote><p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置<strong>allowCoreThreadTimeOut(true)，则会也作用于核心线程</strong>。</p></blockquote></li><li><p><strong>TimeUnit unit</strong>：keepAliveTime的单位。</p></li><li><p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>。</p><p>常用的几个阻塞队列：</p><ol><li><p><strong>LinkedBlockingQueue</strong></p><p>链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也<strong>可以指定大小</strong>。</p></li><li><p><strong>ArrayBlockingQueue</strong></p><p>数组阻塞队列，底层数据结构，是数组，需要指定队列的大小。</p></li><li><p><strong>SynchronousQueue</strong></p><p>同步队列，内部容量为0，每个put操作必须<strong>等待</strong>一个take操作，反之亦然。</p></li><li><p><strong>DelayQueue</strong></p><p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</p></li></ol></li><li><p><strong>ThreadFactory threadFactory</strong></p><p>创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;<br>    <span class="hljs-comment">// 省略属性</span><br>    <span class="hljs-comment">// 构造函数</span><br>    DefaultThreadFactory() &#123;<br>        SecurityManager s = System.getSecurityManager();<br>        group = (s != <span class="hljs-keyword">null</span>) ? s.getThreadGroup() :<br>        Thread.currentThread().getThreadGroup();<br>        namePrefix = <span class="hljs-string">&quot;pool-&quot;</span> +<br>            poolNumber.getAndIncrement() +<br>            <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>RejectedExecutionHandler handler</strong></p><p><strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</p><ol><li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常。</li><li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li></ol></li></ul><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220507130735644.png" alt="image-20220507130735644"> </p><ul><li>线程池创建后处于<strong>RUNNING</strong>状态。</li><li>调用<strong>shutdown()<strong>方法后处于</strong>SHUTDOWN</strong>状态，线程池不能接受新的任务，清除一些空闲worker，等待阻塞队列的任务完成。</li><li>调用shutdownNow()方法后处于<strong>STOP</strong>状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize=0,阻塞队列的size也为0。</li><li>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为<strong>TIDYING</strong>状态。接着会执行terminated()函数。</li></ul><h5 id="如何优雅的关闭线程池"><a href="#如何优雅的关闭线程池" class="headerlink" title="如何优雅的关闭线程池"></a>如何优雅的关闭线程池</h5><p><a href="https://segmentfault.com/a/1190000038258152">https://segmentfault.com/a/1190000038258152</a></p><h4 id="工作原理简述"><a href="#工作原理简述" class="headerlink" title="工作原理简述"></a>工作原理简述</h4><blockquote><p>addWork(command, true) —-&gt; offer() —-&gt; addWork(null, false) —-&gt; reject()</p></blockquote><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220505113517803.png" alt="image-20220505113517803" style="zoom:80%;" /> <ol><li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong>(可以使用preStartAllCoreThreads()预加载所有核心线程)</li><li>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li><li>当缓存队列满了，需要创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li><li>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li></ol><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a><a href="https://www.cnblogs.com/tomakemyself/p/14018814.html">源码解析</a></h4><p>核心方法 execute()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();   <br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">// 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>       <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>           <span class="hljs-keyword">return</span>;<br>       c = ctl.get();<br>    &#125;<br>    <span class="hljs-comment">// 2.如果不小于corePoolSize，则将任务添加到workQueue队列。</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-comment">// 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。</span><br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>            <span class="hljs-comment">// 2.2 线程池处于running状态，但是没有线程，则创建线程</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.如果放入workQueue失败，则创建非核心线程执行任务，</span><br>    <span class="hljs-comment">// 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>         reject(command);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Java线程池是如何保证核心线程不被销毁的"><a href="#Java线程池是如何保证核心线程不被销毁的" class="headerlink" title="Java线程池是如何保证核心线程不被销毁的"></a><a href="https://blog.csdn.net/smile_from_2015/article/details/105259789">Java线程池是如何保证核心线程不被销毁的</a></h5><h4 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ThreadPool;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lunfee</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022/5/4-14:38</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LunfeeThreadPool</span> </span>&#123;<br>    BlockingQueue&lt;Runnable&gt; taskQueue;<br>    List&lt;WorkThread&gt; threads;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LunfeeThreadPool</span><span class="hljs-params">(BlockingQueue&lt;Runnable&gt; taskQueue, <span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.taskQueue = taskQueue;<br>        <span class="hljs-keyword">this</span>.threads  = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; capacity; i++) &#123;<br>            WorkThread workThread = <span class="hljs-keyword">new</span> WorkThread(<span class="hljs-string">&quot;Work-&quot;</span> + i);<br>            workThread.start();<br>            threads.add(workThread);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        taskQueue.put(task);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(name);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                Runnable task = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task = taskQueue.take();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                task.run();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM = <span class="hljs-number">10</span>;<br>        LunfeeThreadPool threadPool = <span class="hljs-keyword">new</span> LunfeeThreadPool(<span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">9</span>), <span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM; i++) &#123;<br>            threadPool.execute(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; execute a task...&quot;</span>);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="使用线程池案例-amp-参数设置"><a href="#使用线程池案例-amp-参数设置" class="headerlink" title="使用线程池案例&amp;参数设置"></a>使用线程池案例&amp;参数设置</h4><p>使用多线程的目的：是充分利用多核 CPU 资源，在尽可能减少线程上下文切换的同时，充分利用线程等待的 CPU 空闲时间</p><p>线程池大小需要参考的因素：</p><ol><li>机器当前 CPU 占用率</li><li>当前程序已启动线程数目</li><li><strong>当前任务 I/O 执行时间和运算时间占比</strong></li></ol><p>参数设置</p><blockquote><p>网上有一个流传的公式：CPU 密集型设置为 CORE_NUM + 1，I/O 密集型 CORE_NUM * 2 + 1，考虑是否 I/O 密集是没错的，但是这样的设置比较绝对，我想一般没有人这么用；一般的后端系统都是伴随着数据处理+网络I/O+数据库I/O，所以重要的是二者的比例，理论上，如果没有 I/O 操作的话，线程数设置为 CORE_NUM 就可以了，这样做使得每个内核同时执行的话都跑满；这时如果 I/O 时间越多，就意味着 CPU 空闲时间越长，就可以开更多的线程提高利用率，所以我觉得如果一定要有一个参考公式的话应该用</p><p>Nthreads = Ncores x Ruse x (R(IO / 计算) + 1)</p></blockquote><p>使用经验</p><blockquote><p>我做过一个核酸检测结果统计的项目，由于政府提供的接口只能一条一条的查询，即使我们把数据库存储优化到极致，也没办法突破每个查询的200ms 的网络等待，项目最初就是一个一天一次的半夜定时任务，一次执行要3-4个小时，计算时间，也就是内存的操作时间很短，理论上可以开 CORE_NUM 好几倍的线程数，但是考虑到网络超时的问题，最后设置的是 2 * CORE_NUM，时间降低到几分钟，就可以使用一个异步的<strong>观察者模式</strong>手动触发然后统计报表。</p></blockquote><h4 id="为什么不推荐使用Executors创建线程池"><a href="#为什么不推荐使用Executors创建线程池" class="headerlink" title="为什么不推荐使用Executors创建线程池"></a>为什么不推荐使用Executors创建线程池</h4><p>阿里巴巴Java开发手册中提到，不要使用 Executors 创建线程池，一方面为了明确线程池的使用规则，另一方面防止资源耗尽。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> executers;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lunfee</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022/5/7-13:17</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//同步队列，核心线程数为零，最大线程数为 Integer.MAX_VALUE，可能导致资源耗尽</span><br>        Executors.newCachedThreadPool();<br>        <span class="hljs-comment">//fixed指的是核心线程数和最大线程数相等，阻塞队列无边界，可以放入无限多任务</span><br>        Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//所有任务由一个线程执行，阻塞队列无边界</span><br>        Executors.newSingleThreadExecutor();<br>        <span class="hljs-comment">//延时队列，最大线程数 Integer.MAX_VALUE</span><br>        Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><blockquote><p>从 CPU 调度的角度讲：并发指的是多个线程在同一个 CPU 内核上执行，CPU 为每个线程分配时间片轮流执行；并行则是不同的线程在不同的 CPU 内核上同时执行；</p><p>从程序或者接口的角度讲：并发指的是，某一时刻，多个用户同时访问某段程序，</p></blockquote><h4 id="为什么创建线程是expensive"><a href="#为什么创建线程是expensive" class="headerlink" title="为什么创建线程是expensive"></a>为什么创建线程是expensive</h4><p>每创建一个线程都对应操作系统注册和创建一个本地线程</p><p>JVM会为线程创建一个较大的栈空间，并初始化</p><h4 id="Thread-start-方法"><a href="#Thread-start-方法" class="headerlink" title="Thread start 方法"></a>Thread start 方法</h4><ol><li><p><strong>直接调用 Runnable 的方法</strong>不可以以开启线程的方式执行，因为 Java 线程和操作系统线程一一对应，必须执行本地方法 start0() 完成线程创建。</p></li><li><p><strong>不能反复或者在线程结束调用 start 方法</strong>，因为在执行的时候会检查 threadState 是为0(NEW)，否则会抛出非法的线程状态异常。</p></li></ol><h4 id="线程状态与转换"><a href="#线程状态与转换" class="headerlink" title="线程状态与转换"></a>线程状态与转换</h4><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.drawio.png" style="zoom:85%;" /> <h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><blockquote><p>同步是多线程情况下，不同线程之间按照一定的顺序执行，保证运行结果的正确性</p></blockquote><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/%E5%90%8C%E6%AD%A5.drawio.png" alt="同步.drawio"> </p><h4 id="wait-和-sleep-区别"><a href="#wait-和-sleep-区别" class="headerlink" title="wait() 和 sleep() 区别"></a>wait() 和 sleep() 区别</h4><p><a href="">stackoverflow</a></p><p><a href="https://stackoverflow.com/questions/9417260/when-is-it-sensible-to-use-thread-sleep">why not to use sleep() int production code</a></p><blockquote><p>二者都会调用本地方法，使线程不占用 CPU，进入等待。操作系统不会为他们分配任何时间片</p><p><em>1.<strong>机制</strong></em>：wait() 是同步监视器 Object 的方法，用于通过线程间通信的方式完成同步功能；sleep() 是 Thread 类的方法，用于延迟指定时间</p><p><em>2.<strong>位置</strong></em>：wait() 和 notify() 是建立在内置监视器的基础之上的，<strong>必须要在 synchronized 代码块中执行</strong>，而且 <strong>wait() 会释放同步锁</strong>，sleep() 可以在线程的任何位置使用，<strong>在同步代码块中也不会释放锁</strong>。</p><p><em>3.<strong>状态</strong></em>：执行不带延时的 wait() 会进入 waiting 状态，而 sleep() 进入 time_waiting 状态；唤醒 wait() 使用 notify() 或者 notifyAll() ，多个线程被唤醒之后可能进入 block 状态；sleep() timeout 后自然唤醒，进入runnable 状态；</p><p><em>4.<strong>使用</strong></em>：使用 wait() 完成线程间同步功能，sleep() 在测试的时候使用延迟固定时间</p></blockquote><h5 id="补充：中断"><a href="#补充：中断" class="headerlink" title="补充：中断"></a>补充：<a href="https://www.geeksforgeeks.org/interrupting-a-thread-in-java/">中断</a></h5><blockquote><p>In Java Threads, if any thread is in sleeping or waiting state (i.e. sleep() or wait() is invoked), calling the interrupt() method on the thread, <strong>breaks out the sleeping or waiting state throwing InterruptedException</strong>. If the thread is not in the sleeping or waiting state, calling the interrupt() method <strong>performs normal behavior and doesn’t interrupt the thread but sets the interrupt flag to true</strong>. </p></blockquote><h5 id="补充：yield"><a href="#补充：yield" class="headerlink" title="补充：yield()"></a>补充：yield()</h5><p>告诉操作系统，可以放弃当前线程的时间片，操作系统不一定会真的不执行，放弃不过是希望其它线程由机会使用 CPU 资源</p><p>在实际开发中一般不使用，在测试环境下可能会使用</p><h5 id="补充：在生产环境中，不使用-sleep-的原因"><a href="#补充：在生产环境中，不使用-sleep-的原因" class="headerlink" title="补充：在生产环境中，不使用 sleep() 的原因"></a>补充：在生产环境中，不使用 sleep() 的原因</h5><p><a href="https://stackoverflow.com/questions/9417260/when-is-it-sensible-to-use-thread-sleep">resons</a></p><blockquote><p>首先在任何情况下不要用 sleep() 完成线程间同步</p><p>不要在 UI 层使用 sleep() </p><p>不要用 sleep() 做精确定时任务</p></blockquote><h5 id="实战（记录一次code-review）"><a href="#实战（记录一次code-review）" class="headerlink" title="实战（记录一次code review）"></a>实战（记录一次code review）</h5><p><a href="http://www.qat.com/using-waitnotify-instead-thread-sleep-java/">来源</a></p><blockquote><p>在做代码检查的时候遇到过一次误用 sleep() 的案例</p><p>这个同学要实现的是一个图片处理和上传功能，为了实现异步，开启一个线程完成图片处理的功能，主线程完成其它操作后，等待处理结束，完成上传。</p><p>他的做法是在主线程使用一个 while 循环不断的进行 boolean check，没完成处理的情况下就 sleep，这明显是线程同步的一个误用，等待时间短会频繁的进行 boolean check，时间长可能造成响应变慢。应当使用等待通知机制。</p></blockquote><h4 id="sync的优化"><a href="#sync的优化" class="headerlink" title="sync的优化"></a>sync的优化</h4><p>偏向锁</p><p>自旋锁</p><h4 id="sync底层原理"><a href="#sync底层原理" class="headerlink" title="sync底层原理"></a>sync底层原理</h4><blockquote><p>编译，monitor，对象头，锁优化</p></blockquote><p><a href="https://stackoverflow.com/questions/3362303/whats-a-monitor-in-java">https://stackoverflow.com/questions/3362303/whats-a-monitor-in-java</a></p><p>监视器（管程）是一个并发控制的机制，保证只用一个线程能执行临界区的代码，维护线程间的等待通知机制</p><p>enter the monitor (编译monitor enter)</p><p>acquire the monitor</p><p>owing the monitor </p><p>release the monitor(编译monitor exit)</p><h4 id="sync-和-Lock的比较"><a href="#sync-和-Lock的比较" class="headerlink" title="sync 和 Lock的比较"></a>sync 和 Lock的比较</h4><p>公平非公平</p><p>是否可中断（lockInterrupted）</p><p>关联多个条件（Condition），针对性的唤醒</p><p>sync 更加简单，在业务中方便使用（尤其是1.6优化之后），Lock 复杂，在设计高效的数据结构或者源码中使用的多（我们一般使用线程的工具就好）</p><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS 调用的是本地方法，例如 Intel 通过处理器指令 CMPXCHG 在硬件上保证交换的原子性操作</p><p>它之所以高效，是因为与加锁相比它避免了互斥等待时间，和上下文切换</p><p>使用 CAS 的方法在 swap 失败后一般会选择放弃，或循环重试（这种方式是在保证操作至少执行一次的情况下使用）</p><p>这种操作会有几个问题</p><ol><li>仅仅是值的比较，可能会有 ABA 问题，这可以通过版本号解决</li><li>只能保证一个变量的原子性，所以一般在状态位，或者实现原子类的时候使用</li><li>在状态转换中一般是失败返回，但是在原子类的操作中，一般是失败循环重试（do while），竞争较大的时候可能比较消耗 CPU 资源</li></ol><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>语义：易变的</p><p>一般用于状态标志，或者充当信号量（boolean check），不能保证原子性</p><p>可见性保证（JMM）</p><p><strong>禁止指令重排序</strong>（单例模式中的应用）</p><h4 id="User-Mode-Kernel-Mode"><a href="#User-Mode-Kernel-Mode" class="headerlink" title="User Mode Kernel Mode"></a><a href="https://stackoverflow.com/questions/1311402/what-is-the-difference-between-user-and-kernel-modes-in-operating-systems">User Mode Kernel Mode</a></h4><p><a href="https://www.geeksforgeeks.org/user-mode-and-kernel-mode-switching/">geek</a></p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a><a href="https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread">协程</a></h4><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220526220118173.png" alt="image-20220526220118173"></p><h4 id="类加载与new对象"><a href="#类加载与new对象" class="headerlink" title="类加载与new对象"></a>类加载与new对象</h4><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/new_%E5%AF%B9%E8%B1%A1.drawio.png" alt="new_对象.drawio"></p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><img src="E:\blog\source\_posts\drawio\垃圾面试.drawio.png" alt="垃圾面试.drawio" style="zoom:100%;" /><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>Why</p><p>开发过程中最简单的后台也是分为 Controller， Service，Repository层，每一层专注于做一件事情。</p><ul><li><p><strong>「计算机系统细化」</strong>进程间的网络通信本来是复杂的工作，分层方便制定标准<strong>「不同层使用不同的协议」</strong></p></li><li><p><strong>「各层之间相互独立」</strong>只需要调用下层接口实现本层逻辑。<strong>「高内聚低耦合」</strong></p></li><li><p><strong>「提高了整体灵活性」</strong>可以根据需求定制化不同的实现，给上层提供好一致的接口即可。<strong>「在TCP和Http之间加入TLS增加安全性」</strong></p></li></ul><p>How</p><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82.png" alt="网络分层"> </p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Chttp.drawio.png" alt="计算机网络http.drawio"> </p><h4 id="Post请求和Get请求"><a href="#Post请求和Get请求" class="headerlink" title="Post请求和Get请求"></a>Post请求和Get请求</h4><p><a href="https://xiaolincoding.com/network/2_http/http_interview.html#get-%E5%92%8C-post-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">引用</a></p><blockquote><p>二者都是Http的请求方式；</p><p>区别：</p><p><em>1. <strong>语义</strong></em></p><ul><li>Get 请求的语义是通过 RUL 从服务器获取指定资源</li><li>Post 请求的语义是通过 Payload 对服务器的资源做做出处理</li></ul><p><em>2. <strong>参数</strong></em></p><ul><li>Get 请求参数以键值对的方式直接拼接到 URL 中，参数是可见的；同时会收到浏览器 URL 长度限制（2048字符）</li><li>Post 请求参数放在 Payload 中，是不可见的；请求长度不受限制</li></ul><p><em>3. <strong>安全</strong></em>（http 为明文传输，都是不安全的，保证安全应当使用Https）</p><ul><li>Get 请求参数是可见的，相对来说更不安全</li><li>Post 请求参数不可见，相对更安全</li></ul><p><em>4. <strong>幂等与缓存</strong></em></p><ul><li>一般情况下，对同一资源的 Get 请求的响应式一样的（幂等），所以会对 Get 请求做强制缓存或者协商缓存</li><li>Post 请求的响应是不同的（非幂等），因此不会进行缓存，也不保留历史，书签等</li></ul><p><em>5. <strong>请求次数</strong></em></p><ul><li>Get 请求是简单请求，只发送一次请求数据</li><li>Post 可能构成<a href="https://juejin.cn/post/6976817041625841701">非简单请求</a>，可能发送两次请求（Options 探测请求 + Post 请求）</li></ul></blockquote><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><h5 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h5><ul><li><p>强制缓存：</p><p>由浏览器决定缓存过期时间</p><ul><li><code>Cache-Control</code>， 是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul></li><li><p><a href="https://xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">协商缓存</a></p><p>由服务器决定是否使用缓存</p><p>通过请求<strong>资源是否发生变化</strong>来确定 </p><ul><li><p>最后修改<strong>时间</strong> Last-Modified</p><p>或</p></li><li><p><strong>资源唯一标识符</strong> Etag</p></li></ul></li></ul><h4 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h4><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86">引用</a></p><blockquote><p>二者都是<strong>传输层</strong>的协议；</p><p>区别：</p><p><em>1. <strong>连接</strong></em>（三次握手四次挥手）</p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接</li><li>UDP 是不需要连接</li></ul><p><em>2. <strong>传输方式</strong></em></p><ul><li>TCP 是面向字节流的传输，数据包没有边界；但可以通过序列号保证有序。</li><li>UDP 是一个包一个包的发送，是有边界的；但可能会丢包和乱序。</li></ul><p><em>3. <strong>可靠性</strong></em></p><ul><li>TCP 可以保证数据的可靠性；数据可以无差错、不丢失、不重复。</li><li>UDP 不保证可靠交付数据。</li></ul><p><em>4. <strong>拥塞控制、流量控制</strong></em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有。</li></ul><p><em>5. <strong>首部开销</strong></em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. <strong>分片不同</strong></em></p><ul><li><p>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</p></li><li><p>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p><p>细节：</p><p>Maximum Segment Size 最大分段大小（传输层）</p><p>Maximum Transmission Unit 最大传输单元 （网络层）</p><p>IP 层没有重传机制，一旦丢包就需要全部重传，所以 MSS 刻意设置的比 MTU 小一些（1500 - 1450），尽可能在 TCP 层进行分片，保证可靠性和效率</p></li></ul></blockquote><h5 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h5><h5 id="报文结构："><a href="#报文结构：" class="headerlink" title="报文结构："></a>报文结构：</h5><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220503141427045.png" alt="image-20220503141427045" style="zoom: 60%;" /><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/image-20220503161727384.png" alt="image-20220503161727384" style="zoom: 60%;" /></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="https://pic-lunfee.oss-cn-beijing.aliyuncs.com/picgo/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="三次握手.drawio"></p><h5 id="为什么三次，两次不行？"><a href="#为什么三次，两次不行？" class="headerlink" title="为什么三次，两次不行？"></a>为什么三次，两次不行？</h5><p>直观上：三次握手能保证客户端和服务端的发送和接收的能力</p><p>设计上：</p><ul><li>主要原因：防止在网络不佳的情况下，<a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">旧的连接</a>造成混乱</li><li>同步序列号：三次握手伴随着两次 SYN 的发送和 ACK 的确认，同步了客户端和服务端的序列号</li><li>由于超时重传可能导致同一个请求，建立多个连接</li></ul><h4 id="TCP重传"><a href="#TCP重传" class="headerlink" title="TCP重传"></a><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">TCP重传</a></h4><h4 id="Https握手"><a href="#Https握手" class="headerlink" title="Https握手"></a><a href="https://juejin.cn/post/6847902219745181709">Https握手</a></h4><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="单例模式-Spring-单例"><a href="#单例模式-Spring-单例" class="headerlink" title="单例模式 != Spring 单例"></a>单例模式 != Spring 单例</h4><p>设计模式中的单例模式指的是对于同一个类，只会创建唯一的一个对象，该类不能使用 new 关键字创建对象，因为构造器是私有的，只能通过调用一个 static 方法（通常为 getInstance）返回同一个实例</p><p>Spring 中的 bean 作用域 Singleton scope 和单例模式没什么关系，只代表当前的 bean 只会被实例化一次，但是并不要求当前类只有一个对象，也不要求构造器私有。</p><blockquote><p>Spring 中的作用域有 Singleton，Prototype，Request（每一个http 请求），Session</p></blockquote><p>那单例模式有什么应用吗</p><p>写一个安全的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br><br>    <span class="hljs-comment">// Pay attention to volatile</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Foo INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// TODO Add private shouting constructor</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Foo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Check 1 防止同步太多次</span><br>            <span class="hljs-keyword">synchronized</span> (Foo.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Check 2</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> Foo();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单例模式-vs-静态类"><a href="#单例模式-vs-静态类" class="headerlink" title="单例模式 vs 静态类"></a>单例模式 vs 静态类</h4><p>为什么要用单例模式呢，静态类不是也可以保证只有一个“实例”吗</p><blockquote><p>原因是使用单例模式的对象就是一个普通的对象，可以作为参数传递，而且可以实现接口，比静态方法要灵活</p></blockquote><h4 id="aqs-模板方法"><a href="#aqs-模板方法" class="headerlink" title="aqs: 模板方法"></a>aqs: 模板方法</h4><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><h3 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br><br>    <span class="hljs-comment">// Pay attention to volatile</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Foo INSTANCE = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">// TODO Add private shouting constructor</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Foo <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Check 1 防止同步太多次</span><br>            <span class="hljs-keyword">synchronized</span> (Foo.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Check 2</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> Foo();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ThreadPool;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.ArrayBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lunfee</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022/5/4-14:38</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LunfeeThreadPool</span> </span>&#123;<br>    BlockingQueue&lt;Runnable&gt; taskQueue;<br>    List&lt;WorkThread&gt; threads;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LunfeeThreadPool</span><span class="hljs-params">(BlockingQueue&lt;Runnable&gt; taskQueue, <span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.taskQueue = taskQueue;<br>        <span class="hljs-keyword">this</span>.threads  = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; capacity; i++) &#123;<br>            WorkThread workThread = <span class="hljs-keyword">new</span> WorkThread(<span class="hljs-string">&quot;Work-&quot;</span> + i);<br>            workThread.start();<br>            threads.add(workThread);<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        taskQueue.put(task);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkThread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(name);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                Runnable task = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task = taskQueue.take();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                task.run();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM = <span class="hljs-number">10</span>;<br>        LunfeeThreadPool threadPool = <span class="hljs-keyword">new</span> LunfeeThreadPool(<span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">9</span>), <span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM; i++) &#123;<br>            threadPool.execute(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; execute a task...&quot;</span>);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><a href="https://segmentfault.com/a/1190000040336213">HashMap</a></h4><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleList</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">int</span> value;<br>        DoubleList prev;<br>        DoubleList next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleList</span><span class="hljs-params">()</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, DoubleList&gt; map;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    DoubleList head;<br>    DoubleList tail;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        head = <span class="hljs-keyword">new</span> DoubleList();<br>        tail = <span class="hljs-keyword">new</span> DoubleList();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        DoubleList temp = map.get(key);<br>        <span class="hljs-keyword">if</span>(temp == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        removeNode(temp);<br>        <br>        addHead(temp);<br>        <span class="hljs-keyword">return</span> temp.value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHead</span><span class="hljs-params">(DoubleList node)</span> </span>&#123;<br>        node.next = head.next;<br>        head.next.prev = node;<br>        head.next = node;<br>        node.prev = head;<br>        <br>        map.put(node.key, node);<br>        <br>        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DoubleList node)</span> </span>&#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>        map.remove(node.key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(key)) &#123;<br>            DoubleList temp = map.get(key);<br>            removeNode(temp);<br>            <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(capacity == map.size()) &#123;<br>            removeNode(tail.prev);<br>        &#125;<br>        <br>        addHead(<span class="hljs-keyword">new</span> DoubleList(key, value));<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><a href="https://juejin.cn/post/6844904196852940808#comment">负载均衡</a></h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/29/re/%E7%BD%91%E7%BB%9Cio/"/>
    <url>/2022/03/29/re/%E7%BD%91%E7%BB%9Cio/</url>
    
    <content type="html"><![CDATA[<h1 id="I-O到底是什么"><a href="#I-O到底是什么" class="headerlink" title="I/O到底是什么?"></a>I/O到底是什么?</h1><p>I/O 其实就是 input 和 output 的缩写，即输入/输出。</p><p>那输入输出啥呢？</p><p>比如我们用键盘来敲代码其实就是输入，那显示器显示图案就是输出，这其实就是 I/O。</p><p>而我们时常关心的磁盘 I/O 指的是硬盘和内存之间的输入输出。</p><p>读取本地文件的时候，要将磁盘的数据拷贝到内存中，修改本地文件的时候，需要把修改后的数据拷贝到磁盘中。</p><p>网络 I/O 指的是网卡与内存之间的输入输出。</p><p>当网络上的数据到来时，网卡需要将数据拷贝到内存中。当要发送数据给网络上的其他人时，需要将数据从内存拷贝到网卡里。</p><p>那为什么都要跟内存交互呢?</p><p>我们的指令最终是由 CPU 执行的，究其原因是 CPU 与内存交互的速度远高于 CPU 和这些外部设备直接交互的速度。</p><p>因此都是和内存交互，当然假设没有内存，让 CPU 直接和外部设备交互，那也算 I/O。</p><p>总结下：I/O 就是指内存与外部设备之间的交互（数据拷贝）。</p><p>好了，明确什么是 I/O 之后，让我们来揭一揭 socket 通信内幕~</p><h1 id="创建-socket"><a href="#创建-socket" class="headerlink" title="创建 socket"></a>创建 socket</h1><p>首先服务端需要先创建一个 socket。在 Linux 中一切都是文件，那么创建的 socket 也是文件，每个文件都有一个整型的文件描述符（fd）来指代这个文件。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> socket(<span class="hljs-type">int</span> <span class="hljs-keyword">domain</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">type</span>, <span class="hljs-type">int</span> protocol);<br></code></pre></td></tr></table></figure><ul><li>domain：这个参数用于选择通信的协议族，比如选择 IPv4 通信，还是 IPv6 通信等等</li><li>type：选择套接字类型，可选字节流套接字、数据报套接字等等。</li><li>protocol：指定使用的协议。</li></ul><p>这个 protocol 通常可以设为 0 ，因为由前面两个参数可以推断出所要使用的协议。</p><p>比如<code>socket(AF_INET, SOCK_STREAM, 0);</code>，表明使用 IPv4 ，且使用字节流套接字，可以判断使用的协议为 TCP 协议。</p><p>这个方法的返回值为 int ，其实就是创建的 socket 的 fd。</p><h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p>现在我们已经创建了一个 socket，但现在还没有地址指向这个 socket。</p><p>众所周知，服务器应用需要指明 IP 和端口，这样客户端才好找上门来要服务，所以此时我们需要指定一个地址和端口来与这个 socket 绑定一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>参数里的 sockfd 就是我们创建的 socket 的文件描述符，执行了 bind 参数之后我们的 socket 距离可以被访问又更近了一步。</p><h1 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h1><p>执行了 socket、bind 之后，此时的 socket 还处于 closed 的状态，也就是不对外监听的，然后我们需要调用 listen 方法，让 socket 进入被动监听状态，这样的 socket 才能够监听到客户端的连接请求。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;<br></code></pre></td></tr></table></figure><p>传入创建的 socket 的 fd，并且指明一下 backlog 的大小。</p><p>这个 backlog 我查阅资料的时候，看到了三种解释：</p><ol><li>socket 有一个队列，同时存放已完成的连接和半连接，backlog为这个队列的大小。</li><li>socket 有两个队列，分别为已完成的连接队列和半连接队列，backlog为这个两个队列的大小之和。</li><li>socket 有两个队列，分别为已完成的连接队列和半连接队列，backlog仅为已完成的连接队列大小。</li></ol><blockquote><p>解释下什么叫半连接</p></blockquote><p>我们都知道 TCP 建立连接需要三次握手，当接收方收到请求方的建连请求后会返回 ack，此时这个连接在接收方就处于半连接状态，当接收方再收到请求方的 ack 时，这个连接就处于已完成状态：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGRSgqjOHJJJFxcQFaoaCCx9cOpkOnhNpWCMKNNsh1riayUI7BJwnuIiaeRZTlPV0ic2LcLGRB7KdzKA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>所以上面讨论的就是这两种状态的连接的存放问题。</p><p>我查阅资料看到，基于 BSD 派生的系统的实现是使用的一个队列来同时存放这两种状态的连接， backlog 参数即为这个队列的大小。</p><p>而 Linux 则使用两个队列分别存储已完成连接和半连接，且 backlog 仅为已完成连接的队列大小</p><h1 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h1><p>现在我们已经初始化好监听套接字了，此时会有客户端连上来，然后我们需要处理这些已经完成建连的连接。</p><p>从上面的分析我们可以得知，三次握手完成后的连接会被加入到已完成连接队列中去。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGRSgqjOHJJJFxcQFaoaCCxY4SRXk80T3g5QgZYROsmtIAq2Grsib0zRC2LBSXEIJkdHO36ib7CyiaLg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>这时候，我们就需要从已完成连接队列中拿到连接进行处理，这个拿取动作就由 accpet 来完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>这个方法返回的 int 值就是拿到的已完成连接的 socket 的文件描述符，之后操作这个 socket 就可以进行通信了。</p><p>如果已完成连接队列没有连接可以取，那么调用 accept 的线程会阻塞等待。</p><blockquote><p>至此服务端的通信流程暂告一段落，我们再看看客户端的操作。</p></blockquote><h1 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h1><p>客户端也需要创建一个 socket，也就是调用 <code>socket()</code>，这里就不赘述了，我们直接开始建连操作。</p><p>客户端需要与服务端建立连接，在 TCP 协议下开始经典的三次握手操作，再看一下上面画的图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGRSgqjOHJJJFxcQFaoaCCx9cOpkOnhNpWCMKNNsh1riayUI7BJwnuIiaeRZTlPV0ic2LcLGRB7KdzKA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>客户端创建完 socket 并调用 <code>connect</code> 之后，连接就处于 <code>SYN_SEND</code> 状态，当收到服务端的 <code>SYN+ACK</code> 之后，连接就变为 <code>ESTABLISHED</code> 状态，此时就代表三次握手完毕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>调用<code>connect</code>需要指定远程的地址和端口进行建连，三次握手完毕之后就可以开始通信了。</p><p>客户端这边不需要调用 bind 操作，默认会选择源 IP 和随机端口。</p><p>用一幅图来小结一下建连的操作：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGRSgqjOHJJJFxcQFaoaCCx9TtyBaDibB7wAUDFibHSuwAYTL8J0kf7PPJQqECsibwSCoDuWhhDtEBAg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">可以看到这里的两个阻塞点：</p><ul><li>connect：需要阻塞等待三次握手的完成。</li><li>accept：需要等待可用的已完成的连接，如果已完成连接队列为空，则被阻塞。</li></ul><h1 id="read、write"><a href="#read、write" class="headerlink" title="read、write"></a>read、write</h1><p>连接建立成功之后，就能开始发送和接收消息了，我们来看一下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nGRSgqjOHJJJFxcQFaoaCCxQV6kDhmyL816BgiagtUXXFicO5esmnCb0W8fxicKTXDownvCRVxI85a3A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image">read 为读数据，从服务端来看就是等待客户端的请求，如果客户端不发请求，那么调用 read 会处于阻塞等待状态，没有数据可以读，这个应该很好理解。</p><p>write 为写数据，一般而言服务端接受客户端的请求之后，会进行一些逻辑处理，然后再把结果返回给客户端，这个写入也可能会被阻塞。</p><p>这里可能有人就会问 read 读不到数据阻塞等待可以理解，write 为什么还要阻塞，有数据不就直接发了吗？</p><p>因为我们用的是 TCP 协议，TCP 协议需要保证数据可靠地、有序地传输，并且给予端与端之间的流量控制。</p><p>所以说发送不是直接发出去，它有个发送缓冲区，我们需要把数据先拷贝到 TCP 的发送缓冲区，由 TCP 自行控制发送的时间和逻辑，有可能还有重传什么的。</p><p>如果我们发的过快，导致接收方处理不过来，那么接收方就会通过 TCP 协议告知：别发了！忙不过来了。发送缓存区是有大小限制的，由于无法发送，还不断调用 write 那么缓存区就满了，满了就不然你 write 了，所以 write 也会发生阻塞。</p><p>综上，read 和 write 都会发生阻塞。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote><p>为什么网络 I/O 会被阻塞？</p></blockquote><p>因为建连和通信涉及到的 accept、connect、read、write 这几个方法都可能会发生阻塞。</p><p>阻塞会占用当前执行的线程，使之不能进行其他操作，并且频繁阻塞唤醒切换上下文也会导致性能的下降。</p><p>由于阻塞的缘故，起初的解决的方案就是建立多个线程，但是随着互联网的发展，用户激增，连接数也随着激增，需要建立的线程数也随着一起增加，到后来就产生了 C10K 问题。</p><p>服务端顶不住了呀，咋办？</p><p>优化呗！</p><p>所以后来就弄了个非阻塞套接字，然后 I/O多路复用、信号驱动I/O、异步I/O。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/29/re/mysql/"/>
    <url>/2022/03/29/re/mysql/</url>
    
    <content type="html"><![CDATA[<h4 id="175-组合两个表"><a href="#175-组合两个表" class="headerlink" title="175. 组合两个表"></a><a href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></h4><p><img src="https://raw.githubusercontent.com/lunfee/picgo/main/img/image-20220329133209535.png?token=AJECWBOXBUZWAXKVMSDBTXDCIKNB2" alt="image-20220329133209535"> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select  firstName, lastName, city, state<br>from <br>person left join address<br>on <br>Person.personId = Address.personId;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/lunfee/picgo/main/img/ad3df1c4ecc7d2dbe85f92cdde8ec9a731fdd20dc4c5629ecb372b21de26c682-1.jpg?token=AJECWBNOOUEEO52PBDDE2LDCIKNIW" alt="1.jpg"> </p><h4 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176. 第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></h4><p><img src="https://raw.githubusercontent.com/lunfee/picgo/main/img/image-20220329134642493.png?token=AJECWBPPXGG2QOC4QDK6IYTCIKOX6" alt="image-20220329134642493"> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/17/re/linux/"/>
    <url>/2022/03/17/re/linux/</url>
    
    <content type="html"><![CDATA[<p>netstat -tunlp |grep 8080  查看某个端口的进程信息 </p><p>pid: process ID</p><p>ppid: parent proessID</p><p>jps: 显示HotSpot虚拟机的所有进程pid</p><p>ps -ef</p><p>tail -10 log</p><p>tail -f </p><p>head -10 log</p><p>stat log 查看文件inode信息</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/08/re/%E5%BF%AB%E6%89%8B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/08/re/%E5%BF%AB%E6%89%8B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><p>数据结构在面试中占比约30</p><hr><ul><li><p>知道哪些数据结构以及他们的特点</p><blockquote><p>存储结构</p><ul><li><strong>数组（Array）：</strong>数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。</li><li><strong>链表（Linked List）：</strong>链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。</li></ul><p>逻辑结构</p><ul><li><strong>栈（Stack）：</strong>栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。</li><li><strong>队列（Queue）：</strong>队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。</li><li><strong>树（Tree）：</strong>树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。</li><li><strong>图（Graph）：</strong>图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。</li><li><strong>堆（Heap）：</strong>数据结构中的堆在逻辑上是树型结构，二叉堆是完全二叉树。存储上使用的数组，按索引查找。</li><li><strong>散列表（Hash table）：</strong>散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。</li></ul></blockquote></li><li><p>如何提高链表的查询效率</p><blockquote><p><a href="https://docs.data-structures.knowledge-precipitation.site/cha-zhao/tiao-biao">https://docs.data-structures.knowledge-precipitation.site/cha-zhao/tiao-biao</a></p></blockquote></li><li><p>上一题的衍生问题：为什么 Redis 要用跳表而不是红黑树来实现有序集合</p><blockquote><p><a href="https://www.zhihu.com/question/20202931">https://www.zhihu.com/question/20202931</a></p></blockquote></li><li><p>大顶堆和小顶堆的用途</p><blockquote><p><code>topK</code>问题，排序</p></blockquote></li><li><p>B+树，数据库索引，B-树，数据库为什么用树存储结构（I/O）</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/54102723">https://zhuanlan.zhihu.com/p/54102723</a></p></blockquote></li><li><p>长短地址映射</p><blockquote></blockquote></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/06/re/java%E9%94%81/"/>
    <url>/2022/03/06/re/java%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="由单例模式深入-Java-锁"><a href="#由单例模式深入-Java-锁" class="headerlink" title="由单例模式深入 Java 锁"></a>由单例模式深入 Java 锁</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>下面的代码是一段经典的饿汉式的单例模式写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javal;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lunfee</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022/3/6-14:53</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//懒汉式单例模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//B. 可见性</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//p.</span><br><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<span class="hljs-comment">//1.</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// A. DCL （Double Check Lock双端检锁机制）</span><br>                    instance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">//2.</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是在同一 JVM 下线程同步的写法，保证多线程的实例唯一性，这里由两个需要注意的点（A. B.），我们从这两个点深入理解一下Java种的锁机制。</p><ul><li><p>A. Double Check，synchronized 关键字是一种对象锁的实现方式，由它修饰的代码块或者方法，能保证在临界区内的代码原子性，p 处对 instance 的判断不在同步块内，无法保证其读写原子性。在没有Double Check时，可能发生下面这种情况：Thread1 和 Thread2 同时执行到 p. 处， 都判断 instance == null 为 True，然后一次获取锁，完成对象的实例化，导致实例化多次。</p></li><li><p>B. volatile，仅仅做Double Check的话，任然会有问题，原因时有指令重排的存在，加入volatile可以禁止指令重排</p><p>原因是在某一个线程执行到第一次检测，读取到instance不为null时，instance的引用对象可能没有完成初始化。instance=new SingleDemo();可以被分为一下三步（<a href="https://www.zhihu.com/search?q=%E4%BC%AA%E4%BB%A3%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2140946313%7D">伪代码</a>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">memory = allocate();//1.分配对象内存空间<br>instance(memory); //2.初始化对象<br>instance = memory; //3.设置instance执行刚分配的内存地址，此时instance!=null<br></code></pre></td></tr></table></figure><p>步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的</p><p>所以如果3步骤提前于步骤2，但是instance还没有初始化完成指令重排只会保证串行语义的执行的一致性（单线程），但并不关心多线程间的语义一致性。</p><p>所以当一条线程访问instance不为null时，由于instance示例未必已初始化完成，也就造成了线程安全问题。</p><p>此时加上volatile后就不会出现线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//B. 可见性</span><br></code></pre></td></tr></table></figure><p>因为volatile禁止了指令重排序的问题</p></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li>volatile 关键字保证了修饰变量的可见性</li></ul><blockquote><p>读：忽略本地内存的变量  &gt;  直接读取主内存种的变量</p><p>赋值：直接读取主内存种的变量  &gt; 存入本地内存  &gt;  赋值  &gt;  刷入主内存</p></blockquote><p>在这种情况下，volatile 与 synchronized 一样保证了操作的原子性，但是这种保证，仅限于写操作与当前当前值无关的情况下。</p><p>对于运算等操作，无法使用 volatile 保证原子性。</p><blockquote><p>运算：直接读取主内存种的变量  &gt; 存入本地内存 &gt; 运算操作  &gt;  赋值  &gt;  刷入主内存</p></blockquote><ul><li>synchronized 时一种互斥锁，通过保证唯一的线程执行临界区代码，保证操作的原子性。</li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul><li>volatile 的可见性不在赘述。</li><li>synchronized 也能保证可见性，只不过不是实时的，</li></ul><h2 id="单一变量的高效锁-CAS-synchronized：大材小用"><a href="#单一变量的高效锁-CAS-synchronized：大材小用" class="headerlink" title="单一变量的高效锁 CAS (synchronized：大材小用)"></a>单一变量的高效锁 CAS (synchronized：大材小用)</h2><p>我们先来看几行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如有100个线程同时调用 increment() 方法对 i 进行自增操作，i 的结果会是 100 吗？</p><p>这个方法是线程不安全的，由于 i++ 不是一个<strong>原子操作</strong>，所以是很难得到 100 的。</p><p>那该怎么办呢？解决的策略一般都是给这个方法加个锁，如下（<strong>这里不能用volatile，因为无法保证原子性</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，一个简简单单的自增操作，就加了 synchronized 进行同步，好像有点大材小用的感觉，加了 synchronized 关键词之后，当有很多线程去竞争 increment 这个方法的时候，拿不到锁的方法是会被<strong>阻塞</strong>在方法外面的，最后再来唤醒他们，而阻塞/唤醒这些操作，是非常消耗资源的。</p><p>虽然synchronized 到了JDK1.6之后不是做了很多优化，增加了偏向锁、轻量级锁等， 但是，就算增加了这些，当很多线程来竞争的时候，开销依然很多（会升级）</p><h3 id="CAS-："><a href="#CAS-：" class="headerlink" title="CAS ："></a>CAS ：</h3><p>如果我采用下面这种方式，能否保证 increment 是线程安全的，步骤如下：</p><p>1、线程从内存中读取 i 的值，假如此时 i 的值为 0，我们把这个值称为 k 吧，即此时 k = 0。</p><p>2、令 j = k + 1。</p><p>3、用 k 的值与内存中i的值相比，如果相等，这意味着没有其他线程修改过 i 的值，我们就把 j（此时为1） 的值写入内存；如果不相等（意味着i的值被其他线程修改过），我们就不把j的值写入内存，而是重新跳回步骤 1，继续这三个操作。</p><p>翻译成代码的话就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">int</span> k = i;<br>        <span class="hljs-keyword">int</span> j = k + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">while</span> (compareAndSet(i, k, j))<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写是线程安全的。</p><p>这个 compareAndSet 操作，他其实只对应操作系统的<strong>一条硬件操作指令</strong>，尽管看似有很多操作在里面，但操作系统能够保证他是原子执行的。</p><p>对于一条英文单词很长的指令，我们都喜欢用它的简称来称呼他，所以，我们就把 compareAndSwap 称为 <strong>CAS</strong> 吧。</p><p>所以，采用 CAS 这种机制的写法也是线程安全的，通过这种方式，可以说是不存在锁的竞争，也不存在阻塞等事情的发生，可以让程序执行的更好。</p><p>在 Java 中，也是提供了这种 CAS 的原子类，例如：</p><ol><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicReference</li></ol><p>具体如何使用呢？我就以上面那个例子进行改版吧，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 自增 1并返回之后的结果</span><br>        i.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CAS源码中为什么有循环操作"><a href="#CAS源码中为什么有循环操作" class="headerlink" title="CAS源码中为什么有循环操作"></a>CAS源码中为什么有循环操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AtomicInteger num = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    num.getAndIncrement();<br>    System.out.println(num);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;<br>    <span class="hljs-comment">//Object var1 一般为this, long var2 为偏移量， int var4 为目标值</span><br>    <span class="hljs-keyword">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);<span class="hljs-comment">//内存中获取值</span><br>        <span class="hljs-comment">//执行CAS操作</span><br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>多个线程对同一个共享变量进行操作时，非常用以出现并发的问题，所以为了保证线程安全，都要对共享变量进行同步。</p><h4 id="合理的理解"><a href="#合理的理解" class="headerlink" title="合理的理解"></a>合理的理解</h4><p>ThreadLoal 变量，它的基本原理是，同一个 ThreadLocal 所包含的对象（对ThreadLocal&lt; String &gt;而言即为 String 类型变量），在不同的 Thread 中有不同的副本（实际是不同的实例，后文会详细阐述）。这里有几点需要注意</p><ul><li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来</li><li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题</li><li>既无共享，何来同步问题，又何来解决同步问题一说？</li></ul><p>那 ThreadLocal 到底解决了什么问题，又适用于什么样的场景？</p><blockquote><p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p></blockquote><p>核心意思是</p><blockquote><p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p></blockquote><p>总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</strong>后文会通过实例详细阐述该观点。另外，该场景下，并非必须使用 ThreadLocal ，其它方式完全可以实现同样的效果，只是 ThreadLocal 使得实现更简洁。</p><h4 id="ThreadLocal怎么用"><a href="#ThreadLocal怎么用" class="headerlink" title="ThreadLocal怎么用"></a><strong>ThreadLocal怎么用</strong></h4><p>既然ThreadLocal的作用是每一个线程创建一个副本，我们使用一个例子来验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//新建一个ThreadLocal</span><br>        ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>        <span class="hljs-comment">//新建一个随机数类</span><br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-comment">//使用java8的Stream新建5个线程</span><br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>).forEach(a-&gt; <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-comment">//为每一个线程设置相应的local值</span><br>            local.set(a+<span class="hljs-string">&quot;  &quot;</span>+random.nextInt(<span class="hljs-number">10</span>));   <br>            System.out.println(<span class="hljs-string">&quot;线程和local值分别是  &quot;</span>+ local.get());<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*线程和local值分别是  0  6</span><br><span class="hljs-comment">  线程和local值分别是  1  4</span><br><span class="hljs-comment">  线程和local值分别是  2  3</span><br><span class="hljs-comment">  线程和local值分别是  4  9</span><br><span class="hljs-comment">  线程和local值分别是  3  5 */</span><br></code></pre></td></tr></table></figure><p>从结果我们可以看到，每一个线程都有各自的local值，我们设置了一个休眠时间，就是为了另外一个线程也能够及时的读取当前的local值。</p><p>这就是TheadLocal的基本使用，是不是非常的简单。那么为什么会在数据库连接的时候使用的比较多呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection connect = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(connect == <span class="hljs-keyword">null</span>)&#123;<br>            connect = DriverManager.getConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> connect;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(connect!=<span class="hljs-keyword">null</span>)<br>            connect.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一个数据库连接的管理类，我们使用数据库的时候首先就是建立数据库连接，然后用完了之后关闭就好了，这样做有一个很严重的问题，如果有1个客户端频繁的使用数据库，那么就需要建立多次链接和关闭，我们的服务器可能会吃不消，怎么办呢？如果有一万个客户端，那么服务器压力更大。</p><p>这时候最好ThreadLocal，因为ThreadLocal在每个线程中对连接会创建一个副本，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。是不是很好用。</p><h4 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="hljs-comment">     * to the specified value.  Most subclasses will have no need to</span><br><span class="hljs-comment">     * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span><br><span class="hljs-comment">     * method to set the values of thread-locals.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span><br><span class="hljs-comment">     *        this thread-local.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        Thread t = Thread.currentThread();<br>        ThreadLocalMap map = getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>            map.set(<span class="hljs-keyword">this</span>, value);<br>        <span class="hljs-keyword">else</span><br>            createMap(t, value);<br>    &#125;<br>    <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment">     * InheritableThreadLocal.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the current thread</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> firstValue value for the initial entry of the map</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>        t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自我理解： ThreadLocal 其实就是一个空壳，线程的局部变量不是存放在 ThreadLocal 中的，而是使用 ThreadLocal 维护的方法对当前线程的 ThreadLocalMap threadLocals 进行操作，之所以使用 Map 的形式存储，是因为同一个线程可能维护多个ThreadLocal 变量。</p><p>内存溢出问题： 如果一个线程不消亡，其threadLocals中的变量就一直会存在，可能会造成内存溢出，所以使用完毕要进行remove操作。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>对于 Java Web 应用而言，Session 保存了很多信息。很多时候需要通过 Session 获取信息，有些时候又需要修改 Session 的信息。一方面，需要保证每个线程有自己单独的 Session 实例。另一方面，由于很多地方都需要操作 Session，存在多方法共享 Session 的需求。如果不使用 ThreadLocal，可以在每个线程内构建一个 Session实例，并将该实例在多个方法间传递，如下所示。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SessionHandler &#123;<br><br>  @Data<br>  <span class="hljs-built_in">public</span> static <span class="hljs-keyword">class</span> <span class="hljs-keyword">Session</span> &#123;<br>    private String id;<br>    private String <span class="hljs-keyword">user</span>;<br>    private String status;<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> <span class="hljs-keyword">Session</span> createSession() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Session</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> String getUser(<span class="hljs-keyword">Session</span> <span class="hljs-keyword">session</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">session</span>.getUser();<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> String getStatus(<span class="hljs-keyword">Session</span> <span class="hljs-keyword">session</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">session</span>.getStatus();<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> setStatus(<span class="hljs-keyword">Session</span> <span class="hljs-keyword">session</span>, String status) &#123;<br>    <span class="hljs-keyword">session</span>.setStatus(status);<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    <span class="hljs-built_in">new</span> Thread(() -&gt; &#123;<br>      SessionHandler <span class="hljs-keyword">handler</span> = <span class="hljs-built_in">new</span> SessionHandler();<br>      <span class="hljs-keyword">Session</span> <span class="hljs-keyword">session</span> = <span class="hljs-keyword">handler</span>.createSession();<br>      <span class="hljs-keyword">handler</span>.getStatus(<span class="hljs-keyword">session</span>);<br>      <span class="hljs-keyword">handler</span>.getUser(<span class="hljs-keyword">session</span>);<br>      <span class="hljs-keyword">handler</span>.setStatus(<span class="hljs-keyword">session</span>, &quot;close&quot;);<br>      <span class="hljs-keyword">handler</span>.getStatus(<span class="hljs-keyword">session</span>);<br>    &#125;).<span class="hljs-keyword">start</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法是可以实现需求的。但是每个需要使用 Session 的地方，都需要显式传递 Session 对象，方法间耦合度较高。</p><p>这里使用 ThreadLocal 重新实现该功能如下所示。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionHandler</span> &#123;</span><br><br>  public <span class="hljs-keyword">static</span> ThreadLocal&lt;Session&gt; session = ThreadLocal.&lt;Session&gt;withInitial<span class="hljs-function"><span class="hljs-params">(() -&gt; <span class="hljs-keyword">new</span> Session())</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  @<span class="hljs-title">Data</span></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">Session</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">id</span>;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">user</span>;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">status</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">session</span>.<span class="hljs-title">get</span><span class="hljs-params">()</span>.<span class="hljs-title">getUser</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">session</span>.<span class="hljs-title">get</span><span class="hljs-params">()</span>.<span class="hljs-title">getStatus</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-built_in">String</span> status)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">session</span>.<span class="hljs-title">get</span><span class="hljs-params">()</span>.<span class="hljs-title">setStatus</span><span class="hljs-params">(status)</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-built_in">String</span>[] args)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">      SessionHandler handler = <span class="hljs-keyword">new</span> SessionHandler();</span></span><br><span class="hljs-params"><span class="hljs-function">      handler.getStatus();</span></span><br><span class="hljs-params"><span class="hljs-function">      handler.getUser();</span></span><br><span class="hljs-params"><span class="hljs-function">      handler.setStatus(<span class="hljs-string">&quot;close&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">      handler.getStatus();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>使用 ThreadLocal 改造后的代码，不再需要在各个方法间传递 Session 对象，并且也非常轻松的保证了每个线程拥有自己独立的实例。</p><p>如果单看其中某一点，替代方法很多。比如可通过在线程内创建局部变量可实现每个线程有自己的实例，使用静态变量可实现变量在方法间的共享。但如果要同时满足变量在线程间的隔离与方法间的共享，ThreadLocal再合适不过。</p><h4 id="弱引用问题"><a href="#弱引用问题" class="headerlink" title="弱引用问题"></a>弱引用问题</h4><p><a href="https://zhuanlan.zhihu.com/p/304240519">https://zhuanlan.zhihu.com/p/304240519</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/12/23/Maven/"/>
    <url>/2021/12/23/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><hr><p>用了这么久maven，理解仅限制在自动导入JAR包上，打算写一篇博客记录下maven更深层次的东西</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/11/25/gulimall/"/>
    <url>/2021/11/25/gulimall/</url>
    
    <content type="html"><![CDATA[<h1 id="gulimall技术与配置"><a href="#gulimall技术与配置" class="headerlink" title="gulimall技术与配置"></a>gulimall技术与配置</h1><blockquote><h2 id="nacos服务发现"><a href="#nacos服务发现" class="headerlink" title="nacos服务发现"></a>nacos服务发现</h2></blockquote><ul><li><p>common 模块导入 nacos 服务发现依赖</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>子模块配置服务名称，ancos 服务器端口地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">application:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">gulimall-ware</span><br><span class="hljs-attr">cloud:</span><br>  <span class="hljs-attr">nacos:</span><br>    <span class="hljs-attr">discovery:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">101.43</span><span class="hljs-number">.56</span><span class="hljs-number">.164</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure></li><li><p>服务添加 @EnableDiscoveryClient注解</p></li></ul><hr><blockquote><h2 id="openfeign远程调用配置"><a href="#openfeign远程调用配置" class="headerlink" title="openfeign远程调用配置"></a>openfeign远程调用配置</h2></blockquote><ul><li><p>springcloud 依赖</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>openfeign 依赖</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写本地调用接口，添加 @FeignClient(“服务名(注册中心)”) 注解，直接将远程接口的mapping与方法名复制过来（声明式远程调用），一定要写请求的全名称</p></li><li><p>调用端开启远程调用功能 @EnableFeignClients(basePackages =  “feign服务全包名”)</p></li></ul><blockquote><h2 id="nacos-服务配置"><a href="#nacos-服务配置" class="headerlink" title="nacos 服务配置"></a>nacos 服务配置</h2></blockquote><ul><li><p>common 导入 nacos 配置依赖</p></li><li><p>bootstrap.propert 设置应用名与配置中心地址</p></li><li><p>给配置中心添加一个Data Id(以应用名.properties命名)，作为配置中心</p></li><li><p>添加动态刷新注解@Value(${})配合@RefreshScope。<strong>优先使用配置中心</strong></p><p>更多细节：</p><ul><li>命名空间：做配置隔离；默认为public，可以为开发，测试，生产环境，在bootstrap.properties中设置namespace Id</li><li>配置集：</li><li>配置集Id：</li><li>配置分组：bootstrap.properties中设置group</li></ul></li></ul><blockquote><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a><strong>网关</strong></h2></blockquote><ul><li><p>route: 路由</p></li><li><p>predicate: 满足指定条件</p></li><li><p>filter: </p><p>配置</p><ul><li>开启服务注册与发现</li></ul></li></ul><blockquote><h2 id="vue模板"><a href="#vue模板" class="headerlink" title="vue模板"></a>vue模板</h2></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>      hello<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  components: &#123;&#125;,<br>  data () &#123;<br>    return &#123;&#125;<br>  &#125;,<br>  computed: &#123;&#125;,<br>  watch: &#123;&#125;,<br>  methods: &#123;&#125;,<br>  created () &#123;&#125;,<br>  mounted () &#123;&#125;,<br>  beforeCreate () &#123;&#125;,<br>  beforeMount () &#123;&#125;,<br>  beforeUpdate () &#123;&#125;,<br>  updated () &#123;&#125;,<br>  beforeDestroy () &#123;&#125;,<br>  destroyed () &#123;&#125;,<br>  activated () &#123;&#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><h2 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h2></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">已拦截跨源请求：同源策略禁止读取位于 http://localhost:88/api/sys/login 的远程资源。（原因：CORS 头缺少 &#x27;Access-Control-Allow-Origin&#x27;）<br></code></pre></td></tr></table></figure><ul><li><p>跨域：由于浏览器的同源策略，使浏览器不能执行其他网站的脚本</p></li><li><p>同源策略：协议名，域名，端口号都要在字符级别一致</p></li></ul><p><img src="https://i.loli.net/2021/11/29/Xh8KuwVobmQEy1k.png" alt="image-20211129125942244"></p><ul><li><p>开发阶段解决方法：浏览器收到预检请求后返回允许跨域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsWebFilter <span class="hljs-title">corsWebFilter</span><span class="hljs-params">()</span></span>&#123;<br>        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();<br>        <span class="hljs-comment">//@Description 创建跨域过滤器，配置允许请求类型，来源等</span><br>        CorsConfiguration corsConfiguration = <span class="hljs-keyword">new</span> CorsConfiguration();<br>        corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        corsConfiguration.setAllowCredentials(<span class="hljs-keyword">true</span>);<br>        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>,corsConfiguration);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsWebFilter(urlBasedCorsConfigurationSource);<br>    &#125;<br></code></pre></td></tr></table></figure><p>此时的OPTIONS请求的请求头携带如下信息</p><p><img src="https://i.loli.net/2021/11/29/E9c2kiO6HMDVKbx.png" alt="image-20211129132204884"></p></li><li><p>上线解决方法：nginx</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机原理面试题</title>
    <link href="/2021/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    <url>/2021/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ol><li>电脑为什么可以运行大于电脑内存的程序</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程面试题</title>
    <link href="/2021/10/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2021/10/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li>volatile的理解</li><li>TreadPool的理解，有几种实现</li><li>为什么更愿意new一个线程而不是使用线程池的方式</li><li>Automic原子类的理解</li><li>异步和非阻塞的区别</li><li>什么时候会发生线程死锁</li><li>如何避免线程死锁</li><li>一个生产者一个消费者，不用加锁如何避免线程死锁</li><li>线程六个状态怎么转换的</li><li>syn的底层怎么实现的</li><li>syn和volatile的区别</li><li>syn和lock怎么回事</li><li>讲一讲lock的实现类有那哪两个？怎么实现的</li><li>双重锁实现线程安全单例模式</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯&amp;剪枝</title>
    <link href="/2021/10/26/%E5%9B%9E%E6%BA%AF+%E5%89%AA%E6%9E%9D/"/>
    <url>/2021/10/26/%E5%9B%9E%E6%BA%AF+%E5%89%AA%E6%9E%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>做题看题解时偶然遇到 weiwei，他解题方法和思路比较适合我，可能也适合大多数人 hhh….下面附上他讲解回溯入门时的回答：</p><p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/</a></p><p>我做了其中的：</p><ul><li>全排列(1&amp;2)</li><li>组合总数(1&amp;2)</li><li>子集(1&amp;2)</li></ul><p>感觉有所收获，并在剪枝的题目代码注释部分感叹道：美哉美哉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-comment">//这句话在去重中起着很大的作用</span><br>            <span class="hljs-comment">//和下面的两句英文注释结合，美哉，美哉</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">continue</span>;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//tell the next layer, nums[i] is being used;</span><br>            dfs(nums, len, path, ans, used);<br>            used[i] = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//tell the rest-loop nums[i] can be used again;</span><br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><p>为了留着以后复习，或者是巩固知识，再或者是暂时性提高此时此刻的多巴胺水平，我有必要为回溯做一个初步的总结</p><h2 id="何时使用回溯"><a href="#何时使用回溯" class="headerlink" title="何时使用回溯"></a>何时使用回溯</h2><h2 id="无重复元素问题"><a href="#无重复元素问题" class="headerlink" title="无重复元素问题"></a>无重复元素问题</h2><h3 id="全排列1"><a href="#全排列1" class="headerlink" title="全排列1"></a>全排列1</h3><p>题目描述</p><p><img src="https://i.loli.net/2021/10/26/Smc196oWhuxrsVA.png" alt="image-20211026152742449"></p><p>由于元素无重复，我们只用考虑当前元素的位置而无需考虑其具体值，我仅以此题为代表画出递归树，其他题目自行脑补即可（好狂野）</p><p><img src="https://i.loli.net/2021/10/26/rXAxaScuL3kqjRN.png" alt="image-20211026155651854"></p><p>我们需要额外定义一个元素是否被使用过的 boolean 数组来告知下一层 dfs 当前值是否可以继续被选用，</p><p>同样的在回溯过程中，这个 boolean 数组必须被还原，因为当for 遍历至下一个子树时，这个元素时可以被继续使用的。</p><p>代码如下（做完就感觉好简单）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];<br>        dfs(nums, len, path, ans, used);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> len, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans, <span class="hljs-keyword">boolean</span>[] used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == len)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">continue</span>;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-keyword">true</span>;<br>            dfs(nums, len, path, ans, used);<br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="有重复元素问题"><a href="#有重复元素问题" class="headerlink" title="有重复元素问题"></a>有重复元素问题</h2><h3 id="全排列2"><a href="#全排列2" class="headerlink" title="全排列2"></a>全排列2</h3><p><img src="https://i.loli.net/2021/10/26/OYVCNKU4F3MpHzf.png" alt="image-20211026155605823"></p><p>由于含有重复元素，就没办法再用上面简单的递归回溯来解决，但是我们也很容易发现使用上面的方法时不考虑元素位置的，重复元素回被创建一个一摸一样的子树，把这个子树（树枝）去掉就是剪枝过程，为了保证结果的唯一和方便找到重复元素，我们必须对数组进行排序。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList();<br>        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len];<br>        Arrays.sort(nums);<br>        dfs(nums, len, path, ans, used);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> len, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans, <span class="hljs-keyword">boolean</span>[] used)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.size() == len)&#123;<br>            ans.add(<span class="hljs-keyword">new</span> ArrayList(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-comment">//这句话在去重中起着很大的作用</span><br>            <span class="hljs-comment">//和下面的两句英文注释结合，美哉，美哉</span><br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">continue</span>;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//tell the next layer, nums[i] is being used;</span><br>            dfs(nums, len, path, ans, used);<br>            used[i] = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//tell the rest-loop nums[i] can be used again;</span><br>            path.remove(path.size() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>其实一切都很好理解，除了 !used[i - 1] </p><p>如果把 &amp;&amp;!used[i - 1] 去掉的话，会导致结果为空，以为误判而 continue 了，剪枝剪掉 nums[i] == nums[i - 1] 的枝只能是<strong>被 dfs 完被重新置为false</strong>的元素。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM虚拟机</title>
    <link href="/2021/10/25/JVM/"/>
    <url>/2021/10/25/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM杂志"><a href="#JVM杂志" class="headerlink" title="JVM杂志"></a>JVM杂志</h1><p>首先要明确的是，一个进程对应着一个 JVM 实例，也就是说线程共享的堆和方法区是对于一个 java 进程而言的，每一个 java 进程有一个独立的 JVM 虚拟机。</p><h2 id="变量分类（于我很难）"><a href="#变量分类（于我很难）" class="headerlink" title="变量分类（于我很难）"></a>变量分类（于我很难）</h2><ol><li><p>按数据类型分：可以分为基本数据类型 vs 引用数据类型（对象，数组，接口……（不用多说）</p></li><li><p>按在类中声明的位置分：可以分为局部变量（声明在方法中，使用前必须进行显示的赋值，否则编译不通过） vs </p><p>​                                                        成员变量（使用前会经历默认初始化赋值）：</p><p>​                                                                    静态变量（用static修饰，也叫类变量）：在类加载阶段进行初始化赋值</p><p>​                                                                    实例变量（无static修饰）：对象的创建过程中，会在堆空间为实例变量分配空间，并进行默认赋值</p></li></ol><h2 id="内加载："><a href="#内加载：" class="headerlink" title="内加载："></a>内加载：</h2><p><img src="https://i.loli.net/2021/10/26/ewYC6smRQZpxN2G.png" alt="image-20211026162431249"></p><p>描述类加载过程：<init><clinit></p><p>类加载与static</p><p>如何判断两个class文件是否为同一个类：</p><ul><li>全类名一致（包括包名）</li><li>加载class文件的 ClassLoader 必须一致（类加载的<strong>双亲委派机制</strong>）</li></ul><p>蜜汁方法区：（由此可见方法区有一个功能是用来存放类型信息的，在保证即使存在多个线程，共用类也只在堆空间中被加载一次）</p><ul><li>JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的，如果是由用户类加载器加载的话，JVM则将这个类加载器的一个引用作为类型信息的一部分存放在方法区。</li></ul><h2 id="内存结构："><a href="#内存结构：" class="headerlink" title="内存结构："></a>内存结构：</h2><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><ul><li><p>程序计数器只用来存储当前线程下一条指令的“行号”（指令地址），占用极小的内存空间（几乎可以忽略不计），因此他也是JVM中唯一一个没有内存溢出的内存区域，如果当前执行的是本地方法则标记为 undefined。</p></li><li><p>程序计数器的定位和与其他结构的交互</p></li></ul><p><img src="https://i.loli.net/2021/10/24/71gefiVvsLYnxrq.png" alt="image-20211024200420957"></p><ul><li>PC的作用：控制程序的正常运行；上下文切换时保留和恢复现场（所以它必须是线程私有的）</li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="线程私有（这是一句废话）"><a href="#线程私有（这是一句废话）" class="headerlink" title="线程私有（这是一句废话）"></a>线程私有（这是一句废话）</h4><h4 id="作用（得明确）"><a href="#作用（得明确）" class="headerlink" title="作用（得明确）"></a>作用（得明确）</h4><p>保存方法区的局部变量(8中基本数据类型和对象的引用地址)，部分结果，参与方法的调用与返回（栈帧间），方法结束则将栈帧销毁，因此虚拟机栈不需要进行垃圾回收。</p><p>可能出现的异常（需要区分发生的原因）：</p><ul><li>StackOverflowError：方法过多或者递归过深导致。</li><li>OutOfMemoryError：栈未满而报OOM的原因除了内存空间真的就很小之外，主要的原因在于程序可能创建了过多的线程。</li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><p>调优：-Xss 设置虚拟机线程栈的大小（针对StackOverflowError）</p><h4 id="内部结构（栈帧）"><a href="#内部结构（栈帧）" class="headerlink" title="内部结构（栈帧）"></a>内部结构（栈帧）</h4><p>​    总体结构就是一个一个的栈帧，没执行一次方法对应一个栈帧（包括递归的），栈帧之间的切换（栈帧结束）依据是return（无返回值的字节码就是return）或者未捕获异常以抛出异常的方式结束</p><p><img src="https://i.loli.net/2021/10/24/SJEhxjFWby39dBI.png" alt="image-20211024210935486"></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ol><li><p>定义为一个数字数组，用于存储方法参数以及局部变量，包括基本数据类型，对象引用，以及<strong>returnAddress类型</strong>，数组的每个字段单元为一个Slot，除了long和double，都占用一个Slot（这是针对64位机而言的，32位机都是一个Slot）</p></li><li><p>不存在线程安全问题（废话）</p></li><li><p>容量大小在编译器就确定并固定，保存在方法的Code属性的maximum local variables数据项中</p><p>眼见为实，看一下局部变量表的真面目，startPC和Length分别为作用域开始字节码指令的位置和作用域长度</p><p><img src="https://i.loli.net/2021/10/25/WJxU6CQIOKywXu7.png" alt="image-20211025100721866"></p><p>非静态方法（实例方法）和构造方法中，都会有一个this的引用在变量槽的起始位置，这也是在静态方法中没法使用this的底层原因，直观上看的话，就是静态方法是直接被类调用的，this不到当前的实例</p><p><img src="https://i.loli.net/2021/10/25/ykN4GvzKScinLPe.png"></p><p>double数据在局部变量表中占两个slot</p><p><img src="https://i.loli.net/2021/10/25/63siDYatABR2CVq.png" alt="image-20211025104448577"></p><p>局部变量表的确定是需要计算的，例如当某局部变量出了作用域，他所只能用的slot可以被重复利用，节省了一部分空间</p><p><img src="https://i.loli.net/2021/10/25/9RNFvBro1tmeZTx.png" alt="image-20211025104933201"></p><p><img src="https://i.loli.net/2021/10/25/aCDUR5hlOEsKcdo.png" alt="image-20211025110912220"></p></li></ol><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>在方法的执行过程中，进行复制，值交换求和等操作需要对操作数栈进行读数据写数据操作，即入栈出栈。</p><p>java的解释引擎是基于栈的执行引擎，这个栈就是指栈帧中的操作数栈</p><p>和局部变量表一样，在编译之后其大小就已经确定（我感觉这个确定不容易），但其大小和局部变量表的大小没有直接关系</p><p><img src="https://i.loli.net/2021/10/25/ZbF8HJ1OjlTqkB7.png" alt="image-20211025113240607"></p><p>很容易发现，使用操作数栈的执行方式的字节码会更加臃肿，存在大量的入栈出栈操作，与使用寄存器的方式相比会降低执行的效率，栈顶缓存技术将栈顶频繁使用的元素全部缓存到CPU的寄存器中，避免了频繁的对内存进行读写，提高执行引擎的效率。</p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>（指向运行时常量池的方法引用）（像一个对照表从符号引用到真实引用）</p><p>常量池中的符号引用</p><p><img src="https://i.loli.net/2021/10/25/awWiOmVvGEunbP5.png" alt="image-20211025153036821"></p><p><img src="https://i.loli.net/2021/10/25/9SYIQPdfUA4c2FW.png" alt="image-20211025152831213"></p><p>方法调用</p><ul><li><p>绑定的概念：一个属性，方法或者类在从符号引用转换成直接引用的过程，该过程只发生一次。</p><p>如果被调用的目标在编译器就能确定如何绑定，可以使用静态链接的方法进行早期绑定</p><p>否则就在运行时使用动态链接的方式进行动态绑定，动态链接主要指的是多态的方式（invokeinterface，invokevirtural）</p></li></ul><p><img src="https://i.loli.net/2021/10/25/FJBDs2LloZY4Nya.png" alt="image-20211025190949168"></p><p>编译期间没法确定的方法是虚方法</p><p>​        隐式调用父类的final方法，也是invokevirtual，但是非虚方法</p><p><img src="https://i.loli.net/2021/10/25/peO5i98SqNjZ37a.png" alt="image-20211025191551422"></p><h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><p><img src="https://i.loli.net/2021/10/26/a3SCkBA1HzREuln.png" alt="image-20211026114404258"></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆区在JVM启动的时候即被创建，其空间大小也被确定了，是JVM管理的最大一块空间。</p><p>java栈，堆空间和方法区的直观表现</p><p><img src="https://i.loli.net/2021/10/26/Izl4V1g9eLAumOF.png" alt="image-20211026165208565"></p><p><img src="https://i.loli.net/2021/10/27/I8PUoY2HBqzdZev.png" alt="image-20211027104842363"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/10/18/dp/"/>
    <url>/2021/10/18/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>动态规划，简称 dp，它的思想是通过状态方程把现有的问题转化成子问题，子问题再用同样的方法转化成子子问题，可能听起来像是递归，但是递归解决起来和带有递归性质的树，链表这一类的题目不同，它会做到很多重复的运算，无疑会导致算法效率低下，所以动态规划的一个重要的思想就是用空间换时间。我们把状态转移方程右边需要的状态提前计算出来，另外开辟空间来存储查询，就避免了重复计算的问题；</p><h2 id="适用题型"><a href="#适用题型" class="headerlink" title="适用题型"></a>适用题型</h2><p>dp适用于求解如最多，最少，最大，多少种，能不能……之类的问题，一般是可以对子问题的状态进行存储的。</p><h2 id="一般步骤（不是流程-）"><a href="#一般步骤（不是流程-）" class="headerlink" title="一般步骤（不是流程 ）"></a>一般步骤（不是流程 ）</h2><ul><li>确定状态：需要开辟额外的空间（数组）来存储子问题的状态，因此首先要确定每个数组元素的意义（最有子问题）。</li><li>确定状态转移方程</li><li>初始条件，边界情况（问题规模）</li><li>确定计算顺序</li></ul><h2 id="剑指offer2-103-最少的硬币数"><a href="#剑指offer2-103-最少的硬币数" class="headerlink" title="剑指offer2 103 最少的硬币数"></a>剑指offer2 103 最少的硬币数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>       <span class="hljs-comment">//amount is the  value of all selected coins</span><br>        <span class="hljs-comment">//define a zone for storing the status</span><br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br><br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//record every status </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++)&#123;<br>            f[i] = Integer.MAX_VALUE;<br>            <span class="hljs-comment">//f[x] = min&#123;f[x - coins[1]], f[x - coins[2] .....] &#125; + 1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>; j &lt; coins.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i - coins[j] &gt;= <span class="hljs-number">0</span> &amp;&amp;  f[i - coins[j] ] != Integer.MAX_VALUE)&#123;<br>                    f[i] = Math.min(f[i], f[i - coins[j]] + <span class="hljs-number">1</span> ) ;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[amount] == Integer.MAX_VALUE? -<span class="hljs-number">1</span> : f[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-62-不同路径"><a href="#LeetCode-62-不同路径" class="headerlink" title="LeetCode 62 不同路径"></a>LeetCode 62 不同路径</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//initialize a space to store the status of every subproblem</span><br>        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-comment">//initialize the status</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j== <span class="hljs-number">0</span>)&#123;<br>                    f[i][j] = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span><br>                    f[i][j] = f[i-<span class="hljs-number">1</span>][j] + f[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>        <br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\lunfee\Desktop\snipaste_20211019_200701.jpg" alt="snipaste_20211019_200701"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2021/10/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/10/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>java线程与操作系统的本地线程一一对应，Java线程开启本地线程就会创建，Java线程结束，本地线程就被回收</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>计算机操作系统的可执行文件是由一行行代码或指令组成，这些静态的指令与数据文件在计算机中叫一个程序。</p><p>想要运行一个<strong>程序</strong>就必须要把这些指令集加载到机器的CPU中，同时将数据加载到内存，运行起来的程序叫做<strong>进程</strong>，进程是用来加载指令，管理IO，管理内存的。同一个程序如果允许多次执行，就形成了多个进程。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可以包括多个线程（Windows进程就是一个线程容器）</p><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行</p><h3 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h3><p>在Java中，线程是最小的<strong>调度</strong>单位，进程是资源分配的最小单位。</p><p>进程是相互独立的，而线程存在于进程内，是进程的一个子集</p><p>进程内存在共享资源，供内部线程共享使用</p><p>多线程：一个进程内同时并行执行多个线程，每个线程各自有一套虚拟机栈和程序计数器。</p><p>多线程的优势：</p><ol><li><p>用户使用图形化界面完成不同任务的必须。</p></li><li><p>可以提高CPU利用率（尽管对于单核会降低速度）</p></li><li><p>复杂的进程分为多线程，单独启动易于管理，优化结构。</p></li></ol><p>何时使用多线程：</p><ol><li><p>程序需要同时执行两个或多个任务</p></li><li><p>程序需要实现一些需要等待的任务，比如网络加载，输入，读写文件等 </p></li></ol><p>后台执行任务。</p><p>进程间的通信：同一台计算机之间进程的通讯成为IPC(Inter-Process Communication)</p><p>​                         不同计算机之间的进程通讯，需要走网络并遵守协议</p><p>线程间的通讯：线程共享方法区和堆，可以实现进程间高效通信。</p><p>上下文切换：</p><ol><li>线程间的上下文切换主要是对指令的临时存储，开销较小</li><li>进程间的上下文切换涉及到资源的临时存储，开销较大</li></ol><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>并发(Concurent)的概念是建立在单个处理器上，在逻辑（时间）上好像多个线程在同步运行，实际上是在不同线程间不停切换。处理器核心为不同线程分发时间片，CPU在不同的线程见轮询（Windows下最短时间片为15ms)</p><p>并行是物理意义上的同步运行，基于多个处理器（核心），单核处理器无法实现并行。</p><p>计算机的任务处理是并行域并发同时发生的，因为大多数情况下，计算机需要处理的线程数要大于计算机的总处理器核数。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>任务执行的同步与异步：</p><ol><li>需要等待结果返回才能继续运行就是同步</li><li>不要等待结果返回就能继续运行就是同步</li></ol><p>Java多线程的同步：让多个线程步调一致</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>在单核CPU下，多线程并不能提高实际的效率，只是为了在不同的任务之间转换，不同线程轮流使用CPU，避免单线程工作，其他线程等待。</li><li>对于多核CPU而言，处理任务是否可以拆分，是否需要拆分都需要根据实际情况确定。</li><li>IO操作是不占用CPU的，但是如果使用<strong>阻塞IO</strong>，相当于线程虽然不用CPU，但是需要一直等待IO操作结束，没有充分的利用线程，所以才有后面的<strong>非阻塞IO</strong>和<strong>异步IO</strong>（NIO）.</li></ol><h2 id="JAVA线程基础"><a href="#JAVA线程基础" class="headerlink" title="JAVA线程基础"></a>JAVA线程基础</h2><h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><h4 id="方法1：使用Thread（继承Threada类，重写run-方法）"><a href="#方法1：使用Thread（继承Threada类，重写run-方法）" class="headerlink" title="方法1：使用Thread（继承Threada类，重写run()方法）"></a>方法1：使用Thread（继承Threada类，重写run()方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建线程对象</span><br><span class="hljs-comment">//使用匿名内部类的方式创建Thread，因为只用一次，直接在new的时候覆盖run()方法。</span><br>Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        log.debug(<span class="hljs-string">&quot;thread1 run&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//交给任务调度器调度分配时间片，由CPU执行。</span><br>t1.start();<br></code></pre></td></tr></table></figure><h4 id="方法2；使用Runnable配合Thread"><a href="#方法2；使用Runnable配合Thread" class="headerlink" title="方法2；使用Runnable配合Thread"></a>方法2；使用Runnable配合Thread</h4><ol><li>把线程和任务分离</li><li>Tread表示线程，Runnable表示可运行的任务，线程要执行的代码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable task = <span class="hljs-keyword">new</span> Runnable()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        log.debug(<span class="hljs-string">&quot;task run&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//也可以交给线程池处理</span><br>Thread t2 = Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><h5 id="新知识"><a href="#新知识" class="headerlink" title="新知识"></a>新知识</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Runnable接口源码</span><br><span class="hljs-meta">@FunctionlInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>@FunctionalInterface注解使用在仅有一个抽象方法的接口上，在Java8 以上的版本中可以使用lambda表达式简写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable task = () -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;task run&quot;</span>);<br>&#125;<br><span class="hljs-comment">//也可以交给线程池处理</span><br>Thread t2 = Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><h4 id="方法3：FutureTssk配合Thread（）"><a href="#方法3：FutureTssk配合Thread（）" class="headerlink" title="方法3：FutureTssk配合Thread（）"></a>方法3：FutureTssk配合Thread（）</h4><p>从Runnable接口源码可以看出，Runnable接口的run()方法没有返回值，无法进行线程间数据的传输共享。</p><p><img src="https://i.loli.net/2021/10/17/5kzyDTlpFstjhu6.png" alt="image-20211017171615846"></p><p>FutureTask类可以返回线程的执行结果，它的继承关系如图：</p><p><img src="https://i.loli.net/2021/10/17/ZH2raKA4k6JvITS.png" alt="image-20211017172252995"></p><p>继承的Future接口中有get()方法，能实现返回，除此之外，FutureTask需要搭配Callable接口（有返回值）：</p><p><img src="https://i.loli.net/2021/10/17/kqhrBep91x4o85i.png" alt="image-20211017172157201"></p><p>一个代码示例（之前在尚硅谷记的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableThtread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//3.create the instance of call class</span><br>        NumberThresd numberThresd = <span class="hljs-keyword">new</span> NumberThresd();<br>        <span class="hljs-comment">//4.use the futuretask tool</span><br>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(numberThresd);<br>        <span class="hljs-comment">//5.create new thread</span><br>        <span class="hljs-keyword">new</span> Thread(futureTask).start();<br>        <span class="hljs-comment">//6.call get method if you need the return value of call</span><br>        Object o = futureTask.get();<br>        System.out.println(o);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//1.create a class implements Callable interface and Override call method</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThresd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//2.return Object, Integer is the subclass of Object, int sum is turned into Integer automatically</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                sum += i;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于为什么使用Future命名，从官方对Future的解释可以看出，get()方法可能需要阻塞等待执行结果(未来的结果)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready.<br></code></pre></td></tr></table></figure><h3 id="线程和进程的查看"><a href="#线程和进程的查看" class="headerlink" title="线程和进程的查看"></a>线程和进程的查看</h3><p>在Windows下提供了查看所有进程与线程的cmd命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tasklist   //显示所有任务<br>taskkill   //通过pid杀死某个进程<br>tasklist | findstr java    //通过管道方法搜索带有java字段的任务<br></code></pre></td></tr></table></figure><p>Linus下对线程的查看操作更为丰富</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -fe | grep java    //管道筛选所有Java字段的进程<br>kill pid              //杀死进程<br>top//动态采集进程运行情况，包括CPU占用和MER占用<br>top -H -p pid //显示进程中所有线程的信息(-H 表示查看线程)<br></code></pre></td></tr></table></figure><p>JDK也提供了一套可以用来专门查看Java线程的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jps       //查看所有java进程<br></code></pre></td></tr></table></figure><h3 id="线程的运行底层原理"><a href="#线程的运行底层原理" class="headerlink" title="线程的运行底层原理"></a>线程的运行底层原理</h3><p>Java Virtual Machine Stacks(Java 虚拟机栈)</p><p><img src="https://i.loli.net/2021/10/17/OjnMUfIxRTkZlLc.png" alt="image-20211017200109319"></p><p>JVM是由堆，栈，方法区组成，其中栈时线程私有的，每个线程启动，虚拟机都会为其分配一块栈内存，</p><p>每个栈由多个栈帧(Frame)组成，对应这每次方法调用时所占用的内存。</p><p>每个线程只有一个活动的栈帧，对应着当前正在执行的那个方法。</p><p>单个线程的运行时栈内存和栈帧内存的使用情况：</p><p><img src="https://i.loli.net/2021/10/17/5HFDiwARtGZXpNB.png" alt="image-20211017194407325"></p><p>多个线程的情况下，各个线程之间有各自的占内存，栈帧是相互独立的.</p><p><img src="https://i.loli.net/2021/10/22/TRUks3jOmY12VKv.png" alt="image-20211022110139621"></p><p><a href="https://stackoverflow.com/questions/14763079/what-are-the-xms-and-xmx-parameters-when-starting-jvm">https://stackoverflow.com/questions/14763079/what-are-the-xms-and-xmx-parameters-when-starting-jvm</a></p><p>The flag <code>Xmx</code> specifies the maximum memory allocation pool for a Java Virtual Machine (JVM), while <code>Xms</code> specifies the initial memory allocation pool.</p><p>This means that your JVM will be started with <code>Xms</code> amount of memory and will be able to use a maximum of <code>Xmx</code> amount of memory. For example, starting a JVM like below will start it with 256 MB of memory and will allow the process to use up to 2048 MB of memory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xms256m -Xmx2048m<br></code></pre></td></tr></table></figure><p>The memory flag can also be specified in different sizes, such as kilobytes, megabytes, and so on.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xmx1024k<br>-Xmx512m<br>-Xmx8g<br></code></pre></td></tr></table></figure><p>The <code>Xms</code> flag has no default value, and <code>Xmx</code> typically has a default value of 256 MB. A common use for these flags is when you encounter a <code>java.lang.OutOfMemoryError</code>.</p><p>When using these settings, keep in mind that these settings are for the JVM’s <em>heap</em>, and that the JVM can and will use more memory than just the size allocated to the heap. From <a href="http://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html">Oracle’s documentation</a>:</p><blockquote><p>Note that the JVM uses more memory than just the heap. For example Java methods, thread stacks and native handles are allocated in memory separate from the heap, as well as JVM internal data structures.</p></blockquote><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><p>上下文切换的具体情况：</p><p><img src="https://i.loli.net/2021/10/17/hYEj1pHd9OZxJyA.png" alt="image-20211017201009754"></p><h3 id="线程常用方法讲解"><a href="#线程常用方法讲解" class="headerlink" title="线程常用方法讲解"></a>线程常用方法讲解</h3><h4 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h4><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h4 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h4><p><strong>sleep</strong> (使线程阻塞)</p><ol><li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span><br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//休眠一分钟</span><br>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><p>yield （让出当前线程）</p><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能(机会)被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-regexp">//</span>设置为优先级最高<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h4><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用t1.join()，则是主线程等待t1线程结束</p><p>join() 方法可用于<strong>线程的同步</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>();<br><span class="hljs-comment">//等待thread线程执行结束</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>();<br><span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h4 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h4><p>当<strong>阻塞</strong>(sleep wait join…)的线程被打断，实际是阻塞状态被终止。</p><p>所以sleep()方法需要添加异常处理，被打断后会抛出异常并且立刻执行进入运行状态。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。</li><li>如果是打断因sleep wait join方法而被阻塞的线程，只是打断了当前的阻塞状态，会继续执行之后的代码，打断标记置为false</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>用于查看打断标记，返回值被boolean类型<br>t1.isInterrupted();<br></code></pre></td></tr></table></figure><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>) &#123;<br>        break;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="https://i.loli.net/2021/10/21/i3pkemhWc6UvSBr.png" alt="img"></a></p><p><strong>代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Monitor</span>();<br>monitor.<span class="hljs-built_in">start</span>();<br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">3500</span>);<br>monitor.<span class="hljs-built_in">stop</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;</span><br><br>Thread monitor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>() &#123;<br>@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">//判断当前线程是否被打断了</span><br><span class="hljs-keyword">if</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">isInterrupted</span>()) &#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-comment">//终止线程执行</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>e.<span class="hljs-built_in">printStackTrace</span>();<br><span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">interrupt</span>();<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.<span class="hljs-built_in">interrupt</span>();<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h4><ul><li>stop方法 停止线程运行（可能造成共享资源锁无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）/resume（恢复线程）方法</li></ul><h4 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h4><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><p>所以守护线程就像一个其他线程的守护者，别人不结束我就一直干，别人结束了我就立刻放弃自己的所有任务（感人了）</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//将线程设置为守护线程, 默认为<span class="hljs-literal">false</span><br><span class="hljs-literal">monitor</span>.setDaemon(<span class="hljs-literal">true</span>);Copy<br></code></pre></td></tr></table></figure><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><h4 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h4><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="https://i.loli.net/2021/10/21/UhMp4cRNVS9GPmK.png" alt="img"></a></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】 <ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h4 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h4><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><img src="https://i.loli.net/2021/10/22/yuk689JfSLjoZHQ.png" alt="image-20211022223937573"></p><ul><li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>共享带来的问题</p><p>(1)临界区 Critical Section</p><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123;   <br>    counter++; <br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><br><span class="hljs-function"></span>&#123; <br>    counter--; <br>&#125;Copy<br></code></pre></td></tr></table></figure><p><strong>(2)竞态条件 Race Condition</strong></p><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><h3 id="对象锁synchronized"><a href="#对象锁synchronized" class="headerlink" title="对象锁synchronized"></a>对象锁synchronized</h3><p><strong>synchronized</strong>，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证临界区内的代码的原子性，不用担心线程上下文切换，即使所持有者因为CPU上线文切换被BLOCKED，其他线程也无法拿到锁。</p><h4 id="synchronized语法"><a href="#synchronized语法" class="headerlink" title="synchronized语法"></a>synchronized语法</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(对象)</span></span> &#123;<br><span class="hljs-comment">//临界区内的所有代码作为原子性操作的一个整体</span><br>&#125;Copy<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>; <br><span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span> room = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>();<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) <span class="hljs-keyword">throws</span> InterruptedException &#123;    <br>Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;        <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;            <br>        <span class="hljs-keyword">synchronized</span> (room) &#123;     <br>        counter++;            <br>        &#125;       <br>    &#125;    <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br> <br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;       <br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;         <br>            <span class="hljs-keyword">synchronized</span> (room) &#123;            <br>            counter--;          <br>            &#125;    <br>        &#125; <br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br> <br>    t1.start();    <br>    t2.start(); <br>    t1.<span class="hljs-built_in">join</span>();   <br>    t2.<span class="hljs-built_in">join</span>();    <br>    <span class="hljs-built_in">log</span>.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,counter); <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="synchronized加在方法上"><a href="#synchronized加在方法上" class="headerlink" title="synchronized加在方法上"></a>synchronized加在方法上</h4><ul><li><p>加在成员方法上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-comment">//在方法上加上synchronized关键字</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-function"><span class="hljs-title">synchronized</span>(<span class="hljs-params"><span class="hljs-built_in">this</span></span>)</span> &#123;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>加在静态方法上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-comment">//在静态方法上加上synchronized关键字</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>&#125;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-function"><span class="hljs-title">synchronized</span>(<span class="hljs-params">Demo.<span class="hljs-keyword">class</span></span>)</span> &#123;<br><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://i.loli.net/2021/10/26/QqCSJovO6lYH9M1.png" alt="image-20211026205407518"></p><p>对于未加锁的线程，由于在对临界区代码进行操作时不会尝试获取对象锁，也不会有被阻塞的可能，就无法保证线程共享数据的安全</p><h4 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h4><p>刚好学完JVM这一块的知识，其实变量是否安全主要看变量被放在什么内存的什么区域，是否线程共享</p><p>实例变量和静态变量（都是成员变量）是否线程安全？</p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全（多线程时，不同线程的方法可能会发生线程不安全的情况）</li></ul></li></ul><p>局部变量是否线程安全？</p><ul><li><p>局部变量是线程安全的（创建的对象保存在栈帧中）</p></li><li><p>但局部变量引用的对象则未必 （要看该对象是否被共享且被执行了读写操作）</p><ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li><li><p>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png"><img src="https://i.loli.net/2021/10/26/4XcRW9YM2HnqhNd.png" alt="img"></a></p><ul><li>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png"><img src="https://i.loli.net/2021/10/26/kw2Ba9CFgPN7e5I.png" alt="img"></a></p><ul><li>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png"><img src="https://i.loli.net/2021/10/26/veagyW1wuk96cBR.png" alt="img"></a></p><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuﬀer</li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p><ul><li>它们的每个方法是原子的（都被加上了synchronized）</li><li>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png"><img src="https://i.loli.net/2021/11/01/JLylFwE6x9CcdAO.png" alt="img"></a></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h3 id="Monitor（锁）"><a href="#Monitor（锁）" class="headerlink" title="Monitor（锁）"></a>Monitor（锁）</h3><p>monitor是操作系统的</p><h4 id="原理之Monitor"><a href="#原理之Monitor" class="headerlink" title="原理之Monitor"></a>原理之Monitor</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png"><img src="https://i.loli.net/2021/11/01/pjUTdcbWhK3BMX5.png" alt="img"></a></p><ul><li>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。<ul><li>如果<strong>没有绑定</strong>，则会先去与Monitor绑定，并且将Owner设为当前线程。</li><li>如果已经绑定，则会去查询该Monitor是否已经有了Owner<ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></li><li><strong>注意</strong>：<ul><li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li><li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li></ul></li></ul><h3 id="Synchronized原理进阶"><a href="#Synchronized原理进阶" class="headerlink" title="Synchronized原理进阶"></a>Synchronized原理进阶</h3><h4 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png"><img src="https://i.loli.net/2021/11/01/ehVdGRADZjH9z5q.png" alt="img"></a></p><h4 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h4><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><ul><li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png"><img src="https://i.loli.net/2021/11/01/IMhomG3LBekjc5S.png" alt="img"></a></p></li><li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png"><img src="https://i.loli.net/2021/11/01/qPMEjQ2avJTupF1.png" alt="img"></a></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png"><img src="https://i.loli.net/2021/11/01/UK9b4H3DPiFORJ1.png" alt="img"></a></p><h4 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h4><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png"><img src="https://i.loli.net/2021/11/01/IunVNWvgOSQ84GK.png" alt="img"></a></p><ul><li><p>此时便会给对象加上重量级锁（使用Monitor）</p><ul><li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</p></li><li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png"><img src="https://i.loli.net/2021/11/01/oUxETYavhMntzjb.png" alt="img"></a></p></li></ul></li></ul><h4 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h4><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态（减少了上下文切换的次数）。</p><ul><li>第一种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png"><img src="https://i.loli.net/2021/11/01/4UGmjap1d6WTRNi.png" alt="img"></a></p><ul><li>第二种情况</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png"><img src="https://i.loli.net/2021/11/01/hcVI5FkHY1KeAzf.png" alt="img"></a></p><h4 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h4><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png"><img src="https://i.loli.net/2021/11/01/u2YUwZ8SWhyjoQP.png" alt="img"></a></p><h5 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h5><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png"><img src="https://i.loli.net/2021/11/01/g5ia1H9O8EdolAR.png" alt="img"></a></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li></ul><h5 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h5><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h4 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h4><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h4 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h4><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20211006</title>
    <link href="/2021/10/06/20211006/"/>
    <url>/2021/10/06/20211006/</url>
    
    <content type="html"><![CDATA[<p>我也不知道 Typora 发生了什么事情，本来是想来记个日记的，发现了一个 bug，就是写完 yaml 之后正文第一个字符必须是英文，不管那么多了，正文开始吧….</p><p>今天是国庆假期的倒数第二天了，虽然学校只放三天的假期，但是我四号赶来学校的时候实验室其实没什么人过来，说来是有点自私的，我也知道可以晚点来学校，多陪陪家人，奈何我的心里面想的工作学习的事情也怕被耽搁，其实差不多了，这几天过的还算充实。只是突然回来学校有点找不到原来的方向了，尽管在离校前，对我的当时任务做了个入栈操作，如图所示：</p><p><img src="https://i.loli.net/2021/10/06/owERgTnqdJcF7LB.png" alt="image-20211006171648690"></p><p>除了这些，我其实还需要搞机器人，以应付胡**的突然“关心”，说实话从读研到现在我的学术进展几乎为零，也没有头绪，没有心思确定未来我要做什么发小论文和毕业，到底是不是机器人啊，一年后我就有答案了啊哈哈，因为那个时候就是迫在眉睫了。现在我就安心的想我的工作吧，科研这条路不是每个人都适合，更不是每个人都有机遇。可能我遇到一个好的导师，我就……就可以读博了，别，感觉在这个学校或者说国内这个环境下（国外不知道），真的没那么多人喜欢科研，不过是混个学历罢了。我就勉为其难掩盖我的科研素养，好好利用这最后的学历光环搞钱吧。</p><p>可能对于我个人而言，生活的开心快乐真的比什么都重要，但是我也知道，快乐可以是纯粹的，也可以是物质的，我也知道，纯粹的快乐是最持久的，但是我仍然义无反顾的追求物质的快乐，直白点就是金钱。可能超脱物质的那种人真的存在，但那必不是我。从小长大的环境告诉我，没有金钱就没有自信，尽管这个事实被我的学历冲淡了那么一点点，但其实只是把金钱的价值转移到了具有强大购买了的高学历上了，我不否认这一点，因为这太正常不过了。</p><p>有钱可以让我对得起自己的亲情（良心），比如不会表达的我可以靠买一些生活用品啊，小礼物啊来慰藉自己的父母，奶奶，以及几个宝贝；比如可以毫不吝啬的买高铁票飞机票回家，而不用抉择这路途如此艰难究竟要不要回家；比如父母的体检费啊，以后难免可能有高昂的医药费啊，我想毫不犹豫的说，治，都少钱都给我治，但拿需要底气——来自于金钱。</p><p>我一点也不心虚的觉得我很爱我的家人，尤其心疼我的父母，有物质层面的有精神层面的甚至是知识层面上。物质上，他们挣钱真的太不容易了，尽管最近几年在花销上大了不少，但依旧是省吃俭用，工作也是普通劳动人民，尽管我也是如此，省吃俭用，未来的新型劳动人民，但这种心疼是油然而生的，这种心疼源自生为他们一点一点用心养大的儿子的我的生活质量要比他们高出很多上，源自工作的体面程度上，源自社会地位上，不过也还好有我，尽管算是在这残酷的世界上苟且偷生吧，让他们有一点骄傲和慰藉，这一点真的有在精神层面弥补到他们，我确定。关于精神层面的心疼和知识层面的下次再写吧。</p><p><img src="https://raw.githubusercontent.com/lunfee/picgo/main/img/image-20220111133806363.png?token=AJECWBIM6M62XS7OGQSFC53B3UL7U" alt="image-20220111133806363"></p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Object类</title>
    <link href="/2021/09/27/Object%E7%B1%BB/"/>
    <url>/2021/09/27/Object%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2021/09/26/Netty%E7%9F%A5%E6%A0%B9%E7%9F%A5%E5%BA%95/"/>
    <url>/2021/09/26/Netty%E7%9F%A5%E6%A0%B9%E7%9F%A5%E5%BA%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty知根知底"><a href="#Netty知根知底" class="headerlink" title="Netty知根知底"></a>Netty知根知底</h1><h2 id="学前问题"><a href="#学前问题" class="headerlink" title="学前问题"></a>学前问题</h2><p>netty线程模型</p><p>NIO为什么这么快，是否高效，和IO的区别</p><p>NIO和BIO和IO</p><p>NIO原理</p><p>NIO究竟怎么实现非阻塞的</p><p>java里面哪些用到了NIO</p><p>TCP粘包拆包</p><p>Netty是网络编程基本框架，Java开发流行的Redis缓存的主从复制，分布式的RPC的底层通讯都使用Netty网络通讯。</p><h2 id="NIO是个什么玩意"><a href="#NIO是个什么玩意" class="headerlink" title="NIO是个什么玩意"></a>NIO是个什么玩意</h2><p>NIO(non-blocking-io，非阻塞io)</p><p><img src="https://i.loli.net/2021/09/27/Ld7zph2ajmvIwMF.png" alt="image-20210925163226750"></p><img src="https://i.loli.net/2021/09/27/7YfjtHqBmRCKgVo.png" alt="image-20210925163239860" style="zoom:200%;" /><p><img src="https://i.loli.net/2021/09/27/mwPBF2r46MYpZLg.png" alt="image-20210925163521053"></p><p><img src="https://i.loli.net/2021/09/27/dHwjf7kBD3XoMVc.png" alt="image-20210925163857831"></p><p>拆包粘包问题，</p>]]></content>
    
    
    
    <tags>
      
      <tag>nio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/25/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/25/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="关于计算机网络"><a href="#关于计算机网络" class="headerlink" title="关于计算机网络"></a>关于计算机网络</h1><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>IP地址用于确定主机</p><p>端口号用于区分主机上的不同应用。</p><p>TCP（Transmission Control Protocol, 传输控制协议）是基于数据流的协议，它是可靠的。</p><p>UDP是基于报文传输的协议，它不是可靠的但是高效，经常用于像视频聊天这种实时性高但可靠性要求不高的通信，即使再视频语音通话中，有少数的丢帧也不影响通话的整体效果。</p><p>Socket（插座）建立不同主机，不同应用间点对点的虚拟数据通道。</p><p>TCP和UDP是两种常用的socket。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment">#下面建立一个简单的socket连接</span><br><span class="hljs-comment">#第一个参数传入AF_INET代表使用ipv4地址家族，第二个参数SOCK_STREAM表示传输类型使用流传输，第三个参数为传输协议，缺省则使用第二个参数默认的，如SOCK_STREAM默认使用TCP协议传输，如果手动使用UDP会报错。</span><br><span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> s:<br><span class="hljs-comment">#ip绑定0.0.0.0表示如果服务器端有两个或以上的ip地址，那么两个都可以被识别；</span><br>    s.bind((<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">1234</span>))<br>    <span class="hljs-comment">#建立好ssocket后要对socket进行监听，s是专门负责监听连接的socket</span><br>    s.listen()<br>    <span class="hljs-comment">#当有客户端发来请求时，使用accept建立新的连接socket，用来处理消息的收发</span><br>    c, addr = s.accept()<br>    <span class="hljs-built_in">print</span>(addr, <span class="hljs-string">&quot;connected&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#消息接收与回传</span><br>        data = c.recv(<span class="hljs-number">1024</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">break</span><br>        c.sendall(data)<br></code></pre></td></tr></table></figure><p>在linux中进行测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash\">$nc 10.133.45.184 1234<br>hello<br>hello<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2021/09/24/Redis/"/>
    <url>/2021/09/24/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="需要知道"><a href="#需要知道" class="headerlink" title="需要知道"></a>需要知道</h2><p>Redis单条命令是保证原子性的，但是事务不保证原子性。</p><p>一次性，顺序性，排他性，没有隔离级别的概念，</p><p>Redis是单线程的：因为CPU处理速度不是Redis的瓶颈，Redis是基于内存操作的，它的瓶颈是机器的内存和网络带宽，单线程足够快了。</p><p>Redis为什么这么快？</p><p>Redis是将所有数据保存在内存中的，使用多线程的话CPU上下文切换也是很耗时的，使用单线程反而效率更高。</p><p>Redis可以用来做数据库，缓存和消息中间件MQ，</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>select 3                    选择第3号数据库</p><p>dbsize                        查看当前数据库大小</p><p>set key value            设置字段key的值为value</p><p>flushdb                        清空当前数据库</p><p>flushall                        清空所有数据库</p><p>keys *                            查看拥有的所有字段</p><p>exists                            是否含有某key</p><p>move key                        移除</p><p>expire key  10                  设置过期时间    </p><p>ttl key                        查看过期剩余时间</p><p>type key                    查看key类型</p><p>append key “value”            没有就set</p><p>strlen key</p><p>incr</p><p>decr</p><p>incrby</p><p>decrby</p><p>getrange key 0 3</p><p>getrange key 0 -1</p><p>setrange key 3 value</p><p>setex key 30 value</p><p>setnx key value</p><p>mset </p><p>mget</p><p>msetnx 原子性</p><p>getset</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>l(r)push list value</p><p>l(r)range list 0 1</p><p>l(r)index list 1</p><p>llen list</p><p>lrem list 3 value</p><p>ltrem list 1 2</p><p>rpoplpush list1 list2</p><p>exists list</p><p>lset list 0 value</p><p>linsert list </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>sadd set value</p><p>smembers set</p><p>sismember set value</p><p>scard set，所有元素个数</p><p>srem set value</p><p>srandmember set 2</p><p>spop 随机移除</p><p>smove set1 set2 value</p><p>sdiff set1 set2 </p><p>sinter set1 set2</p><p>sunion set1 set2</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>hset hashset field1 value1</p><p>hget hashset field</p><p> hmset</p><p> hgetall hashset</p><p>hdelete hashset filed1</p><p>  hsetnx hashset  </p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>在set基础上加了个字段 xxx</p><p>zadd</p><p>zrenge xxx </p><p>zrevrenge xxx</p><p>zrangebyscore xxx </p><p>zcard xxx</p><p>zcount xxx</p><h3 id="geospatial（底层是zset）"><a href="#geospatial（底层是zset）" class="headerlink" title="geospatial（底层是zset）"></a>geospatial（底层是zset）</h3><p>geoadd</p><p>geopos</p><p>geodist</p><p>georadius </p><p>georadiusbymember</p><h3 id="hyperloglog-不精确"><a href="#hyperloglog-不精确" class="headerlink" title="hyperloglog(不精确)"></a>hyperloglog(不精确)</h3><p>面试题：网页的UV：同一个人访问网站多次，怎么确认是同一个人的登录。</p><p>1.set保存下用户id。</p><p>2.</p><p>pfadd</p><p>pfcount</p><p>pfmerge</p><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>setbit </p><p>getbit</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>开启事务 multi</p><p>命令入队</p><p>执行 exec</p><p>放弃 discard</p><p>编译型错误，不执行</p><p>运行时错误，仍然执行正确的部分</p><p>悲观锁：很谨慎，感觉怎么都会出问题，任何时候都加锁</p><p>乐观锁：感觉不会有任何问题，不上锁，但是如果操作数据有变化，会被告知执行失败</p><p>watch，实现乐观锁，如果执行失败，unwatch解锁，再重新监视最新的值，watch</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>maven 导入Jedis依赖</p><p>new Jedis(“127.0.0.1”, “6379”)对象</p><p>其余操作和redis命令行一样。</p><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><p>初始化勾选Nosql的redis</p><p>把jedis换成了lettuce. 封装在redisTemplate中，</p><p>jedis是线程不安全的，想要变得安全要使用jedis pool，更像BIO模式</p><p>lettuce采用的是netty，实例可以在多个栈中进行分享，不存在县城不安全的情况，可以减少线程数据了，更像NIO模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>RedisTemplate redisTamplate;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function">viod <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    redisTemplate.opsForList().list的方法<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关于对象的序列化"><a href="#关于对象的序列化" class="headerlink" title="关于对象的序列化"></a>关于对象的序列化</h4><p>要么转化成json，要么就是类实现序列化（JDK 序列化implements Serializable），或者（推荐）直接在配置类中配置序列化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">templete.setKeySerialzer(<span class="hljs-keyword">new</span> xxxSerializer())<br></code></pre></td></tr></table></figure><h4 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h4><p>一般公司都会自己写一个根据自己业务的特点搞一个自己的工具类</p><h2 id="Redis-值钱的东西"><a href="#Redis-值钱的东西" class="headerlink" title="Redis 值钱的东西"></a>Redis 值钱的东西</h2><p>上面讲的都是使用Redis的基本操作</p><h3 id="Redis-config"><a href="#Redis-config" class="headerlink" title="Redis.config"></a>Redis.config</h3><p>配置文件对大小写不敏感。</p><p>包含，可以用 import 进行引用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">绑定端口</span><br>bind ipaddress<br><span class="hljs-meta">#</span><span class="bash">开启保护模式</span><br>protected-mode yes<br><span class="hljs-meta">#</span><span class="bash">设置端口</span><br>port xxxx<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">以守护进程的方式运行（后台运行）</span><br>deamonize yes<br><span class="hljs-meta">#</span><span class="bash">如果以后台方式运行，我们需要指定pid进程文件</span><br>profile /var/run/redis_6379.pid<br><span class="hljs-meta">#</span><span class="bash">日志，有多种日志级别</span><br>loglevel notice  #生产环境使用<br><span class="hljs-meta">#</span><span class="bash">日志的文件名</span><br>logfile &quot;&quot;  #空的话代表不保存直接输出<br><span class="hljs-meta">#</span><span class="bash">数据库数量</span><br>database 16<br><br><br>快照<br><span class="hljs-meta">#</span><span class="bash">持久化(防止内存数据库断电失去),在规定的时间内，执行了多少次操作会持久化到文件</span><br><span class="hljs-meta">#</span><span class="bash">900秒内，如果至少有一个key进行了修改，就要进行持久化</span><br>save 900 1<br>save 300 10<br>save 60 10000<br><span class="hljs-meta">#</span><span class="bash">持久化出错是否继续工作</span><br>stop-write-bgsave-error yes<br><span class="hljs-meta">#</span><span class="bash">是否压缩rdb文件（持久化文件），会占用CPU资源</span><br>rdbcompression yes<br><span class="hljs-meta">#</span><span class="bash">是否校验rdb文件（）</span><br>rdbchecksum yes<br><span class="hljs-meta">#</span><span class="bash">rdb文件保存目录</span><br>dir ./<br><br>RDB（下文单讲）<br><br>安全<br>requirepass xxx<br><span class="hljs-meta">#</span><span class="bash">或者在命令行config <span class="hljs-built_in">set</span> requirepass xxxx</span><br><span class="hljs-meta">#</span><span class="bash">认证</span><br>auth &quot;xxxx&quot;<br><br><br>客户端<br><span class="hljs-meta">#</span><span class="bash">了解一下</span><br>maxclients 1000<br>maxmemory &lt;bytes&gt;<br><span class="hljs-meta">#</span><span class="bash">内存满了使用什么策略处理</span><br>maxmemory-policy noeviction<br><br><br>APPEND ONLY模式 aof（持久化方式2） 配置<br>appendonly no #默认使用rdb方式持久化，大多数情况下rdf够用。<br>appendfilename &quot;appendonly.aof&quot;#持久化的文件名<br><span class="hljs-meta">#</span><span class="bash">每秒执行一次同步（可能丢失这个时候的数据）可以设置为no,always</span><br>appendfsync everysec<br></code></pre></td></tr></table></figure><h3 id="持久化RDB"><a href="#持久化RDB" class="headerlink" title="持久化RDB"></a>持久化RDB</h3><p>RDB就是Redis Database；保存的文件叫dump.rdb。</p><p>可以自定义一个save</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save 60 5<br></code></pre></td></tr></table></figure><ol><li><p>save设置的规则满足的情况下，会自动触发rdb规则。</p></li><li><p>执行flushall也会触发rdb规则</p></li><li><p>退出redis也会产生。</p></li></ol><p>如何回复？</p><ol><li><p>把文件放在redis的启动位置就好了，redis启动会自动检查dump.rdb文件并恢复数据。</p></li><li><p>config get dir  #自动扫描/usr/local/bin下存在的dump.rdb</p></li></ol><p>rdb的优缺点：</p><ol><li>优点：<ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高的时候使用</li></ol></li><li>缺点<ol><li>需要一定的时间间隔进程操作！如果redis意外宕机，最后一次修改的数据就没有了</li><li>fork进程的时候，会赵勇一定的内存空间！！</li></ol></li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>记录所有写操作，默认关闭</p><p>append only file</p><p>appendfsync everysec  #每秒同步</p><p>如果恶意破坏aof文件则没法恢复，使用下面的语句修复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-check-aof --fix appendonly.aof<br></code></pre></td></tr></table></figure><p>aof的优缺点：(?????????????????????)</p><ol><li>优点：<ol><li>每一次修改都同步（always），文件的完整性更好</li><li></li></ol></li><li>缺点<ol><li></li><li></li></ol></li></ol><h3 id="消息发布与订阅（还是交给专门的中间件来做吧）"><a href="#消息发布与订阅（还是交给专门的中间件来做吧）" class="headerlink" title="消息发布与订阅（还是交给专门的中间件来做吧）"></a>消息发布与订阅（还是交给专门的中间件来做吧）</h3><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>redis一般是集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">info replication<span class="hljs-comment">#查看当前库的主从信息</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis与JDBC</title>
    <link href="/2021/09/23/Mybatis%E4%B8%8EJDBC/"/>
    <url>/2021/09/23/Mybatis%E4%B8%8EJDBC/</url>
    
    <content type="html"><![CDATA[<h2 id="Mybatis与JDBC"><a href="#Mybatis与JDBC" class="headerlink" title="Mybatis与JDBC"></a>Mybatis与JDBC</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC，Java Database Connectivity，舰名思意，Java数据库连接，一般操作的步骤如下：</p><p>1，根据四要素（Driver-Class，url，username，password）获得连接，</p><p>2，编写sql语句，</p><p>3，获取preparedStatement，预编译sql语句，</p><p>4，获取并处理结果集</p><p>5，关闭资源</p><p>使用第三方数据库连接池时需要配置dataSource。</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>Mybatis算是一个ORM框架，说到底内部也是封装了JDBC的，但是简化了很多操作，它的操作步骤：</p><p>1，sqlSessionFactory获取一个sqlSession,（session.getMapper）</p><p>2，编写@Mapper的mapper接口（DAO）</p><p>3，编写xml映射文件（包括sql语句，返回封装的Bean）          —————-与数据库交互</p><p>4，编写@Service的service业务逻辑代码</p><h3 id="JDBC与Mybatis比有哪些局限性呢"><a href="#JDBC与Mybatis比有哪些局限性呢" class="headerlink" title="JDBC与Mybatis比有哪些局限性呢"></a>JDBC与Mybatis比有哪些局限性呢</h3><p>1.数据库连接池（减少数据库关闭开启时数据库的资源浪费）：</p><p>2.SQL配置文件（减少硬编码）：原生JDBC直接在java中写sql语句，及其不好维护。</p><p>3.动态SQL语句（只专注写sql，各干各的事，专一）</p><p>4.映射（resultset直接转为java对象）：不用再操作底层的ResultSet。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2021/09/20/SpringMVC/"/>
    <url>/2021/09/20/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC原理"><a href="#SpringMVC原理" class="headerlink" title="SpringMVC原理"></a>SpringMVC原理</h1><h2 id="SpringMVC架构："><a href="#SpringMVC架构：" class="headerlink" title="SpringMVC架构："></a>SpringMVC架构：</h2><p>所有的WEB MVC框架都是这么设计的：一个中央Servlet程序，用于把请求分发到相应的控制器，实现业务逻辑与跳转。由于SpringMVC整合了Spring IoC容器，所以它具有Spring的所有功能。Spring的Servlet的实现类是DispatcherServlet，具有更强大的功能。</p><h3 id="DispatcherServlet："><a href="#DispatcherServlet：" class="headerlink" title="DispatcherServlet："></a>DispatcherServlet：</h3><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20210908095953054.png" alt="image-20210908095953054" style="zoom: 80%;" /><h3 id="浏览器访问流程："><a href="#浏览器访问流程：" class="headerlink" title="浏览器访问流程："></a>浏览器访问流程：</h3><p>用户向服务器发送HTTP请求，DispatcherServlet根据请求的信息通过Mapping寻找到处理请求的处理器，并返回到DispatcherServlet；HandlerAdapter再根据请求参数适配到指定的方法处理service业务，结果以mv的形式回传；View对mv进行渲染返回给客户。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Mybatis</title>
    <link href="/2021/09/19/Springboot%20Mybaits%20%E6%95%B4%E5%90%88%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/09/19/Springboot%20Mybaits%20%E6%95%B4%E5%90%88%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot-Mybaits-整合记录"><a href="#Springboot-Mybaits-整合记录" class="headerlink" title="Springboot Mybaits 整合记录"></a>Springboot Mybaits 整合记录</h1><p>新建项目，添加组件</p><p>导入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入mybatis--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置数据源信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/lou_springboot?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.alibaba.druid.proxy.DruidDriver</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">lunfee</span><br></code></pre></td></tr></table></figure><p>配置服务器访问端口</p><p>配置要么写在配置文件中，要么就写配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yam">server:<br>  port: 80<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2021/09/19/Springboot%20%E4%B8%AD,%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/09/19/Springboot%20%E4%B8%AD,%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Springboot-中-和-的区别"><a href="#Springboot-中-和-的区别" class="headerlink" title="Springboot 中/**,/和/*的区别"></a>Springboot 中/**,/和/*的区别</h2><p>Springboot 中经常使用拦截器，过滤器处理掉一部分请求操作，在设置拦截域的时候使用/**,/和/*拦截的效果是不同的</p><p>/**：拦截所有文件，包括文件夹下的子文件夹，包括静态资源，因此在拦截的时候需要放行如.css文件等的静态资源</p><p>/*：拦截该文件夹下所有的文件路径，不包含子文件夹，包涵页面。</p><p>/：拦截该文件夹下的所有文件路径，不包含页面</p>]]></content>
    
    
    
    <tags>
      
      <tag>/*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好康的</title>
    <link href="/2021/09/16/%E5%A5%BD%E5%BA%B7%E7%9A%84/"/>
    <url>/2021/09/16/%E5%A5%BD%E5%BA%B7%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="好康的"><a href="#好康的" class="headerlink" title="好康的"></a>好康的</h1><h2 id="关于-和-equals-的区别"><a href="#关于-和-equals-的区别" class="headerlink" title="关于==和.equals()的区别"></a>关于==和.equals()的区别</h2><p>其实很多人对于这个问题的答案可能就是一句简单的：双=号比较的是在堆内存中的地址值，equals()方法比较的是内容值。但是面试官要听的可不是这句话，或者他一定会问更深，更底层的问题，这里面牵扯了很多底层的计算机或者Java虚拟机的内容，下面先浅显的做一个梳理，后面有机会的话再修改补充。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>内存作为一个存储数据的存在， 有一个很重要的特性， 就是内存里的数据能被cpu直接访问（或者说被CPU的高速缓存区直接访问），所以内存才是计算机系统的主存储器， 而硬盘是外部存储器。</p><p>我们把内存分成了以字节为单位的结构， 但是实际上内存里还是有非常多的字节的，例如64MB内存就有 64 × 1024 × 1024 个字节，如果cpu要查找1个变量， 还是要1个个字节去找到话，时一个很浪费时间的行为，所以为了避免去遍历内存，计算机系统就引入了内存地址这个概念。在32位操作系统中，<strong>内存的地址就是32位的2进制数</strong>， 所以32位的地址范围就是从 0000 0000 0000 0000 0000 0000 0000 0000 到 1111 1111 1111 1111 1111 1111 1111 1111 （ox00000000 - oxFFFFFFFF)， 共2^32个内存地址，也就是 4GB，所以如果你给32位的系统配上了8GB的内存， 操作系统最多也只能给其中4GB 分配地址， 其余 4GB 是没有地址， 因为地址不够用啊， 所以32位系统最多支持4GB内存就是这样来的。 </p><p>说了这么多就是想讲在32位系统和64位系统中，指针的大小实际上是不一样的，因为指针时存放内存地址的，这么讲是针对C语言而言的，JAVA是不能直接操作计算机内存空间的。</p><h3 id="JVM的变量存储"><a href="#JVM的变量存储" class="headerlink" title="JVM的变量存储"></a>JVM的变量存储</h3><p>首先，我们先大概知道一下JVM的内存模型和Java的四类八种基本数据类型。</p><p>需要指出的是，java 在不同位的机器上执行时，</p><p><img src="https://i.loli.net/2021/09/27/hvOpPICSVGeJyRl.png" alt="image-20210923120220226"></p><p>在JVM内存模型中，方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就是局部变量只能在方法中有效的原因。</p><p>方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。</p><p>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）都是放在方法栈中</p><p>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p><p>类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</p><p>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量</p><p>​    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的</p><p>​    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。</p><h3 id="和-equals"><a href="#和-equals" class="headerlink" title="==和.equals()"></a>==和.equals()</h3><p>基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。</p><p>引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是<strong>堆内存</strong>地址）。</p><p>对于引用数据类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。<strong>因为每new一次，都会重新开辟堆内存空间</strong>。</p><p>JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    <span class="hljs-comment">//this - s1    //obj - s2    </span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。 </p><p>所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。我们对上面的两段内容做个总结吧： <strong>== 的作用：</strong></p><p>　　基本类型：比较的就是值是否相同</p><p>　　引用类型：比较的就是地址值是否相同</p><p>String类的equals()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>              String anotherString = (String)anObject;<br>              <span class="hljs-keyword">int</span> n = value.length;<br>              <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>                  <span class="hljs-keyword">char</span> v1[] = value;<br>                 <span class="hljs-keyword">char</span> v2[] = anotherString.value;<br>                 <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>                 <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                     <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                     i++;<br>                 &#125;<br>                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>     &#125;<br></code></pre></td></tr></table></figure><p>所以很明显比较的是两个String的值是否相同。说到这里感觉已经把==和.equals()的区别讲差不多了。</p><p>参考：<a href="https://www.zhihu.com/search?q===%E5%92%8Cequals&amp;utm_content=search_history&amp;type=content">https://www.zhihu.com/search?q=%3D%3D%E5%92%8Cequals&amp;utm_content=search_history&amp;type=content</a></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/27626724">https://zhuanlan.zhihu.com/p/27626724</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>equals</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈</title>
    <link href="/2021/09/14/%E6%9D%82%E8%B0%88/"/>
    <url>/2021/09/14/%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><h2 id="关于Spring“自动”这件事"><a href="#关于Spring“自动”这件事" class="headerlink" title="关于Spring“自动”这件事"></a>关于Spring“自动”这件事</h2><p>下面说的三种时期亦或是三种方式，知识入口不同而已，容器底层启动的过程是一样的，方式有早期和主流之分，但在开发中多是灵活搭配的，例如早期的代码融入新技术实现的代码（Import）。</p><h3 id="1-XML配置时期"><a href="#1-XML配置时期" class="headerlink" title="1.XML配置时期"></a>1.XML配置时期</h3><p>最开始使用Spring的时候，也是早期主流的使用方式，我们需要在beans.xml中创建<bean>标签，并在子标签中对相应属性进行赋值，常用的方式有：</p><p>传值三种方式：按参数索引，按参数类型，按参数名</p><p>1.构造器注入（bean类中有相应的构造器）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentConstruct2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;domain.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.set注入（bean类中有相应的set方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;domain.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;11&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以该文件为参数传入ClassPathXmlApplicationContext会得到一个applicationContext的上下文容器对象。</p><p>从容器中获取bean并强转到原类型就能从容器中拿到该已赋值的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取applicationContext</span><br>ClassPathXmlApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br><span class="hljs-comment">//传入beanId, 获取bean</span><br>Student studentNoValue = (Student) applicationContext.getBean(<span class="hljs-string">&quot;student&quot;</span>);<br></code></pre></td></tr></table></figure><p>这种方式摆脱了奴役我们很久的new对象的方式，尽管这种方式看起来很麻烦，（重要的是思想，等我复习了再补充）</p><h3 id="2-Autowired-Bean时期"><a href="#2-Autowired-Bean时期" class="headerlink" title="2.@Autowired@Bean时期"></a>2.@Autowired@Bean时期</h3><p>在spring的一个叫做核心配置文件的东西中配置自动扫描哪些包下面的bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">#配置自动扫描包路径<br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.lunfee.beans&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>于此同时</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br></code></pre></td></tr></table></figure><h3 id="3-Java-Config时期（SpringBoot）"><a href="#3-Java-Config时期（SpringBoot）" class="headerlink" title="3.Java Config时期（SpringBoot）"></a>3.Java Config时期（SpringBoot）</h3>]]></content>
    
    
    
    <tags>
      
      <tag>关于Spring的一些理解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Session,Cookie,Request</title>
    <link href="/2021/09/11/session,cookie,request%E5%9F%9F/"/>
    <url>/2021/09/11/session,cookie,request%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="session-cookie-request域"><a href="#session-cookie-request域" class="headerlink" title="session,cookie,request域"></a>session,cookie,request域</h2><p>他们的作用都是保存页面的信息，</p><h3 id="sessi0n"><a href="#sessi0n" class="headerlink" title="sessi0n"></a>sessi0n</h3><p>用于存放不同页面的公共信息，比如登录信息，比如在商品页面添加到心愿单的商品，在跳转到购物车页面的时候任然可以获取到；</p><p>作用域：session 的作用域是一个会话</p><p>原理：用户发送一个请求访问到 Servlet，在服务器上找一块内存，实际上是一个键值对，前面是 String name，后面是Object value，每一个客户端都有一个session，每个客户端之间，当服务器为客户端下发一个临时的cookie（浏览器的内存中），名字叫JSESSIONID，是一组字母加数字的序列，表示访问服务器session内存的“凭证”，客户端通过JSESSIONID这个凭证访问自己对应的服务器存储session的内存。</p><p>失效：  1、客户端关闭浏览器程序，造成了JSESSIONID凭证丢失<br>                    2、时效性，session超时（会话超时）：a、客户端关闭后，一段时间内没有访问过该session内存，服务器会清理。b、或者一段时间内没有访问过该session内存，服务器会清理。c、会话超时的时间，默认是30分钟，只要发起请求，会话时间从0重新计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//页面1</span><br>session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;苹果&quot;</span>);<br><span class="hljs-comment">//页面2</span><br>session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>在 Springboot 中，只用在配置文件中配置就可以实现改变 session 的生命周期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pro">server.servlet.session.timeout=60  #单位分钟<br></code></pre></td></tr></table></figure><h3 id="requset"><a href="#requset" class="headerlink" title="requset"></a>requset</h3><p>常用于服务器间同一请求不同页面之间的参数传递，常应用于表单的控件值传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">request.setAttribute(); <br>request.getAttribute();<br>request.removeAttribute();<br>request.getParameter().<br></code></pre></td></tr></table></figure><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><p>model仅在一次request中有效，所以也存放临时值</p>]]></content>
    
    
    
    <tags>
      
      <tag>域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thymeleaf</title>
    <link href="/2021/09/11/Thymeleaf/"/>
    <url>/2021/09/11/Thymeleaf/</url>
    
    <content type="html"><![CDATA[<p>Thymeleaf </p><p>Thymeleaf 自动配置里面添加了默认的前后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.html&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">th:action=&quot;@&#123;/index&#125;      使用模板引擎定向controller<br>th:text=&quot;$&#123;&#125;&quot;             向model中取值//也可以像request中取值，一次request对应一个model//zh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于请求转发</title>
    <link href="/2021/09/11/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/"/>
    <url>/2021/09/11/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="请求转发，刷新页面"><a href="#请求转发，刷新页面" class="headerlink" title="请求转发，刷新页面"></a>请求转发，刷新页面</h2><p>在页面的跳转中，如果使用return”页面名”，默认走的是请求转发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&#123;&quot;/login&quot;,&quot;/&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLoginPage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@PostMapping(&quot;/index&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndexPage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--login表单提交走post请求，跳转到/index 控制器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-signin&quot;</span>  <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/index&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这种情况下，刷新页面会重新提交表单，要避免这种情况要使用重定向方法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
