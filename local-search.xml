<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM虚拟机</title>
    <link href="/2021/10/25/JVM/"/>
    <url>/2021/10/25/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM杂志"><a href="#JVM杂志" class="headerlink" title="JVM杂志"></a>JVM杂志</h1><h2 id="变量分类（于我很难）"><a href="#变量分类（于我很难）" class="headerlink" title="变量分类（于我很难）"></a>变量分类（于我很难）</h2><ol><li><p>按数据类型分：可以分为基本数据类型 vs 引用数据类型（对象，数组，接口……（不用多说）</p></li><li><p>按在类中声明的位置分：可以分为局部变量（声明在方法中，使用前必须进行显示的赋值，否则编译不通过） vs </p><p>​                                                        成员变量（使用前会经历默认初始化赋值）：</p><p>​                                                                    类变量（用static修饰，也叫静态变量）：在类加载阶段进行初始化赋值</p><p>​                                                                    实例变量（无static修饰）：对象的创建过程中，会在堆空间为实例变量分配空间，并进行默认赋值</p></li></ol><h2 id="内加载："><a href="#内加载：" class="headerlink" title="内加载："></a>内加载：</h2><p>描述类加载过程：<init><clinit></p><p>类加载与static</p><p>如何判断两个class文件是否为同一个类：</p><ul><li>全类名一致（包括包名）</li><li>加载class文件的 ClassLoader 必须一致（类加载的双亲委派机制）</li></ul><p>蜜汁方法区：（由此可见方法区有一个功能是用来存放类型信息的，在保证即使存在多个线程，共用类也只在堆空间中被加载一次）</p><ul><li>JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的，如果是由用户类加载器加载的话，JVM则将这个类加载器的一个引用作为类型信息的一部分存放在方法区。</li></ul><h2 id="内存结构："><a href="#内存结构：" class="headerlink" title="内存结构："></a>内存结构：</h2><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><ul><li><p>程序计数器只用来存储当前线程下一条指令的“行号”（指令地址），占用极小的内存空间（几乎可以忽略不计），因此他也是JVM中唯一一个没有内存溢出的内存区域，如果当前执行的是本地方法则标记为 undefined。</p></li><li><p>程序计数器的定位和与其他结构的交互</p></li></ul><p><img src="https://i.loli.net/2021/10/24/71gefiVvsLYnxrq.png" alt="image-20211024200420957"></p><ul><li>PC的作用：控制程序的正常运行；上下文切换时保留和恢复现场（所以它必须是线程私有的）</li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="线程私有（这是一句废话）"><a href="#线程私有（这是一句废话）" class="headerlink" title="线程私有（这是一句废话）"></a>线程私有（这是一句废话）</h4><h4 id="作用（得明确）"><a href="#作用（得明确）" class="headerlink" title="作用（得明确）"></a>作用（得明确）</h4><p>保存方法区的局部变量(8中基本数据类型和对象的引用地址)，部分结果，参与方法的调用与返回（栈帧间），方法结束则将栈帧销毁，因此虚拟机栈不需要进行垃圾回收。</p><p>可能出现的异常（需要区分发生的原因）：</p><ul><li>StackOverflowError：方法过多或者递归过深导致。</li><li>OutOfMemoryError：栈未满而报OOM的原因除了内存空间真的就很小之外，主要的原因在于程序可能创建了过多的线程。</li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><p>调优：-Xss 设置虚拟机线程栈的大小（针对StackOverflowError）</p><h4 id="内部结构（栈帧）"><a href="#内部结构（栈帧）" class="headerlink" title="内部结构（栈帧）"></a>内部结构（栈帧）</h4><p>​    总体结构就是一个一个的栈帧，没执行一次方法对应一个栈帧（包括递归的），栈帧之间的切换（栈帧结束）依据是return（无返回值的字节码就是return）或者未捕获异常以抛出异常的方式结束</p><p><img src="https://i.loli.net/2021/10/24/SJEhxjFWby39dBI.png" alt="image-20211024210935486"></p><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><ol><li><p>定义为一个数字数组，用于存储方法参数以及局部变量，包括基本数据类型，对象引用，以及<strong>returnAddress类型</strong>，数组的每个字段单元为一个Slot，除了long和double，都占用一个Slot（这是针对64位机而言的，32位机都是一个Slot）</p></li><li><p>不存在线程安全问题（废话）</p></li><li><p>容量大小在编译器就确定并固定，保存在方法的Code属性的maximum local variables数据项中</p><p>眼见为实，看一下局部变量表的真面目，startPC和Length分别为作用域开始字节码指令的位置和作用域长度</p><p><img src="https://i.loli.net/2021/10/25/WJxU6CQIOKywXu7.png" alt="image-20211025100721866"></p><p>非静态方法（实例方法）和构造方法中，都会有一个this的引用在变量槽的起始位置，这也是在静态方法中没法使用this的底层原因，直观上看的话，就是静态方法是直接被类调用的，this不到当前的实例</p><p><img src="https://i.loli.net/2021/10/25/ykN4GvzKScinLPe.png"></p><p>double数据在局部变量表中占两个slot</p><p><img src="https://i.loli.net/2021/10/25/63siDYatABR2CVq.png" alt="image-20211025104448577"></p><p>局部变量表的确定是需要计算的，例如当某局部变量出了作用域，他所只能用的slot可以被重复利用，节省了一部分空间</p><p><img src="https://i.loli.net/2021/10/25/9RNFvBro1tmeZTx.png" alt="image-20211025104933201"></p><p><img src="https://i.loli.net/2021/10/25/aCDUR5hlOEsKcdo.png" alt="image-20211025110912220"></p></li></ol><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>在方法的执行过程中，进行复制，值交换求和等操作需要对操作数栈进行读数据写数据操作，即入栈出栈。</p><p>java的解释引擎是基于栈的执行引擎，这个栈就是指栈帧中的操作数栈</p><p>和局部变量表一样，在编译之后其大小就已经确定（我感觉这个确定不容易），但其大小和局部变量表的大小没有直接关系</p><p><img src="https://i.loli.net/2021/10/25/ZbF8HJ1OjlTqkB7.png" alt="image-20211025113240607"></p><p>很容易发现，使用操作数栈的执行方式的字节码会更加臃肿，存在大量的入栈出栈操作，与使用寄存器的方式相比会降低执行的效率，栈顶缓存技术将栈顶频繁使用的元素全部缓存到CPU的寄存器中，避免了频繁的对内存进行读写，提高执行引擎的效率。</p><h5 id="动态链接（指向运行时常量池的方法引用）（像一个对照表从符号引用到真实引用）"><a href="#动态链接（指向运行时常量池的方法引用）（像一个对照表从符号引用到真实引用）" class="headerlink" title="动态链接（指向运行时常量池的方法引用）（像一个对照表从符号引用到真实引用）"></a>动态链接（指向运行时常量池的方法引用）（像一个对照表从符号引用到真实引用）</h5><p>常量池中的符号引用</p><p><img src="https://i.loli.net/2021/10/25/awWiOmVvGEunbP5.png" alt="image-20211025153036821"></p><p><img src="https://i.loli.net/2021/10/25/9SYIQPdfUA4c2FW.png" alt="image-20211025152831213"></p><p>方法调用</p><ul><li><p>绑定的概念：一个属性，方法或者类在从符号引用转换成直接引用的过程，该过程只发生一次。</p><p>如果被调用的目标在编译器就能确定如何绑定，可以使用静态链接的方法进行早期绑定</p><p>否则就在运行时使用动态链接的方式进行动态绑定，动态链接主要指的是多态的方式（invokeinterface，invokevirtural）</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法&lt;临时&gt;</title>
    <link href="/2021/10/23/%E8%AF%B4%E6%98%8E%EF%BC%9A/"/>
    <url>/2021/10/23/%E8%AF%B4%E6%98%8E%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<p>说明：</p><p>本题解主要是写给对 回溯算法 还比较陌生的朋友，所以会介绍得很详细；<br>如果看题解觉得比较冗长，可以先观看我投稿给「力扣」 官方题解 的视频；<br>本文还在持续更新，由于个人水平和精力有限，没法一下子表达出所有想表达的意思，还请大家见谅。<br>补充说明（2020 年 8 月 31 日补充）：请大家做了一些回溯算法的问题以后顺便思考一下：深度优先遍历、递归、栈，它们三者的关系，我个人以为它们背后统一的逻辑都是「后进先出」。完成练习有助于我们深刻理解算法思想，我们加油！</p><p>回溯算法与深度优先遍历<br>以下是维基百科中「回溯算法」和「深度优先遍历」的定义。</p><p>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><p>找到一个可能存在的正确的答案；<br>在尝试了所有可能的分步方法后宣告该问题没有答案。<br>深度优先搜索 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p><p>我刚开始学习「回溯算法」的时候觉得很抽象，一直不能理解为什么递归之后需要做和递归之前相同的逆向操作，在做了很多相关的问题以后，我发现其实「回溯算法」与「 深度优先遍历 」有着千丝万缕的联系。</p><p>个人理解<br>「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。至于广度优先遍历为什么没有成为强大的搜索算法，我们在题解后面会提。</p><p>在「力扣」第 51 题的题解《回溯算法（第 46 题 + 剪枝）》 中，展示了如何使用回溯算法搜索 44 皇后问题的一个解，相信对大家直观地理解「回溯算法」是有帮助。</p><p>搜索与遍历<br>我们每天使用的搜索引擎帮助我们在庞大的互联网上搜索信息。搜索引擎的「搜索」和「回溯搜索」算法里「搜索」的意思是一样的。</p><p>搜索问题的解，可以通过 遍历 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 搜索一个问题的所有的解 ，通过深度优先遍历的思想实现。</p><p>与动态规划的区别<br>共同点<br>用于求解多阶段决策问题。多阶段决策问题即：</p><p>求解一个问题分为很多步骤（阶段）；<br>每一个步骤（阶段）可以有多种选择。<br>不同点<br>动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；<br>回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。<br>从全排列问题开始理解回溯算法<br>我们尝试在纸上写 33 个数字、44 个数字、55 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。</p><p>先写以 11 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；<br>再写以 22 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；<br>最后写以 33 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。<br>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。</p><p>看到这里的朋友，建议先尝试自己画出「全排列」问题的树形结构。</p><p>说明：</p><p>每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；<br>使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；<br>深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；<br>深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。<br>使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p><p>设计状态变量<br>首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；<br>递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；<br>布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。<br>这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p><p>代码实现<br>参考代码 1：</p><p>注意：下面的代码是错误的，希望读者能运行测试用例，发现原因，然后再阅读后面的内容。</p><p>JavaPython</p><p>import java.util.ArrayList;<br>import java.util.List;</p><p>public class Solution {</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;    int len = nums.length;    // 使用一个动态数组保存所有可能的全排列    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if (len == 0) &#123;        return res;    &#125;    boolean[] used = new boolean[len];    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    dfs(nums, len, 0, path, used, res);    return res;&#125;private void dfs(int[] nums, int len, int depth,                 List&lt;Integer&gt; path, boolean[] used,                 List&lt;List&lt;Integer&gt;&gt; res) &#123;    if (depth == len) &#123;        res.add(path);        return;    &#125;    // 在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。    for (int i = 0; i &lt; len; i++) &#123;        if (!used[i]) &#123;            path.add(nums[i]);            used[i] = true;            dfs(nums, len, depth + 1, path, used, res);            // 注意：下面这两行代码发生 「回溯」，回溯发生在从 深层结点 回到 浅层结点 的过程，代码在形式上和递归之前是对称的            used[i] = false;            path.remove(path.size() - 1);        &#125;    &#125;&#125;public static void main(String[] args) &#123;    int[] nums = &#123;1, 2, 3&#125;;    Solution solution = new Solution();    List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);    System.out.println(lists);&#125;</code></pre><p>}<br>执行 main 方法以后输出如下：</p><p>[[], [], [], [], [], []]<br>原因出现在递归终止条件这里：</p><p>JavaPython</p><p>if (depth == len) {<br>    res.add(path);<br>    return;<br>}<br>变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表。</p><p>在 Java 中，参数传递是 值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 66 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。</p><p>修改的部分：</p><p>JavaPython</p><p>if (depth == len) {<br>    res.add(new ArrayList&lt;&gt;(path));<br>    return;<br>}<br>此时再提交到「力扣」上就能得到通过了，完整代码请见下文「参考代码 2」。</p><p>复杂度分析：（初学回溯算法的时候可以暂时跳过。）</p><p>回溯算法由于其遍历的特点，时间复杂度一般都比较高，有些问题分析起来很复杂。一些回溯算法解决的问题，剪枝剪得好的话，复杂度会降得很低，因此分析最坏时间复杂度的意义也不是很大。但还是视情况而定。</p><p>时间复杂度：O(N \times N!)O(N×N!)<br>非叶子结点的个数，依次为（按照层数来）：</p><p>1 + A_N^1 + A_N^2 + \cdots + A_N^{N-1} = 1 + \cfrac{N!}{(N - 1)!} + \cfrac{N!}{(N - 2)!} + \cdots + N!<br>1+A<br>N<br>1</p><p> +A<br>N<br>2</p><p> +⋯+A<br>N<br>N−1</p><p> =1+<br>(N−1)!<br>N!</p><ul><li><p>(N−2)!<br>N!</p></li><li><p>⋯+N!</p></li></ul><p>说明：根结点为 11，计算复杂度的时候忽略；A_N^1A<br>N<br>1</p><p>  表示排列数，计算公式为 A_n^m = \cfrac{n!}{(n - m)!}A<br>n<br>m</p><p> =<br>(n−m)!<br>n!</p><p> 。</p><p>在第 1 层，结点个数为 NN 个数选 1 个的排列，故为 A_N^1A<br>N<br>1</p><p> ；</p><p>在第 2 层，结点个数为 NN 个数选 2 个的排列，故为 A_N^2A<br>N<br>2</p><p> 。</p><p>\cfrac{N!}{(N - 1)!} + \cfrac{N!}{(N - 2)!} + \cdots + N! = N! \left( \cfrac{1}{(N - 1)!} + \cfrac{1}{(N - 2)!} + \cdots + 1 \right) \le N! \left( 1 + \cfrac{1}{2} + \cfrac{1}{4} + \cdots + \cfrac{1}{2^{N - 1}} \right) &lt; 2N!<br>(N−1)!<br>N!</p><ul><li><p>(N−2)!<br>N!</p></li><li><p>⋯+N!=N!(<br>(N−1)!<br>1</p></li><li><p>(N−2)!<br>1</p></li><li><p>⋯+1)≤N!(1+<br>2<br>1</p></li><li><p>4<br>1</p></li><li><p>⋯+<br>2<br>N−1</p></li></ul><p>1</p><p> )&lt;2N!</p><p>将常系数 22 视为 11，每个内部结点循环 NN 次，故非叶子结点的时间复杂度为 O(N \times N!)O(N×N!)；</p><p>最后一层共 N!N! 个叶节点，在叶子结点处拷贝需要 O(N)O(N)，叶子结点的时间复杂度也为 O(N \times N!)O(N×N!)。</p><p>空间复杂度：O(N \times N!)O(N×N!)。<br>递归树深度 \log NlogN；<br>全排列个数 N!N!，每个全排列占空间 NN。取较大者。<br>理解回溯<br>从 [1, 2, 3] 到 [1, 3, 2] ，深度优先遍历是这样做的，从 [1, 2, 3] 回到 [1, 2] 的时候，需要撤销刚刚已经选择的数 3，因为在这一层只有一个数 3 我们已经尝试过了，因此程序回到上一层，需要撤销对 2 的选择，好让后面的程序知道，选择 3 了以后还能够选择 2。</p><p>执行深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做「状态重置」，即「回到过去」、「恢复现场」，我们举一个例子。</p><p>月光宝盒<br>只有撤销上一次的选择，重置现场，才能够回到 完全一样 的过去，再开始新的尝试才会是有效的。</p><p>《大话西游》里有这样的情节，至尊宝要对着「月光宝盒」喊一声「波若菠萝蜜」，时间就可以回到回去（所有的人物、事物都得一样，才能叫「回到过去」），他才能救人。这个道理其实和这里的「撤销选择」是一模一样的。</p><p>理解回溯比较困难的是理解「回到过去」，现实世界里我们无法回到过去，但是在算法的世界里可以。</p><p>通过打印输出观察<br>参考代码 2：</p><p>Java</p><p>import java.util.ArrayDeque;<br>import java.util.ArrayList;<br>import java.util.Deque;<br>import java.util.List;</p><p>public class Solution {</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;    int len = nums.length;    // 使用一个动态数组保存所有可能的全排列    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if (len == 0) &#123;        return res;    &#125;    boolean[] used = new boolean[len];    Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(len);    dfs(nums, len, 0, path, used, res);    return res;&#125;private void dfs(int[] nums, int len, int depth,                 Deque&lt;Integer&gt; path, boolean[] used,                 List&lt;List&lt;Integer&gt;&gt; res) &#123;    if (depth == len) &#123;        res.add(new ArrayList&lt;&gt;(path));        return;    &#125;    for (int i = 0; i &lt; len; i++) &#123;        if (!used[i]) &#123;            path.addLast(nums[i]);            used[i] = true;            System.out.println(&quot;  递归之前 =&gt; &quot; + path);            dfs(nums, len, depth + 1, path, used, res);            used[i] = false;            path.removeLast();            System.out.println(&quot;递归之后 =&gt; &quot; + path);        &#125;    &#125;&#125;public static void main(String[] args) &#123;    int[] nums = &#123;1, 2, 3&#125;;    Solution solution = new Solution();    List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);    System.out.println(lists);&#125;</code></pre><p>}<br>控制台输出：</p><p>  递归之前 =&gt; [1]<br>  递归之前 =&gt; [1, 2]<br>  递归之前 =&gt; [1, 2, 3]<br>递归之后 =&gt; [1, 2]<br>递归之后 =&gt; [1]<br>  递归之前 =&gt; [1, 3]<br>  递归之前 =&gt; [1, 3, 2]<br>递归之后 =&gt; [1, 3]<br>递归之后 =&gt; [1]<br>递归之后 =&gt; []<br>  递归之前 =&gt; [2]<br>  递归之前 =&gt; [2, 1]<br>  递归之前 =&gt; [2, 1, 3]<br>递归之后 =&gt; [2, 1]<br>递归之后 =&gt; [2]<br>  递归之前 =&gt; [2, 3]<br>  递归之前 =&gt; [2, 3, 1]<br>递归之后 =&gt; [2, 3]<br>递归之后 =&gt; [2]<br>递归之后 =&gt; []<br>  递归之前 =&gt; [3]<br>  递归之前 =&gt; [3, 1]<br>  递归之前 =&gt; [3, 1, 2]<br>递归之后 =&gt; [3, 1]<br>递归之后 =&gt; [3]<br>  递归之前 =&gt; [3, 2]<br>  递归之前 =&gt; [3, 2, 1]<br>递归之后 =&gt; [3, 2]<br>递归之后 =&gt; [3]<br>递归之后 =&gt; []<br>输出 =&gt; [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]<br>几点说明帮助理解「回溯算法」<br>每一次尝试都「复制」，则不需要回溯<br>如果在每一个 非叶子结点 分支的尝试，都创建 新的变量 表示状态，那么</p><p>在回到上一层结点的时候不需要「回溯」；<br>在递归终止的时候也不需要做拷贝。<br>这样的做法虽然可以得到解，但也会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。为了验证上面的说明，我们写如下代码进行实验：<br>参考代码 3：</p><p>JavaPython</p><p>import java.util.ArrayList;<br>import java.util.List;</p><p>public class Solution {</p><pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;    // 首先是特判    int len = nums.length;    // 使用一个动态数组保存所有可能的全排列    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if (len == 0) &#123;        return res;    &#125;    boolean[] used = new boolean[len];    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    dfs(nums, len, 0, path, used, res);    return res;&#125;private void dfs(int[] nums, int len, int depth,                 List&lt;Integer&gt; path, boolean[] used,                 List&lt;List&lt;Integer&gt;&gt; res) &#123;    if (depth == len) &#123;        // 3、不用拷贝，因为每一层传递下来的 path 变量都是新建的        res.add(path);        return;    &#125;    for (int i = 0; i &lt; len; i++) &#123;        if (!used[i]) &#123;            // 1、每一次尝试都创建新的变量表示当前的&quot;状态&quot;            List&lt;Integer&gt; newPath = new ArrayList&lt;&gt;(path);            newPath.add(nums[i]);            boolean[] newUsed = new boolean[len];            System.arraycopy(used, 0, newUsed, 0, len);            newUsed[i] = true;            dfs(nums, len, depth + 1, newPath, newUsed, res);            // 2、无需回溯        &#125;    &#125;&#125;</code></pre><p>}<br>这就好比我们在实验室里做「对比实验」，每一个步骤的尝试都要保证使用的材料是一样的。我们有两种办法：</p><p>每做完一种尝试，都把实验材料恢复成做上一个实验之前的样子，只有这样做出的对比才有意义；<br>每一次尝试都使用同样的新的材料做实验。<br>在生活中做实验对材料有破坏性，这个过程通常不可逆。而在计算机的世界里，「恢复现场」和「回到过去」是相对容易的。</p><p>在一些字符串的搜索问题中，有时不需要回溯的原因是这样的：字符串变量在拼接的过程中会产生新的对象（针对 Java 和 Python 语言，其它语言我并不清楚）。如果您使用 Python 语言，会知道有这样一种语法：[1, 2, 3] + [4] 也是创建了一个新的列表对象，我们已经在「参考代码 2」中展示这种写法。</p><p>为什么不是广度优先遍历<br>首先是正确性，只有遍历状态空间，才能得到所有符合条件的解，这一点 BFS 和 DFS 其实都可以；<br>在深度优先遍历的时候，不同状态之间的切换很容易 ，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 11 处，因此回退非常方便，这样全局才能使用一份状态变量完成搜索；<br>如果使用广度优先遍历，从浅层转到深层，状态的变化就很大，此时我们不得不在每一个状态都新建变量去保存它，从性能来说是不划算的；<br>如果使用广度优先遍历就得使用队列，然后编写结点类。队列中需要存储每一步的状态信息，需要存储的数据很大，真正能用到的很少 。<br>使用深度优先遍历，直接使用了系统栈，系统栈帮助我们保存了每一个结点的状态信息。我们不用编写结点类，不必手动编写栈完成深度优先遍历。<br>不回溯可不可以<br>可以。搜索问题的状态空间一般很大，如果每一个状态都去创建新的变量，时间复杂度是 O(N)O(N)。在候选数比较多的时候，在非叶子结点上创建新的状态变量的性能消耗就很严重。</p><p>就本题而言，只需要叶子结点的那个状态，在叶子结点执行拷贝，时间复杂度是 O(N)O(N)。路径变量在深度优先遍历的时候，结点之间的转换只需要 O(1)O(1)。</p><p>最后，由于回溯算法的时间复杂度很高，因此在遍历的时候，如果能够提前知道这一条分支不能搜索到满意的结果，就可以提前结束，这一步操作称为 剪枝。</p><p>剪枝<br>回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；<br>提示：剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。</p><p>由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。<br>总结<br>做题的时候，建议 先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p><p>在画图的过程中思考清楚：</p><p>分支如何产生；<br>题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？<br>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？<br>练习<br>下面提供一些我做过的「回溯」算法的问题，以便大家学习和理解「回溯」算法。</p><p>题型一：排列、组合、子集相关问题<br>提示：这部分练习可以帮助我们熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件， 为什么有的时候用 used 数组，有的时候设置搜索起点 begin 变量，理解状态变量设计的想法。</p><ol start="46"><li>全排列（中等）</li><li>全排列 II（中等）：思考为什么造成了重复，如何在搜索之前就判断这一支会产生重复；</li><li>组合总和（中等）</li><li>组合总和 II（中等）</li><li>组合（中等）</li><li>子集（中等）</li><li>子集 II（中等）：剪枝技巧同 47 题、39 题、40 题；</li><li>第 k 个排列（中等）：利用了剪枝的思想，减去了大量枝叶，直接来到需要的叶子结点；</li><li>复原 IP 地址（中等）<br>题型二：Flood Fill<br>提示：Flood 是「洪水」的意思，Flood Fill 直译是「泛洪填充」的意思，体现了洪水能够从一点开始，迅速填满当前位置附近的地势低的区域。类似的应用还有：PS 软件中的「点一下把这一片区域的颜色都替换掉」，扫雷游戏「点一下打开一大片没有雷的区域」。</li></ol><p>下面这几个问题，思想不难，但是初学的时候代码很不容易写对，并且也很难调试。我们的建议是多写几遍，忘记了就再写一次，参考规范的编写实现（设置 visited 数组，设置方向数组，抽取私有方法），把代码写对。</p><ol start="733"><li>图像渲染（Flood Fill，中等）</li><li>岛屿数量（中等）</li><li>被围绕的区域（中等）</li><li>单词搜索（中等）<br>说明：以上问题都不建议修改输入数据，设置 visited 数组是标准的做法。可能会遇到参数很多，是不是都可以写成成员变量的问题，面试中拿不准的记得问一下面试官</li></ol><p>题型三：字符串中的回溯问题<br>提示：字符串的问题的特殊之处在于，字符串的拼接生成新对象，因此在这一类问题上没有显示「回溯」的过程，但是如果使用 StringBuilder 拼接字符串就另当别论。<br>在这里把它们单独作为一个题型，是希望朋友们能够注意到这个非常细节的地方。</p><ol start="17"><li><p>电话号码的字母组合（中等），题解；</p></li><li><p>字母大小写全排列（中等）；</p></li><li><p>括号生成（中等） ：这道题广度优先遍历也很好写，可以通过这个问题理解一下为什么回溯算法都是深度优先遍历，并且都用递归来写。<br>题型四：游戏问题<br>回溯算法是早期简单的人工智能，有些教程把回溯叫做暴力搜索，但回溯没有那么暴力，回溯是有方向地搜索。「力扣」上有一些简单的游戏类问题，解决它们有一定的难度，大家可以尝试一下。</p></li><li><p>N 皇后（困难）：其实就是全排列问题，注意设计清楚状态变量，在遍历的时候需要记住一些信息，空间换时间；</p></li><li><p>解数独（困难）：思路同「N 皇后问题」；</p></li><li><p>祖玛游戏（困难）</p></li><li><p>扫雷游戏（困难）<br>（欢迎大家补充。）</p></li></ol><p>参考资料<br>liuyubobobo 老师在慕课网上开设的课程《玩转算法面试》代码仓库。<br>不好意思，这里给自己做一个宣传，我最近在「力扣」上推出了自己的 LeetBook：使用「力扣」学习算法与数据结构，主要面向 转行 、零基础 的朋友，讲解算法与数据结构的基础知识。（2020.08.23）</p><p>说明：</p><p>该 LeetBook 的前两章（ 时间复杂度、二分查找）是免费阅读的，后面的章节 需要付费 观看，中、高阶用户请谨慎购买；<br>可以在站内或者是我的其他社交账号向我咨询课程内容。不管是否购买课程，我都会尽量回答我所知道的问题（时间允许，能力范围之内）。感谢大家一直以来，一如既往对我的支持。有建议和意见也欢迎大家与我交流。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/10/18/dp/"/>
    <url>/2021/10/18/dp/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>动态规划，简称 dp，它的思想是通过状态方程把现有的问题转化成子问题，子问题再用同样的方法转化成子子问题，可能听起来像是递归，但是递归解决起来和带有递归性质的树，链表这一类的题目不同，它会做到很多重复的运算，无疑会导致算法效率低下，所以动态规划的一个重要的思想就是用空间换时间。我们把状态转移方程右边需要的状态提前计算出来，另外开辟空间来存储查询，就避免了重复计算的问题；</p><h2 id="适用题型"><a href="#适用题型" class="headerlink" title="适用题型"></a>适用题型</h2><p>dp适用于求解如最多，最少，最大，多少种，能不能……之类的问题，一般是可以对子问题的状态进行存储的。</p><h2 id="一般步骤（不是流程-）"><a href="#一般步骤（不是流程-）" class="headerlink" title="一般步骤（不是流程 ）"></a>一般步骤（不是流程 ）</h2><ul><li>确定状态：需要开辟额外的空间（数组）来存储子问题的状态，因此首先要确定每个数组元素的意义（最有子问题）。</li><li>确定状态转移方程</li><li>初始条件，边界情况（问题规模）</li><li>确定计算顺序</li></ul><h2 id="剑指offer2-103-最少的硬币数"><a href="#剑指offer2-103-最少的硬币数" class="headerlink" title="剑指offer2 103 最少的硬币数"></a>剑指offer2 103 最少的硬币数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>       <span class="hljs-comment">//amount is the  value of all selected coins</span><br>        <span class="hljs-comment">//define a zone for storing the status</span><br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br><br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//record every status </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++)&#123;<br>            f[i] = Integer.MAX_VALUE;<br>            <span class="hljs-comment">//f[x] = min&#123;f[x - coins[1]], f[x - coins[2] .....] &#125; + 1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =<span class="hljs-number">0</span>; j &lt; coins.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i - coins[j] &gt;= <span class="hljs-number">0</span> &amp;&amp;  f[i - coins[j] ] != Integer.MAX_VALUE)&#123;<br>                    f[i] = Math.min(f[i], f[i - coins[j]] + <span class="hljs-number">1</span> ) ;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> f[amount] == Integer.MAX_VALUE? -<span class="hljs-number">1</span> : f[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-62-不同路径"><a href="#LeetCode-62-不同路径" class="headerlink" title="LeetCode 62 不同路径"></a>LeetCode 62 不同路径</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//initialize a space to store the status of every subproblem</span><br>        <span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>        <span class="hljs-comment">//initialize the status</span><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j== <span class="hljs-number">0</span>)&#123;<br>                    f[i][j] = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span><br>                    f[i][j] = f[i-<span class="hljs-number">1</span>][j] + f[i][j-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>        <br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\lunfee\Desktop\snipaste_20211019_200701.jpg" alt="snipaste_20211019_200701"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2021/10/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/10/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>java线程与操作系统的本地线程一一对应，Java线程开启本地线程就会创建，Java线程结束，本地线程就被回收</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>计算机操作系统的可执行文件是由一行行代码或指令组成，这些静态的指令与数据文件在计算机中叫一个程序。</p><p>想要运行一个<strong>程序</strong>就必须要把这些指令集加载到机器的CPU中，同时将数据加载到内存，运行起来的程序叫做<strong>进程</strong>，进程是用来加载指令，管理IO，管理内存的。同一个程序如果允许多次执行，就形成了多个进程。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可以包括多个线程（Windows进程就是一个线程容器）</p><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行</p><h3 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h3><p>在Java中，线程是最小的<strong>调度</strong>单位，进程是资源分配的最小单位。</p><p>进程是相互独立的，而线程存在于进程内，是进程的一个子集</p><p>进程内存在共享资源，供内部线程共享使用</p><p>多线程：一个进程内同时并行执行多个线程，每个线程各自有一套虚拟机栈和程序计数器。</p><p>多线程的优势：</p><ol><li><p>用户使用图形化界面完成不同任务的必须。</p></li><li><p>可以提高CPU利用率（尽管对于单核会降低速度）</p></li><li><p>复杂的进程分为多线程，单独启动易于管理，优化结构。</p></li></ol><p>何时使用多线程：</p><ol><li><p>程序需要同时执行两个或多个任务</p></li><li><p>程序需要实现一些需要等待的任务，比如网络加载，输入，读写文件等 </p></li></ol><p>后台执行任务。</p><p>进程间的通信：同一台计算机之间进程的通讯成为IPC(Inter-Process Communication)</p><p>​                         不同计算机之间的进程通讯，需要走网络并遵守协议</p><p>线程间的通讯：线程共享方法区和堆，可以实现进程间高效通信。</p><p>上下文切换：</p><ol><li>线程间的上下文切换主要是对指令的临时存储，开销较小</li><li>进程间的上下文切换涉及到资源的临时存储，开销较大</li></ol><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>并发(Concurent)的概念是建立在单个处理器上，在逻辑（时间）上好像多个线程在同步运行，实际上是在不同线程间不停切换。处理器核心为不同线程分发时间片，CPU在不同的线程见轮询（Windows下最短时间片为15ms)</p><p>并行是物理意义上的同步运行，基于多个处理器（核心），单核处理器无法实现并行。</p><p>计算机的任务处理是并行域并发同时发生的，因为大多数情况下，计算机需要处理的线程数要大于计算机的总处理器核数。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>任务执行的同步与异步：</p><ol><li>需要等待结果返回才能继续运行就是同步</li><li>不要等待结果返回就能继续运行就是同步</li></ol><p>Java多线程的同步：让多个线程步调一致</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li>在单核CPU下，多线程并不能提高实际的效率，只是为了在不同的任务之间转换，不同线程轮流使用CPU，避免单线程工作，其他线程等待。</li><li>对于多核CPU而言，处理任务是否可以拆分，是否需要拆分都需要根据实际情况确定。</li><li>IO操作是不占用CPU的，但是如果使用<strong>阻塞IO</strong>，相当于线程虽然不用CPU，但是需要一直等待IO操作结束，没有充分的利用线程，所以才有后面的<strong>非阻塞IO</strong>和<strong>异步IO</strong>（NIO）.</li></ol><h2 id="JAVA线程基础"><a href="#JAVA线程基础" class="headerlink" title="JAVA线程基础"></a>JAVA线程基础</h2><h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><h4 id="方法1：使用Thread（继承Threada类，重写run-方法）"><a href="#方法1：使用Thread（继承Threada类，重写run-方法）" class="headerlink" title="方法1：使用Thread（继承Threada类，重写run()方法）"></a>方法1：使用Thread（继承Threada类，重写run()方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建线程对象</span><br><span class="hljs-comment">//使用匿名内部类的方式创建Thread，因为只用一次，直接在new的时候覆盖run()方法。</span><br>Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        log.debug(<span class="hljs-string">&quot;thread1 run&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//交给任务调度器调度分配时间片，由CPU执行。</span><br>t1.start();<br></code></pre></td></tr></table></figure><h4 id="方法2；使用Runnable配合Thread"><a href="#方法2；使用Runnable配合Thread" class="headerlink" title="方法2；使用Runnable配合Thread"></a>方法2；使用Runnable配合Thread</h4><ol><li>把线程和任务分离</li><li>Tread表示线程，Runnable表示可运行的任务，线程要执行的代码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable task = <span class="hljs-keyword">new</span> Runnable()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        log.debug(<span class="hljs-string">&quot;task run&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//也可以交给线程池处理</span><br>Thread t2 = Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><h5 id="新知识"><a href="#新知识" class="headerlink" title="新知识"></a>新知识</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Runnable接口源码</span><br><span class="hljs-meta">@FunctionlInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>@FunctionalInterface注解使用在仅有一个抽象方法的接口上，在Java8 以上的版本中可以使用lambda表达式简写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable task = () -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;task run&quot;</span>);<br>&#125;<br><span class="hljs-comment">//也可以交给线程池处理</span><br>Thread t2 = Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure><h4 id="方法3：FutureTssk配合Thread（）"><a href="#方法3：FutureTssk配合Thread（）" class="headerlink" title="方法3：FutureTssk配合Thread（）"></a>方法3：FutureTssk配合Thread（）</h4><p>从Runnable接口源码可以看出，Runnable接口的run()方法没有返回值，无法进行线程间数据的传输共享。</p><p><img src="https://i.loli.net/2021/10/17/5kzyDTlpFstjhu6.png" alt="image-20211017171615846"></p><p>FutureTask类可以返回线程的执行结果，它的继承关系如图：</p><p><img src="https://i.loli.net/2021/10/17/ZH2raKA4k6JvITS.png" alt="image-20211017172252995"></p><p>继承的Future接口中有get()方法，能实现返回，除此之外，FutureTask需要搭配Callable接口（有返回值）：</p><p><img src="https://i.loli.net/2021/10/17/kqhrBep91x4o85i.png" alt="image-20211017172157201"></p><p>一个代码示例（之前在尚硅谷记的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableThtread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//3.create the instance of call class</span><br>        NumberThresd numberThresd = <span class="hljs-keyword">new</span> NumberThresd();<br>        <span class="hljs-comment">//4.use the futuretask tool</span><br>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(numberThresd);<br>        <span class="hljs-comment">//5.create new thread</span><br>        <span class="hljs-keyword">new</span> Thread(futureTask).start();<br>        <span class="hljs-comment">//6.call get method if you need the return value of call</span><br>        Object o = futureTask.get();<br>        System.out.println(o);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//1.create a class implements Callable interface and Override call method</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThresd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//2.return Object, Integer is the subclass of Object, int sum is turned into Integer automatically</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                sum += i;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于为什么使用Future命名，从官方对Future的解释可以看出，get()方法可能需要阻塞等待执行结果(未来的结果)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready.<br></code></pre></td></tr></table></figure><h3 id="线程和进程的查看"><a href="#线程和进程的查看" class="headerlink" title="线程和进程的查看"></a>线程和进程的查看</h3><p>在Windows下提供了查看所有进程与线程的cmd命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tasklist   //显示所有任务<br>taskkill   //通过pid杀死某个进程<br>tasklist | findstr java    //通过管道方法搜索带有java字段的任务<br></code></pre></td></tr></table></figure><p>Linus下对线程的查看操作更为丰富</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -fe | grep java    //管道筛选所有Java字段的进程<br>kill pid              //杀死进程<br>top//动态采集进程运行情况，包括CPU占用和MER占用<br>top -H -p pid //显示进程中所有线程的信息(-H 表示查看线程)<br></code></pre></td></tr></table></figure><p>JDK也提供了一套可以用来专门查看Java线程的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jps       //查看所有java进程<br></code></pre></td></tr></table></figure><h3 id="线程的运行底层原理"><a href="#线程的运行底层原理" class="headerlink" title="线程的运行底层原理"></a>线程的运行底层原理</h3><p>Java Virtual Machine Stacks(Java 虚拟机栈)</p><p><img src="https://i.loli.net/2021/10/17/OjnMUfIxRTkZlLc.png" alt="image-20211017200109319"></p><p>JVM是由堆，栈，方法区组成，其中栈时线程私有的，每个线程启动，虚拟机都会为其分配一块栈内存，</p><p>每个栈由多个栈帧(Frame)组成，对应这每次方法调用时所占用的内存。</p><p>每个线程只有一个活动的栈帧，对应着当前正在执行的那个方法。</p><p>单个线程的运行时栈内存和栈帧内存的使用情况：</p><p><img src="https://i.loli.net/2021/10/17/5HFDiwARtGZXpNB.png" alt="image-20211017194407325"></p><p>多个线程的情况下，各个线程之间有各自的占内存，栈帧是相互独立的.</p><p><img src="https://i.loli.net/2021/10/22/TRUks3jOmY12VKv.png" alt="image-20211022110139621"></p><p><a href="https://stackoverflow.com/questions/14763079/what-are-the-xms-and-xmx-parameters-when-starting-jvm">https://stackoverflow.com/questions/14763079/what-are-the-xms-and-xmx-parameters-when-starting-jvm</a></p><p>The flag <code>Xmx</code> specifies the maximum memory allocation pool for a Java Virtual Machine (JVM), while <code>Xms</code> specifies the initial memory allocation pool.</p><p>This means that your JVM will be started with <code>Xms</code> amount of memory and will be able to use a maximum of <code>Xmx</code> amount of memory. For example, starting a JVM like below will start it with 256 MB of memory and will allow the process to use up to 2048 MB of memory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xms256m -Xmx2048m<br></code></pre></td></tr></table></figure><p>The memory flag can also be specified in different sizes, such as kilobytes, megabytes, and so on.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xmx1024k<br>-Xmx512m<br>-Xmx8g<br></code></pre></td></tr></table></figure><p>The <code>Xms</code> flag has no default value, and <code>Xmx</code> typically has a default value of 256 MB. A common use for these flags is when you encounter a <code>java.lang.OutOfMemoryError</code>.</p><p>When using these settings, keep in mind that these settings are for the JVM’s <em>heap</em>, and that the JVM can and will use more memory than just the size allocated to the heap. From <a href="http://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html">Oracle’s documentation</a>:</p><blockquote><p>Note that the JVM uses more memory than just the heap. For example Java methods, thread stacks and native handles are allocated in memory separate from the heap, as well as JVM internal data structures.</p></blockquote><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><p>上下文切换的具体情况：</p><p><img src="https://i.loli.net/2021/10/17/hYEj1pHd9OZxJyA.png" alt="image-20211017201009754"></p><h3 id="线程常用方法讲解"><a href="#线程常用方法讲解" class="headerlink" title="线程常用方法讲解"></a>线程常用方法讲解</h3><h4 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h4><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h4 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h4><p><strong>sleep</strong> (使线程阻塞)</p><ol><li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span><br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//休眠一分钟</span><br>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><p>yield （让出当前线程）</p><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能(机会)被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-regexp">//</span>设置为优先级最高<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h4><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用t1.join()，则是主线程等待t1线程结束</p><p>join() 方法可用于<strong>线程的同步</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>();<br><span class="hljs-comment">//等待thread线程执行结束</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>();<br><span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h4 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h4><p>当<strong>阻塞</strong>(sleep wait join…)的线程被打断，实际是阻塞状态被终止。</p><p>所以sleep()方法需要添加异常处理，被打断后会抛出异常并且立刻执行进入运行状态。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。</li><li>如果是打断因sleep wait join方法而被阻塞的线程，只是打断了当前的阻塞状态，会继续执行之后的代码，打断标记置为false</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>用于查看打断标记，返回值被boolean类型<br>t1.isInterrupted();<br></code></pre></td></tr></table></figure><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>) &#123;<br>        break;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="https://i.loli.net/2021/10/21/i3pkemhWc6UvSBr.png" alt="img"></a></p><p><strong>代码</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>Monitor monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Monitor</span>();<br>monitor.<span class="hljs-built_in">start</span>();<br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">3500</span>);<br>monitor.<span class="hljs-built_in">stop</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;</span><br><br>Thread monitor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>() &#123;<br>@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br><span class="hljs-comment">//开始不停的监控</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">//判断当前线程是否被打断了</span><br><span class="hljs-keyword">if</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">isInterrupted</span>()) &#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-comment">//终止线程执行</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//线程休眠</span><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>e.<span class="hljs-built_in">printStackTrace</span>();<br><span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">interrupt</span>();<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br>monitor.<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于停止监控器线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//打断线程</span><br>monitor.<span class="hljs-built_in">interrupt</span>();<br>&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h4 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h4><ul><li>stop方法 停止线程运行（可能造成共享资源锁无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）/resume（恢复线程）方法</li></ul><h4 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h4><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><p>所以守护线程就像一个其他线程的守护者，别人不结束我就一直干，别人结束了我就立刻放弃自己的所有任务（感人了）</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//将线程设置为守护线程, 默认为<span class="hljs-literal">false</span><br><span class="hljs-literal">monitor</span>.setDaemon(<span class="hljs-literal">true</span>);Copy<br></code></pre></td></tr></table></figure><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><h4 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h4><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="https://i.loli.net/2021/10/21/UhMp4cRNVS9GPmK.png" alt="img"></a></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h4 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h4><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><img src="https://i.loli.net/2021/10/22/yuk689JfSLjoZHQ.png" alt="image-20211022223937573"></p><ul><li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20211006</title>
    <link href="/2021/10/06/20211006/"/>
    <url>/2021/10/06/20211006/</url>
    
    <content type="html"><![CDATA[<p>我也不知道 Typora 发生了什么事情，本来是想来记个日记的，发现了一个 bug，就是写完 yaml 之后正文第一个字符必须是英文，不管那么多了，正文开始吧….</p><p>今天是国庆假期的倒数第二天了，虽然学校只放三天的假期，但是我四号赶来学校的时候实验室其实没什么人过来，说来是有点自私的，我也知道可以晚点来学校，多陪陪家人，奈何我的心里面想的工作学习的事情也怕被耽搁，其实差不多了，这几天过的还算充实。只是突然回来学校有点找不到原来的方向了，尽管在离校前，对我的当时任务做了个入栈操作，如图所示：</p><p><img src="https://i.loli.net/2021/10/06/owERgTnqdJcF7LB.png" alt="image-20211006171648690"></p><p>除了这些，我其实还需要搞机器人，以应付胡**的突然“关心”，说实话从读研到现在我的学术进展几乎为零，也没有头绪，没有心思确定未来我要做什么发小论文和毕业，到底是不是机器人啊，一年后我就有答案了啊哈哈，因为那个时候就是迫在眉睫了。现在我就安心的想我的工作吧，科研这条路不是每个人都适合，更不是每个人都有机遇。可能我遇到一个好的导师，我就……就可以读博了，别，感觉在这个学校或者说国内这个环境下（国外不知道），真的没那么多人喜欢科研，不过是混个学历罢了。我就勉为其难掩盖我的科研素养，好好利用这最后的学历光环搞钱吧。</p><p>可能对于我个人而言，生活的开心快乐真的比什么都重要，但是我也知道，快乐可以是纯粹的，也可以是物质的，我也知道，纯粹的快乐是最持久的，但是我仍然义无反顾的追求物质的快乐，直白点就是金钱。可能超脱物质的那种人真的存在，但那必不是我。从小长大的环境告诉我，没有金钱就没有自信，尽管这个事实被我的学历冲淡了那么一点点，但其实只是把金钱的价值转移到了具有强大购买了的高学历上了，我不否认这一点，因为这太正常不过了。</p><p>有钱可以让我对得起自己的亲情（良心），比如不会表达的我可以靠买一些生活用品啊，小礼物啊来慰藉自己的父母，奶奶，以及几个宝贝；比如可以毫不吝啬的买高铁票飞机票回家，而不用抉择这路途如此艰难究竟要不要回家；比如父母的体检费啊，以后难免可能有高昂的医药费啊，我想毫不犹豫的说，治，都少钱都给我治，但拿需要底气——来自于金钱。</p><p>我一点也不心虚的觉得我很爱我的家人，尤其心疼我的父母，有物质层面的有精神层面的甚至是知识层面上。物质上，他们挣钱真的太不容易了，尽管最近几年在花销上大了不少，但依旧是省吃俭用，工作也是普通劳动人民，尽管我也是如此，省吃俭用，未来的新型劳动人民，但这种心疼是油然而生的，这种心疼源自生为他们一点一点用心养大的儿子的我的生活质量要比他们高出很多上，源自工作的体面程度上，源自社会地位上，不过也还好有我，尽管算是在这残酷的世界上苟且偷生吧，让他们有一点骄傲和慰藉，这一点真的有在精神层面弥补到他们，我确定。关于精神层面的心疼和知识层面的下次再写吧。</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Object类</title>
    <link href="/2021/09/27/Object%E7%B1%BB/"/>
    <url>/2021/09/27/Object%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/2021/09/26/Netty%E7%9F%A5%E6%A0%B9%E7%9F%A5%E5%BA%95/"/>
    <url>/2021/09/26/Netty%E7%9F%A5%E6%A0%B9%E7%9F%A5%E5%BA%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Netty知根知底"><a href="#Netty知根知底" class="headerlink" title="Netty知根知底"></a>Netty知根知底</h1><h2 id="学前问题"><a href="#学前问题" class="headerlink" title="学前问题"></a>学前问题</h2><p>netty线程模型</p><p>NIO为什么这么快，是否高效，和IO的区别</p><p>NIO和BIO和IO</p><p>NIO原理</p><p>NIO究竟怎么实现非阻塞的</p><p>java里面哪些用到了NIO</p><p>TCP粘包拆包</p><p>Netty是网络编程基本框架，Java开发流行的Redis缓存的主从复制，分布式的RPC的底层通讯都使用Netty网络通讯。</p><h2 id="NIO是个什么玩意"><a href="#NIO是个什么玩意" class="headerlink" title="NIO是个什么玩意"></a>NIO是个什么玩意</h2><p>NIO(non-blocking-io，非阻塞io)</p><p><img src="https://i.loli.net/2021/09/27/Ld7zph2ajmvIwMF.png" alt="image-20210925163226750"></p><img src="https://i.loli.net/2021/09/27/7YfjtHqBmRCKgVo.png" alt="image-20210925163239860" style="zoom:200%;" /><p><img src="https://i.loli.net/2021/09/27/mwPBF2r46MYpZLg.png" alt="image-20210925163521053"></p><p><img src="https://i.loli.net/2021/09/27/dHwjf7kBD3XoMVc.png" alt="image-20210925163857831"></p><p>拆包粘包问题，</p>]]></content>
    
    
    
    <tags>
      
      <tag>nio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/25/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/25/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="关于计算机网络"><a href="#关于计算机网络" class="headerlink" title="关于计算机网络"></a>关于计算机网络</h1><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>IP地址用于确定主机</p><p>端口号用于区分主机上的不同应用。</p><p>TCP（Transmission Control Protocol, 传输控制协议）是基于数据流的协议，它是可靠的。</p><p>UDP是基于报文传输的协议，它不是可靠的但是高效，经常用于像视频聊天这种实时性高但可靠性要求不高的通信，即使再视频语音通话中，有少数的丢帧也不影响通话的整体效果。</p><p>Socket（插座）建立不同主机，不同应用间点对点的虚拟数据通道。</p><p>TCP和UDP是两种常用的socket。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment">#下面建立一个简单的socket连接</span><br><span class="hljs-comment">#第一个参数传入AF_INET代表使用ipv4地址家族，第二个参数SOCK_STREAM表示传输类型使用流传输，第三个参数为传输协议，缺省则使用第二个参数默认的，如SOCK_STREAM默认使用TCP协议传输，如果手动使用UDP会报错。</span><br><span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> s:<br><span class="hljs-comment">#ip绑定0.0.0.0表示如果服务器端有两个或以上的ip地址，那么两个都可以被识别；</span><br>    s.bind((<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">1234</span>))<br>    <span class="hljs-comment">#建立好ssocket后要对socket进行监听，s是专门负责监听连接的socket</span><br>    s.listen()<br>    <span class="hljs-comment">#当有客户端发来请求时，使用accept建立新的连接socket，用来处理消息的收发</span><br>    c, addr = s.accept()<br>    <span class="hljs-built_in">print</span>(addr, <span class="hljs-string">&quot;connected&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#消息接收与回传</span><br>        data = c.recv(<span class="hljs-number">1024</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">break</span><br>        c.sendall(data)<br></code></pre></td></tr></table></figure><p>在linux中进行测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash\">$nc 10.133.45.184 1234<br>hello<br>hello<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2021/09/24/Redis/"/>
    <url>/2021/09/24/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="需要知道"><a href="#需要知道" class="headerlink" title="需要知道"></a>需要知道</h2><p>Redis单条命令是保证原子性的，但是事务不保证原子性。</p><p>一次性，顺序性，排他性，没有隔离级别的概念，</p><p>Redis是单线程的：因为CPU处理速度不是Redis的瓶颈，Redis是基于内存操作的，它的瓶颈是机器的内存和网络带宽，单线程足够快了。</p><p>Redis为什么这么快？</p><p>Redis是将所有数据保存在内存中的，使用多线程的话CPU上下文切换也是很耗时的，使用单线程反而效率更高。</p><p>Redis可以用来做数据库，缓存和消息中间件MQ，</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>select 3                    选择第3号数据库</p><p>dbsize                        查看当前数据库大小</p><p>set key value            设置字段key的值为value</p><p>flushdb                        清空当前数据库</p><p>flushall                        清空所有数据库</p><p>keys *                            查看拥有的所有字段</p><p>exists                            是否含有某key</p><p>move key                        移除</p><p>expire key  10                  设置过期时间    </p><p>ttl key                        查看过期剩余时间</p><p>type key                    查看key类型</p><p>append key “value”            没有就set</p><p>strlen key</p><p>incr</p><p>decr</p><p>incrby</p><p>decrby</p><p>getrange key 0 3</p><p>getrange key 0 -1</p><p>setrange key 3 value</p><p>setex key 30 value</p><p>setnx key value</p><p>mset </p><p>mget</p><p>msetnx 原子性</p><p>getset</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>l(r)push list value</p><p>l(r)range list 0 1</p><p>l(r)index list 1</p><p>llen list</p><p>lrem list 3 value</p><p>ltrem list 1 2</p><p>rpoplpush list1 list2</p><p>exists list</p><p>lset list 0 value</p><p>linsert list </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>sadd set value</p><p>smembers set</p><p>sismember set value</p><p>scard set，所有元素个数</p><p>srem set value</p><p>srandmember set 2</p><p>spop 随机移除</p><p>smove set1 set2 value</p><p>sdiff set1 set2 </p><p>sinter set1 set2</p><p>sunion set1 set2</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>hset hashset field1 value1</p><p>hget hashset field</p><p> hmset</p><p> hgetall hashset</p><p>hdelete hashset filed1</p><p>  hsetnx hashset  </p><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>在set基础上加了个字段 xxx</p><p>zadd</p><p>zrenge xxx </p><p>zrevrenge xxx</p><p>zrangebyscore xxx </p><p>zcard xxx</p><p>zcount xxx</p><h3 id="geospatial（底层是zset）"><a href="#geospatial（底层是zset）" class="headerlink" title="geospatial（底层是zset）"></a>geospatial（底层是zset）</h3><p>geoadd</p><p>geopos</p><p>geodist</p><p>georadius </p><p>georadiusbymember</p><h3 id="hyperloglog-不精确"><a href="#hyperloglog-不精确" class="headerlink" title="hyperloglog(不精确)"></a>hyperloglog(不精确)</h3><p>面试题：网页的UV：同一个人访问网站多次，怎么确认是同一个人的登录。</p><p>1.set保存下用户id。</p><p>2.</p><p>pfadd</p><p>pfcount</p><p>pfmerge</p><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>setbit </p><p>getbit</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>开启事务 multi</p><p>命令入队</p><p>执行 exec</p><p>放弃 discard</p><p>编译型错误，不执行</p><p>运行时错误，仍然执行正确的部分</p><p>悲观锁：很谨慎，感觉怎么都会出问题，任何时候都加锁</p><p>乐观锁：感觉不会有任何问题，不上锁，但是如果操作数据有变化，会被告知执行失败</p><p>watch，实现乐观锁，如果执行失败，unwatch解锁，再重新监视最新的值，watch</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>maven 导入Jedis依赖</p><p>new Jedis(“127.0.0.1”, “6379”)对象</p><p>其余操作和redis命令行一样。</p><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><p>初始化勾选Nosql的redis</p><p>把jedis换成了lettuce. 封装在redisTemplate中，</p><p>jedis是线程不安全的，想要变得安全要使用jedis pool，更像BIO模式</p><p>lettuce采用的是netty，实例可以在多个栈中进行分享，不存在县城不安全的情况，可以减少线程数据了，更像NIO模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>RedisTemplate redisTamplate;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function">viod <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    redisTemplate.opsForList().list的方法<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关于对象的序列化"><a href="#关于对象的序列化" class="headerlink" title="关于对象的序列化"></a>关于对象的序列化</h4><p>要么转化成json，要么就是类实现序列化（JDK 序列化implements Serializable），或者（推荐）直接在配置类中配置序列化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">templete.setKeySerialzer(<span class="hljs-keyword">new</span> xxxSerializer())<br></code></pre></td></tr></table></figure><h4 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h4><p>一般公司都会自己写一个根据自己业务的特点搞一个自己的工具类</p><h2 id="Redis-值钱的东西"><a href="#Redis-值钱的东西" class="headerlink" title="Redis 值钱的东西"></a>Redis 值钱的东西</h2><p>上面讲的都是使用Redis的基本操作</p><h3 id="Redis-config"><a href="#Redis-config" class="headerlink" title="Redis.config"></a>Redis.config</h3><p>配置文件对大小写不敏感。</p><p>包含，可以用 import 进行引用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">绑定端口</span><br>bind ipaddress<br><span class="hljs-meta">#</span><span class="bash">开启保护模式</span><br>protected-mode yes<br><span class="hljs-meta">#</span><span class="bash">设置端口</span><br>port xxxx<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">以守护进程的方式运行（后台运行）</span><br>deamonize yes<br><span class="hljs-meta">#</span><span class="bash">如果以后台方式运行，我们需要指定pid进程文件</span><br>profile /var/run/redis_6379.pid<br><span class="hljs-meta">#</span><span class="bash">日志，有多种日志级别</span><br>loglevel notice  #生产环境使用<br><span class="hljs-meta">#</span><span class="bash">日志的文件名</span><br>logfile &quot;&quot;  #空的话代表不保存直接输出<br><span class="hljs-meta">#</span><span class="bash">数据库数量</span><br>database 16<br><br><br>快照<br><span class="hljs-meta">#</span><span class="bash">持久化(防止内存数据库断电失去),在规定的时间内，执行了多少次操作会持久化到文件</span><br><span class="hljs-meta">#</span><span class="bash">900秒内，如果至少有一个key进行了修改，就要进行持久化</span><br>save 900 1<br>save 300 10<br>save 60 10000<br><span class="hljs-meta">#</span><span class="bash">持久化出错是否继续工作</span><br>stop-write-bgsave-error yes<br><span class="hljs-meta">#</span><span class="bash">是否压缩rdb文件（持久化文件），会占用CPU资源</span><br>rdbcompression yes<br><span class="hljs-meta">#</span><span class="bash">是否校验rdb文件（）</span><br>rdbchecksum yes<br><span class="hljs-meta">#</span><span class="bash">rdb文件保存目录</span><br>dir ./<br><br>RDB（下文单讲）<br><br>安全<br>requirepass xxx<br><span class="hljs-meta">#</span><span class="bash">或者在命令行config <span class="hljs-built_in">set</span> requirepass xxxx</span><br><span class="hljs-meta">#</span><span class="bash">认证</span><br>auth &quot;xxxx&quot;<br><br><br>客户端<br><span class="hljs-meta">#</span><span class="bash">了解一下</span><br>maxclients 1000<br>maxmemory &lt;bytes&gt;<br><span class="hljs-meta">#</span><span class="bash">内存满了使用什么策略处理</span><br>maxmemory-policy noeviction<br><br><br>APPEND ONLY模式 aof（持久化方式2） 配置<br>appendonly no #默认使用rdb方式持久化，大多数情况下rdf够用。<br>appendfilename &quot;appendonly.aof&quot;#持久化的文件名<br><span class="hljs-meta">#</span><span class="bash">每秒执行一次同步（可能丢失这个时候的数据）可以设置为no,always</span><br>appendfsync everysec<br></code></pre></td></tr></table></figure><h3 id="持久化RDB"><a href="#持久化RDB" class="headerlink" title="持久化RDB"></a>持久化RDB</h3><p>RDB就是Redis Database；保存的文件叫dump.rdb。</p><p>可以自定义一个save</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">save 60 5<br></code></pre></td></tr></table></figure><ol><li><p>save设置的规则满足的情况下，会自动触发rdb规则。</p></li><li><p>执行flushall也会触发rdb规则</p></li><li><p>退出redis也会产生。</p></li></ol><p>如何回复？</p><ol><li><p>把文件放在redis的启动位置就好了，redis启动会自动检查dump.rdb文件并恢复数据。</p></li><li><p>config get dir  #自动扫描/usr/local/bin下存在的dump.rdb</p></li></ol><p>rdb的优缺点：</p><ol><li>优点：<ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高的时候使用</li></ol></li><li>缺点<ol><li>需要一定的时间间隔进程操作！如果redis意外宕机，最后一次修改的数据就没有了</li><li>fork进程的时候，会赵勇一定的内存空间！！</li></ol></li></ol><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>记录所有写操作，默认关闭</p><p>append only file</p><p>appendfsync everysec  #每秒同步</p><p>如果恶意破坏aof文件则没法恢复，使用下面的语句修复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-check-aof --fix appendonly.aof<br></code></pre></td></tr></table></figure><p>aof的优缺点：(?????????????????????)</p><ol><li>优点：<ol><li>每一次修改都同步（always），文件的完整性更好</li><li></li></ol></li><li>缺点<ol><li></li><li></li></ol></li></ol><h3 id="消息发布与订阅（还是交给专门的中间件来做吧）"><a href="#消息发布与订阅（还是交给专门的中间件来做吧）" class="headerlink" title="消息发布与订阅（还是交给专门的中间件来做吧）"></a>消息发布与订阅（还是交给专门的中间件来做吧）</h3><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>redis一般是集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">info replication<span class="hljs-comment">#查看当前库的主从信息</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis与JDBC</title>
    <link href="/2021/09/23/Mybatis%E4%B8%8EJDBC/"/>
    <url>/2021/09/23/Mybatis%E4%B8%8EJDBC/</url>
    
    <content type="html"><![CDATA[<h2 id="Mybatis与JDBC"><a href="#Mybatis与JDBC" class="headerlink" title="Mybatis与JDBC"></a>Mybatis与JDBC</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC，Java Database Connectivity，舰名思意，Java数据库连接，一般操作的步骤如下：</p><p>1，根据四要素（Driver-Class，url，username，password）获得连接，</p><p>2，编写sql语句，</p><p>3，获取preparedStatement，预编译sql语句，</p><p>4，获取并处理结果集</p><p>5，关闭资源</p><p>使用第三方数据库连接池时需要配置dataSource。</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>Mybatis算是一个ORM框架，说到底内部也是封装了JDBC的，但是简化了很多操作，它的操作步骤：</p><p>1，sqlSessionFactory获取一个sqlSession,（session.getMapper）</p><p>2，编写@Mapper的mapper接口（DAO）</p><p>3，编写xml映射文件（包括sql语句，返回封装的Bean）          —————-与数据库交互</p><p>4，编写@Service的service业务逻辑代码</p><h3 id="JDBC与Mybatis比有哪些局限性呢"><a href="#JDBC与Mybatis比有哪些局限性呢" class="headerlink" title="JDBC与Mybatis比有哪些局限性呢"></a>JDBC与Mybatis比有哪些局限性呢</h3><p>1.数据库连接池（减少数据库关闭开启时数据库的资源浪费）：</p><p>2.SQL配置文件（减少硬编码）：原生JDBC直接在java中写sql语句，及其不好维护。</p><p>3.动态SQL语句（只专注写sql，各干各的事，专一）</p><p>4.映射（resultset直接转为java对象）：不用再操作底层的ResultSet。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/2021/09/20/SpringMVC/"/>
    <url>/2021/09/20/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC原理"><a href="#SpringMVC原理" class="headerlink" title="SpringMVC原理"></a>SpringMVC原理</h1><h2 id="SpringMVC架构："><a href="#SpringMVC架构：" class="headerlink" title="SpringMVC架构："></a>SpringMVC架构：</h2><p>所有的WEB MVC框架都是这么设计的：一个中央Servlet程序，用于把请求分发到相应的控制器，实现业务逻辑与跳转。由于SpringMVC整合了Spring IoC容器，所以它具有Spring的所有功能。Spring的Servlet的实现类是DispatcherServlet，具有更强大的功能。</p><h3 id="DispatcherServlet："><a href="#DispatcherServlet：" class="headerlink" title="DispatcherServlet："></a>DispatcherServlet：</h3><img src="C:\Users\lunfee\AppData\Roaming\Typora\typora-user-images\image-20210908095953054.png" alt="image-20210908095953054" style="zoom: 80%;" /><h3 id="浏览器访问流程："><a href="#浏览器访问流程：" class="headerlink" title="浏览器访问流程："></a>浏览器访问流程：</h3><p>用户向服务器发送HTTP请求，DispatcherServlet根据请求的信息通过Mapping寻找到处理请求的处理器，并返回到DispatcherServlet；HandlerAdapter再根据请求参数适配到指定的方法处理service业务，结果以mv的形式回传；View对mv进行渲染返回给客户。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot-Mybatis</title>
    <link href="/2021/09/19/Springboot%20Mybaits%20%E6%95%B4%E5%90%88%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/09/19/Springboot%20Mybaits%20%E6%95%B4%E5%90%88%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot-Mybaits-整合记录"><a href="#Springboot-Mybaits-整合记录" class="headerlink" title="Springboot Mybaits 整合记录"></a>Springboot Mybaits 整合记录</h1><p>新建项目，添加组件</p><p>导入maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入mybatis--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置数据源信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/lou_springboot?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.alibaba.druid.proxy.DruidDriver</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">lunfee</span><br></code></pre></td></tr></table></figure><p>配置服务器访问端口</p><p>配置要么写在配置文件中，要么就写配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yam">server:<br>  port: 80<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot</title>
    <link href="/2021/09/19/Springboot%20%E4%B8%AD,%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/09/19/Springboot%20%E4%B8%AD,%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Springboot-中-和-的区别"><a href="#Springboot-中-和-的区别" class="headerlink" title="Springboot 中/**,/和/*的区别"></a>Springboot 中/**,/和/*的区别</h2><p>Springboot 中经常使用拦截器，过滤器处理掉一部分请求操作，在设置拦截域的时候使用/**,/和/*拦截的效果是不同的</p><p>/**：拦截所有文件，包括文件夹下的子文件夹，包括静态资源，因此在拦截的时候需要放行如.css文件等的静态资源</p><p>/*：拦截该文件夹下所有的文件路径，不包含子文件夹，包涵页面。</p><p>/：拦截该文件夹下的所有文件路径，不包含页面</p>]]></content>
    
    
    
    <tags>
      
      <tag>/*</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好康的</title>
    <link href="/2021/09/16/%E5%A5%BD%E5%BA%B7%E7%9A%84/"/>
    <url>/2021/09/16/%E5%A5%BD%E5%BA%B7%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="好康的"><a href="#好康的" class="headerlink" title="好康的"></a>好康的</h1><h2 id="关于-和-equals-的区别"><a href="#关于-和-equals-的区别" class="headerlink" title="关于==和.equals()的区别"></a>关于==和.equals()的区别</h2><p>其实很多人对于这个问题的答案可能就是一句简单的：双=号比较的是在堆内存中的地址值，equals()方法比较的是内容值。但是面试官要听的可不是这句话，或者他一定会问更深，更底层的问题，这里面牵扯了很多底层的计算机或者Java虚拟机的内容，下面先浅显的做一个梳理，后面有机会的话再修改补充。</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>内存作为一个存储数据的存在， 有一个很重要的特性， 就是内存里的数据能被cpu直接访问（或者说被CPU的高速缓存区直接访问），所以内存才是计算机系统的主存储器， 而硬盘是外部存储器。</p><p>我们把内存分成了以字节为单位的结构， 但是实际上内存里还是有非常多的字节的，例如64MB内存就有 64 × 1024 × 1024 个字节，如果cpu要查找1个变量， 还是要1个个字节去找到话，时一个很浪费时间的行为，所以为了避免去遍历内存，计算机系统就引入了内存地址这个概念。在32位操作系统中，<strong>内存的地址就是32位的2进制数</strong>， 所以32位的地址范围就是从 0000 0000 0000 0000 0000 0000 0000 0000 到 1111 1111 1111 1111 1111 1111 1111 1111 （ox00000000 - oxFFFFFFFF)， 共2^32个内存地址，也就是 4GB，所以如果你给32位的系统配上了8GB的内存， 操作系统最多也只能给其中4GB 分配地址， 其余 4GB 是没有地址， 因为地址不够用啊， 所以32位系统最多支持4GB内存就是这样来的。 </p><p>说了这么多就是想讲在32位系统和64位系统中，指针的大小实际上是不一样的，因为指针时存放内存地址的，这么讲是针对C语言而言的，JAVA是不能直接操作计算机内存空间的。</p><h3 id="JVM的变量存储"><a href="#JVM的变量存储" class="headerlink" title="JVM的变量存储"></a>JVM的变量存储</h3><p>首先，我们先大概知道一下JVM的内存模型和Java的四类八种基本数据类型。</p><p>需要指出的是，java 在不同位的机器上执行时，</p><p><img src="https://i.loli.net/2021/09/27/hvOpPICSVGeJyRl.png" alt="image-20210923120220226"></p><p>在JVM内存模型中，方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就是局部变量只能在方法中有效的原因。</p><p>方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。</p><p>（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）都是放在方法栈中</p><p>（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p><p>类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</p><p>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量</p><p>​    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的</p><p>​    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中。</p><h3 id="和-equals"><a href="#和-equals" class="headerlink" title="==和.equals()"></a>==和.equals()</h3><p>基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。</p><p>引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是<strong>堆内存</strong>地址）。</p><p>对于引用数据类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。<strong>因为每new一次，都会重新开辟堆内存空间</strong>。</p><p>JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    <span class="hljs-comment">//this - s1    //obj - s2    </span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。 </p><p>所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。我们对上面的两段内容做个总结吧： <strong>== 的作用：</strong></p><p>　　基本类型：比较的就是值是否相同</p><p>　　引用类型：比较的就是地址值是否相同</p><p>String类的equals()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>              String anotherString = (String)anObject;<br>              <span class="hljs-keyword">int</span> n = value.length;<br>              <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>                  <span class="hljs-keyword">char</span> v1[] = value;<br>                 <span class="hljs-keyword">char</span> v2[] = anotherString.value;<br>                 <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>                 <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                     <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                     i++;<br>                 &#125;<br>                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>     &#125;<br></code></pre></td></tr></table></figure><p>所以很明显比较的是两个String的值是否相同。说到这里感觉已经把==和.equals()的区别讲差不多了。</p><p>参考：<a href="https://www.zhihu.com/search?q===%E5%92%8Cequals&amp;utm_content=search_history&amp;type=content">https://www.zhihu.com/search?q=%3D%3D%E5%92%8Cequals&amp;utm_content=search_history&amp;type=content</a></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/27626724">https://zhuanlan.zhihu.com/p/27626724</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>equals</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈</title>
    <link href="/2021/09/14/%E6%9D%82%E8%B0%88/"/>
    <url>/2021/09/14/%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h1><h2 id="关于Spring“自动”这件事"><a href="#关于Spring“自动”这件事" class="headerlink" title="关于Spring“自动”这件事"></a>关于Spring“自动”这件事</h2><p>下面说的三种时期亦或是三种方式，知识入口不同而已，容器底层启动的过程是一样的，方式有早期和主流之分，但在开发中多是灵活搭配的，例如早期的代码融入新技术实现的代码（Import）。</p><h3 id="1-XML配置时期"><a href="#1-XML配置时期" class="headerlink" title="1.XML配置时期"></a>1.XML配置时期</h3><p>最开始使用Spring的时候，也是早期主流的使用方式，我们需要在beans.xml中创建<bean>标签，并在子标签中对相应属性进行赋值，常用的方式有：</p><p>传值三种方式：按参数索引，按参数类型，按参数名</p><p>1.构造器注入（bean类中有相应的构造器）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentConstruct2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;domain.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.set注入（bean类中有相应的set方法）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;domain.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;11&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;22&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以该文件为参数传入ClassPathXmlApplicationContext会得到一个applicationContext的上下文容器对象。</p><p>从容器中获取bean并强转到原类型就能从容器中拿到该已赋值的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取applicationContext</span><br>ClassPathXmlApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br><span class="hljs-comment">//传入beanId, 获取bean</span><br>Student studentNoValue = (Student) applicationContext.getBean(<span class="hljs-string">&quot;student&quot;</span>);<br></code></pre></td></tr></table></figure><p>这种方式摆脱了奴役我们很久的new对象的方式，尽管这种方式看起来很麻烦，（重要的是思想，等我复习了再补充）</p><h3 id="2-Autowired-Bean时期"><a href="#2-Autowired-Bean时期" class="headerlink" title="2.@Autowired@Bean时期"></a>2.@Autowired@Bean时期</h3><p>在spring的一个叫做核心配置文件的东西中配置自动扫描哪些包下面的bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">#配置自动扫描包路径<br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.lunfee.beans&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>于此同时</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br></code></pre></td></tr></table></figure><h3 id="3-Java-Config时期（SpringBoot）"><a href="#3-Java-Config时期（SpringBoot）" class="headerlink" title="3.Java Config时期（SpringBoot）"></a>3.Java Config时期（SpringBoot）</h3>]]></content>
    
    
    
    <tags>
      
      <tag>关于Spring的一些理解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thymeleaf</title>
    <link href="/2021/09/11/Thymeleaf/"/>
    <url>/2021/09/11/Thymeleaf/</url>
    
    <content type="html"><![CDATA[<p>Thymeleaf </p><p>Thymeleaf 自动配置里面添加了默认的前后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">&quot;classpath:/templates/&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">&quot;.html&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">th:action=&quot;@&#123;/index&#125;      使用模板引擎定向controller<br>th:text=&quot;$&#123;&#125;&quot;             向model中取值//也可以像request中取值，一次request对应一个model//zh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Session,Cookie,Request</title>
    <link href="/2021/09/11/session,cookie,request%E5%9F%9F/"/>
    <url>/2021/09/11/session,cookie,request%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="session-cookie-request域"><a href="#session-cookie-request域" class="headerlink" title="session,cookie,request域"></a>session,cookie,request域</h2><p>他们的作用都是保存页面的信息，</p><h3 id="sessi0n"><a href="#sessi0n" class="headerlink" title="sessi0n"></a>sessi0n</h3><p>用于存放不同页面的公共信息，比如登录信息，比如在商品页面添加到心愿单的商品，在跳转到购物车页面的时候任然可以获取到；</p><p>作用域：session 的作用域是一个会话</p><p>原理：用户发送一个请求访问到 Servlet，在服务器上找一块内存，实际上是一个键值对，前面是 String name，后面是Object value，每一个客户端都有一个session，每个客户端之间，当服务器为客户端下发一个临时的cookie（浏览器的内存中），名字叫JSESSIONID，是一组字母加数字的序列，表示访问服务器session内存的“凭证”，客户端通过JSESSIONID这个凭证访问自己对应的服务器存储session的内存。</p><p>失效：  1、客户端关闭浏览器程序，造成了JSESSIONID凭证丢失<br>                    2、时效性，session超时（会话超时）：a、客户端关闭后，一段时间内没有访问过该session内存，服务器会清理。b、或者一段时间内没有访问过该session内存，服务器会清理。c、会话超时的时间，默认是30分钟，只要发起请求，会话时间从0重新计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//页面1</span><br>session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;苹果&quot;</span>);<br><span class="hljs-comment">//页面2</span><br>session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>在 Springboot 中，只用在配置文件中配置就可以实现改变 session 的生命周期。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pro">server.servlet.session.timeout=60  #单位分钟<br></code></pre></td></tr></table></figure><h3 id="requset"><a href="#requset" class="headerlink" title="requset"></a>requset</h3><p>常用于服务器间同一请求不同页面之间的参数传递，常应用于表单的控件值传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">request.setAttribute(); <br>request.getAttribute();<br>request.removeAttribute();<br>request.getParameter().<br></code></pre></td></tr></table></figure><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><p>model仅在一次request中有效，所以也存放临时值</p>]]></content>
    
    
    
    <tags>
      
      <tag>域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于请求转发</title>
    <link href="/2021/09/11/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/"/>
    <url>/2021/09/11/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="请求转发，刷新页面"><a href="#请求转发，刷新页面" class="headerlink" title="请求转发，刷新页面"></a>请求转发，刷新页面</h2><p>在页面的跳转中，如果使用return”页面名”，默认走的是请求转发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&#123;&quot;/login&quot;,&quot;/&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLoginPage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@PostMapping(&quot;/index&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndexPage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--login表单提交走post请求，跳转到/index 控制器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-signin&quot;</span>  <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/index&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这种情况下，刷新页面会重新提交表单，要避免这种情况要使用重定向方法。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
