

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="由单例模式深入 Java 锁单例模式下面的代码是一段经典的饿汉式的单例模式写法 1234567891011121314151617181920package javal;&#x2F;** * @author lunfee * @create 2022&#x2F;3&#x2F;6-14:53 *&#x2F;&#x2F;&#x2F;懒汉式单例模式public class Singleton &amp;#123;    private static volatile S">
<meta property="og:type" content="article">
<meta property="og:title" content="Lunfee&#39;s Blog">
<meta property="og:url" content="http://example.com/2022/03/06/re/java%E9%94%81/index.html">
<meta property="og:site_name" content="Lunfee&#39;s Blog">
<meta property="og:description" content="由单例模式深入 Java 锁单例模式下面的代码是一段经典的饿汉式的单例模式写法 1234567891011121314151617181920package javal;&#x2F;** * @author lunfee * @create 2022&#x2F;3&#x2F;6-14:53 *&#x2F;&#x2F;&#x2F;懒汉式单例模式public class Singleton &amp;#123;    private static volatile S">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-03-06T06:49:33.849Z">
<meta property="article:modified_time" content="2022-03-07T08:16:12.932Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  <title>Lunfee&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"7obVAznQopJVH3YGJxCxCIHJ-gzGzoHsz","app_key":"R0q46NL7EQiPzt9DDQi4nuNC","server_url":"https://7obvaznq.lc-cn-n1-shared.com","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lunfee</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/IDR_THEME_NTP_BACKGROUND.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-06 14:49" pubdate>
        March 6, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      28 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            <div class="markdown-body">
              <h2 id="由单例模式深入-Java-锁"><a href="#由单例模式深入-Java-锁" class="headerlink" title="由单例模式深入 Java 锁"></a>由单例模式深入 Java 锁</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>下面的代码是一段经典的饿汉式的单例模式写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javal;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lunfee</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022/3/6-14:53</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//懒汉式单例模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//B. 可见性</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//p.</span><br><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<span class="hljs-comment">//1.</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// A. DCL （Double Check Lock双端检锁机制）</span><br>                    instance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">//2.</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是在同一 JVM 下线程同步的写法，保证多线程的实例唯一性，这里由两个需要注意的点（A. B.），我们从这两个点深入理解一下Java种的锁机制。</p>
<ul>
<li><p>A. Double Check，synchronized 关键字是一种对象锁的实现方式，由它修饰的代码块或者方法，能保证在临界区内的代码原子性，p 处对 instance 的判断不在同步块内，无法保证其读写原子性。在没有Double Check时，可能发生下面这种情况：Thread1 和 Thread2 同时执行到 p. 处， 都判断 instance == null 为 True，然后一次获取锁，完成对象的实例化，导致实例化多次。</p>
</li>
<li><p>B. volatile，仅仅做Double Check的话，任然会有问题，原因时有指令重排的存在，加入volatile可以禁止指令重排</p>
<p>原因是在某一个线程执行到第一次检测，读取到instance不为null时，instance的引用对象可能没有完成初始化。instance=new SingleDemo();可以被分为一下三步（<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BC%AA%E4%BB%A3%E7%A0%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2140946313%7D">伪代码</a>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">memory = allocate();//1.分配对象内存空间<br>instance(memory); //2.初始化对象<br>instance = memory; //3.设置instance执行刚分配的内存地址，此时instance!=null<br></code></pre></td></tr></table></figure>

<p>步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的</p>
<p>所以如果3步骤提前于步骤2，但是instance还没有初始化完成指令重排只会保证串行语义的执行的一致性（单线程），但并不关心多线程间的语义一致性。</p>
<p>所以当一条线程访问instance不为null时，由于instance示例未必已初始化完成，也就造成了线程安全问题。</p>
<p>此时加上volatile后就不会出现线程安全问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//B. 可见性</span><br></code></pre></td></tr></table></figure>

<p>因为volatile禁止了指令重排序的问题</p>
</li>
</ul>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li>volatile 关键字保证了修饰变量的可见性</li>
</ul>
<blockquote>
<p>读：忽略本地内存的变量  &gt;  直接读取主内存种的变量</p>
<p>赋值：直接读取主内存种的变量  &gt; 存入本地内存  &gt;  赋值  &gt;  刷入主内存</p>
</blockquote>
<p>在这种情况下，volatile 与 synchronized 一样保证了操作的原子性，但是这种保证，仅限于写操作与当前当前值无关的情况下。</p>
<p>对于运算等操作，无法使用 volatile 保证原子性。</p>
<blockquote>
<p>运算：直接读取主内存种的变量  &gt; 存入本地内存 &gt; 运算操作  &gt;  赋值  &gt;  刷入主内存</p>
</blockquote>
<ul>
<li>synchronized 时一种互斥锁，通过保证唯一的线程执行临界区代码，保证操作的原子性。</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul>
<li>volatile 的可见性不在赘述。</li>
<li>synchronized 也能保证可见性，只不过不是实时的，</li>
</ul>
<h2 id="单一变量的高效锁-CAS-synchronized：大材小用"><a href="#单一变量的高效锁-CAS-synchronized：大材小用" class="headerlink" title="单一变量的高效锁 CAS (synchronized：大材小用)"></a>单一变量的高效锁 CAS (synchronized：大材小用)</h2><p>我们先来看几行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>假如有100个线程同时调用 increment() 方法对 i 进行自增操作，i 的结果会是 100 吗？</p>
<p>这个方法是线程不安全的，由于 i++ 不是一个<strong>原子操作</strong>，所以是很难得到 100 的。</p>
<p>那该怎么办呢？解决的策略一般都是给这个方法加个锁，如下（<strong>这里不能用volatile，因为无法保证原子性</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然而，一个简简单单的自增操作，就加了 synchronized 进行同步，好像有点大材小用的感觉，加了 synchronized 关键词之后，当有很多线程去竞争 increment 这个方法的时候，拿不到锁的方法是会被<strong>阻塞</strong>在方法外面的，最后再来唤醒他们，而阻塞/唤醒这些操作，是非常消耗资源的。</p>
<p>虽然synchronized 到了JDK1.6之后不是做了很多优化，增加了偏向锁、轻量级锁等， 但是，就算增加了这些，当很多线程来竞争的时候，开销依然很多（会升级）</p>
<h3 id="CAS-："><a href="#CAS-：" class="headerlink" title="CAS ："></a>CAS ：</h3><p>如果我采用下面这种方式，能否保证 increment 是线程安全的，步骤如下：</p>
<p>1、线程从内存中读取 i 的值，假如此时 i 的值为 0，我们把这个值称为 k 吧，即此时 k = 0。</p>
<p>2、令 j = k + 1。</p>
<p>3、用 k 的值与内存中i的值相比，如果相等，这意味着没有其他线程修改过 i 的值，我们就把 j（此时为1） 的值写入内存；如果不相等（意味着i的值被其他线程修改过），我们就不把j的值写入内存，而是重新跳回步骤 1，继续这三个操作。</p>
<p>翻译成代码的话就是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-keyword">int</span> k = i;<br>        <span class="hljs-keyword">int</span> j = k + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">while</span> (compareAndSet(i, k, j))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样写是线程安全的。</p>
<p>这个 compareAndSet 操作，他其实只对应操作系统的<strong>一条硬件操作指令</strong>，尽管看似有很多操作在里面，但操作系统能够保证他是原子执行的。</p>
<p>对于一条英文单词很长的指令，我们都喜欢用它的简称来称呼他，所以，我们就把 compareAndSwap 称为 <strong>CAS</strong> 吧。</p>
<p>所以，采用 CAS 这种机制的写法也是线程安全的，通过这种方式，可以说是不存在锁的竞争，也不存在阻塞等事情的发生，可以让程序执行的更好。</p>
<p>在 Java 中，也是提供了这种 CAS 的原子类，例如：</p>
<ol>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
<li>AtomicReference</li>
</ol>
<p>具体如何使用呢？我就以上面那个例子进行改版吧，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 自增 1并返回之后的结果</span><br>        i.incrementAndGet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="CAS源码中为什么有循环操作"><a href="#CAS源码中为什么有循环操作" class="headerlink" title="CAS源码中为什么有循环操作"></a>CAS源码中为什么有循环操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AtomicInteger num = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br>    num.getAndIncrement();<br>    System.out.println(num);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;<br>    <span class="hljs-comment">//Object var1 一般为this, long var2 为偏移量， int var4 为目标值</span><br>    <span class="hljs-keyword">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);<span class="hljs-comment">//内存中获取值</span><br>        <span class="hljs-comment">//执行CAS操作</span><br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>多个线程对同一个共享变量进行操作时，非常用以出现并发的问题，所以为了保证线程安全，都要对共享变量进行同步。</p>
<h4 id="合理的理解"><a href="#合理的理解" class="headerlink" title="合理的理解"></a>合理的理解</h4><p>ThreadLoal 变量，它的基本原理是，同一个 ThreadLocal 所包含的对象（对ThreadLocal&lt; String &gt;而言即为 String 类型变量），在不同的 Thread 中有不同的副本（实际是不同的实例，后文会详细阐述）。这里有几点需要注意</p>
<ul>
<li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来</li>
<li>既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就不存在多线程间共享的问题</li>
<li>既无共享，何来同步问题，又何来解决同步问题一说？</li>
</ul>
<p>那 ThreadLocal 到底解决了什么问题，又适用于什么样的场景？</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p>
</blockquote>
<p>核心意思是</p>
<blockquote>
<p>ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</p>
</blockquote>
<p>总的来说，<strong>ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</strong>后文会通过实例详细阐述该观点。另外，该场景下，并非必须使用 ThreadLocal ，其它方式完全可以实现同样的效果，只是 ThreadLocal 使得实现更简洁。</p>
<h4 id="ThreadLocal怎么用"><a href="#ThreadLocal怎么用" class="headerlink" title="ThreadLocal怎么用"></a><strong>ThreadLocal怎么用</strong></h4><p>既然ThreadLocal的作用是每一个线程创建一个副本，我们使用一个例子来验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalTest01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//新建一个ThreadLocal</span><br>        ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>        <span class="hljs-comment">//新建一个随机数类</span><br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-comment">//使用java8的Stream新建5个线程</span><br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>).forEach(a-&gt; <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>            <span class="hljs-comment">//为每一个线程设置相应的local值</span><br>            local.set(a+<span class="hljs-string">&quot;  &quot;</span>+random.nextInt(<span class="hljs-number">10</span>));   <br>            System.out.println(<span class="hljs-string">&quot;线程和local值分别是  &quot;</span>+ local.get());<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*线程和local值分别是  0  6</span><br><span class="hljs-comment">  线程和local值分别是  1  4</span><br><span class="hljs-comment">  线程和local值分别是  2  3</span><br><span class="hljs-comment">  线程和local值分别是  4  9</span><br><span class="hljs-comment">  线程和local值分别是  3  5 */</span><br></code></pre></td></tr></table></figure>

<p>从结果我们可以看到，每一个线程都有各自的local值，我们设置了一个休眠时间，就是为了另外一个线程也能够及时的读取当前的local值。</p>
<p>这就是TheadLocal的基本使用，是不是非常的简单。那么为什么会在数据库连接的时候使用的比较多呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Connection connect = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(connect == <span class="hljs-keyword">null</span>)&#123;<br>            connect = DriverManager.getConnection();<br>        &#125;<br>        <span class="hljs-keyword">return</span> connect;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(connect!=<span class="hljs-keyword">null</span>)<br>            connect.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面是一个数据库连接的管理类，我们使用数据库的时候首先就是建立数据库连接，然后用完了之后关闭就好了，这样做有一个很严重的问题，如果有1个客户端频繁的使用数据库，那么就需要建立多次链接和关闭，我们的服务器可能会吃不消，怎么办呢？如果有一万个客户端，那么服务器压力更大。</p>
<p>这时候最好ThreadLocal，因为ThreadLocal在每个线程中对连接会创建一个副本，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。是不是很好用。</p>
<h4 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="hljs-comment">     * to the specified value.  Most subclasses will have no need to</span><br><span class="hljs-comment">     * override this method, relying solely on the &#123;<span class="hljs-doctag">@link</span> #initialValue&#125;</span><br><span class="hljs-comment">     * method to set the values of thread-locals.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span><br><span class="hljs-comment">     *        this thread-local.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        Thread t = Thread.currentThread();<br>        ThreadLocalMap map = getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>            map.set(<span class="hljs-keyword">this</span>, value);<br>        <span class="hljs-keyword">else</span><br>            createMap(t, value);<br>    &#125;<br>    <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create the map associated with a ThreadLocal. Overridden in</span><br><span class="hljs-comment">     * InheritableThreadLocal.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the current thread</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> firstValue value for the initial entry of the map</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>        t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>自我理解： ThreadLocal 其实就是一个空壳，线程的局部变量不是存放在 ThreadLocal 中的，而是使用 ThreadLocal 维护的方法对当前线程的 ThreadLocalMap threadLocals 进行操作，之所以使用 Map 的形式存储，是因为同一个线程可能维护多个ThreadLocal 变量。</p>
<p>内存溢出问题： 如果一个线程不消亡，其threadLocals中的变量就一直会存在，可能会造成内存溢出，所以使用完毕要进行remove操作。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>对于 Java Web 应用而言，Session 保存了很多信息。很多时候需要通过 Session 获取信息，有些时候又需要修改 Session 的信息。一方面，需要保证每个线程有自己单独的 Session 实例。另一方面，由于很多地方都需要操作 Session，存在多方法共享 Session 的需求。如果不使用 ThreadLocal，可以在每个线程内构建一个 Session实例，并将该实例在多个方法间传递，如下所示。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SessionHandler &#123;<br><br>  @Data<br>  <span class="hljs-built_in">public</span> static <span class="hljs-keyword">class</span> <span class="hljs-keyword">Session</span> &#123;<br>    private String id;<br>    private String <span class="hljs-keyword">user</span>;<br>    private String status;<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> <span class="hljs-keyword">Session</span> createSession() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> <span class="hljs-keyword">Session</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> String getUser(<span class="hljs-keyword">Session</span> <span class="hljs-keyword">session</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">session</span>.getUser();<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> String getStatus(<span class="hljs-keyword">Session</span> <span class="hljs-keyword">session</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">session</span>.getStatus();<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> setStatus(<span class="hljs-keyword">Session</span> <span class="hljs-keyword">session</span>, String status) &#123;<br>    <span class="hljs-keyword">session</span>.setStatus(status);<br>  &#125;<br><br>  <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    <span class="hljs-built_in">new</span> Thread(() -&gt; &#123;<br>      SessionHandler <span class="hljs-keyword">handler</span> = <span class="hljs-built_in">new</span> SessionHandler();<br>      <span class="hljs-keyword">Session</span> <span class="hljs-keyword">session</span> = <span class="hljs-keyword">handler</span>.createSession();<br>      <span class="hljs-keyword">handler</span>.getStatus(<span class="hljs-keyword">session</span>);<br>      <span class="hljs-keyword">handler</span>.getUser(<span class="hljs-keyword">session</span>);<br>      <span class="hljs-keyword">handler</span>.setStatus(<span class="hljs-keyword">session</span>, &quot;close&quot;);<br>      <span class="hljs-keyword">handler</span>.getStatus(<span class="hljs-keyword">session</span>);<br>    &#125;).<span class="hljs-keyword">start</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>该方法是可以实现需求的。但是每个需要使用 Session 的地方，都需要显式传递 Session 对象，方法间耦合度较高。</p>
<p>这里使用 ThreadLocal 重新实现该功能如下所示。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionHandler</span> &#123;</span><br><br>  public <span class="hljs-keyword">static</span> ThreadLocal&lt;Session&gt; session = ThreadLocal.&lt;Session&gt;withInitial<span class="hljs-function"><span class="hljs-params">(() -&gt; <span class="hljs-keyword">new</span> Session())</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  @<span class="hljs-title">Data</span></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">class</span> <span class="hljs-title">Session</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">id</span>;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">user</span>;</span><br><span class="hljs-function">    <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">status</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">session</span>.<span class="hljs-title">get</span><span class="hljs-params">()</span>.<span class="hljs-title">getUser</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">String</span> <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">session</span>.<span class="hljs-title">get</span><span class="hljs-params">()</span>.<span class="hljs-title">getStatus</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-built_in">String</span> status)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">session</span>.<span class="hljs-title">get</span><span class="hljs-params">()</span>.<span class="hljs-title">setStatus</span><span class="hljs-params">(status)</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-title">public</span> <span class="hljs-title">static</span> <span class="hljs-title">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-built_in">String</span>[] args)</span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">      SessionHandler handler = <span class="hljs-keyword">new</span> SessionHandler();</span></span><br><span class="hljs-params"><span class="hljs-function">      handler.getStatus();</span></span><br><span class="hljs-params"><span class="hljs-function">      handler.getUser();</span></span><br><span class="hljs-params"><span class="hljs-function">      handler.setStatus(<span class="hljs-string">&quot;close&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">      handler.getStatus();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>



<p>使用 ThreadLocal 改造后的代码，不再需要在各个方法间传递 Session 对象，并且也非常轻松的保证了每个线程拥有自己独立的实例。</p>
<p>如果单看其中某一点，替代方法很多。比如可通过在线程内创建局部变量可实现每个线程有自己的实例，使用静态变量可实现变量在方法间的共享。但如果要同时满足变量在线程间的隔离与方法间的共享，ThreadLocal再合适不过。</p>
<h4 id="弱引用问题"><a href="#弱引用问题" class="headerlink" title="弱引用问题"></a>弱引用问题</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/304240519">https://zhuanlan.zhihu.com/p/304240519</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/08/re/%E5%BF%AB%E6%89%8B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/23/Maven/">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
