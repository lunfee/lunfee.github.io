

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="Java多线程杂谈java线程与操作系统的本地线程一一对应，Java线程开启本地线程就会创建，Java线程结束，本地线程就被回收 进程与线程进程计算机操作系统的可执行文件是由一行行代码或指令组成，这些静态的指令与数据文件在计算机中叫一个程序。 想要运行一个程序就必须要把这些指令集加载到机器的CPU中，同时将数据加载到内存，运行起来的程序叫做进程，进程是用来加载指令，管理IO，管理内存的。同一个程序">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="http://example.com/2021/10/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Lunfee&#39;s Blog">
<meta property="og:description" content="Java多线程杂谈java线程与操作系统的本地线程一一对应，Java线程开启本地线程就会创建，Java线程结束，本地线程就被回收 进程与线程进程计算机操作系统的可执行文件是由一行行代码或指令组成，这些静态的指令与数据文件在计算机中叫一个程序。 想要运行一个程序就必须要把这些指令集加载到机器的CPU中，同时将数据加载到内存，运行起来的程序叫做进程，进程是用来加载指令，管理IO，管理内存的。同一个程序">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/10/17/5kzyDTlpFstjhu6.png">
<meta property="og:image" content="https://i.loli.net/2021/10/17/ZH2raKA4k6JvITS.png">
<meta property="og:image" content="https://i.loli.net/2021/10/17/kqhrBep91x4o85i.png">
<meta property="og:image" content="https://i.loli.net/2021/10/17/OjnMUfIxRTkZlLc.png">
<meta property="og:image" content="https://i.loli.net/2021/10/17/5HFDiwARtGZXpNB.png">
<meta property="og:image" content="https://i.loli.net/2021/10/22/TRUks3jOmY12VKv.png">
<meta property="og:image" content="https://i.loli.net/2021/10/17/hYEj1pHd9OZxJyA.png">
<meta property="og:image" content="https://i.loli.net/2021/10/21/i3pkemhWc6UvSBr.png">
<meta property="og:image" content="https://i.loli.net/2021/10/21/UhMp4cRNVS9GPmK.png">
<meta property="og:image" content="https://i.loli.net/2021/10/22/yuk689JfSLjoZHQ.png">
<meta property="article:published_time" content="2021-10-13T12:31:00.000Z">
<meta property="article:modified_time" content="2021-10-25T07:59:43.647Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="线程">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/10/17/5kzyDTlpFstjhu6.png">
  
  <title>多线程 - Lunfee&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"7obVAznQopJVH3YGJxCxCIHJ-gzGzoHsz","app_key":"R0q46NL7EQiPzt9DDQi4nuNC","server_url":"https://7obvaznq.lc-cn-n1-shared.com","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lunfee</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/IDR_THEME_NTP_BACKGROUND.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="多线程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-13 20:31" pubdate>
        October 13, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.4k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      26 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">多线程</h1>
            
            <div class="markdown-body">
              <h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>java线程与操作系统的本地线程一一对应，Java线程开启本地线程就会创建，Java线程结束，本地线程就被回收</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>计算机操作系统的可执行文件是由一行行代码或指令组成，这些静态的指令与数据文件在计算机中叫一个程序。</p>
<p>想要运行一个<strong>程序</strong>就必须要把这些指令集加载到机器的CPU中，同时将数据加载到内存，运行起来的程序叫做<strong>进程</strong>，进程是用来加载指令，管理IO，管理内存的。同一个程序如果允许多次执行，就形成了多个进程。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程可以包括多个线程（Windows进程就是一个线程容器）</p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行</p>
<h3 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h3><p>在Java中，线程是最小的<strong>调度</strong>单位，进程是资源分配的最小单位。</p>
<p>进程是相互独立的，而线程存在于进程内，是进程的一个子集</p>
<p>进程内存在共享资源，供内部线程共享使用</p>
<p>多线程：一个进程内同时并行执行多个线程，每个线程各自有一套虚拟机栈和程序计数器。</p>
<p>多线程的优势：</p>
<ol>
<li><p>用户使用图形化界面完成不同任务的必须。</p>
</li>
<li><p>可以提高CPU利用率（尽管对于单核会降低速度）</p>
</li>
<li><p>复杂的进程分为多线程，单独启动易于管理，优化结构。</p>
</li>
</ol>
<p>何时使用多线程：</p>
<ol>
<li><p>程序需要同时执行两个或多个任务</p>
</li>
<li><p>程序需要实现一些需要等待的任务，比如网络加载，输入，读写文件等 </p>
</li>
</ol>
<p>后台执行任务。</p>
<p>进程间的通信：同一台计算机之间进程的通讯成为IPC(Inter-Process Communication)</p>
<p>​                         不同计算机之间的进程通讯，需要走网络并遵守协议</p>
<p>线程间的通讯：线程共享方法区和堆，可以实现进程间高效通信。</p>
<p>上下文切换：</p>
<ol>
<li>线程间的上下文切换主要是对指令的临时存储，开销较小</li>
<li>进程间的上下文切换涉及到资源的临时存储，开销较大</li>
</ol>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>并发(Concurent)的概念是建立在单个处理器上，在逻辑（时间）上好像多个线程在同步运行，实际上是在不同线程间不停切换。处理器核心为不同线程分发时间片，CPU在不同的线程见轮询（Windows下最短时间片为15ms)</p>
<p>并行是物理意义上的同步运行，基于多个处理器（核心），单核处理器无法实现并行。</p>
<p>计算机的任务处理是并行域并发同时发生的，因为大多数情况下，计算机需要处理的线程数要大于计算机的总处理器核数。</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>任务执行的同步与异步：</p>
<ol>
<li>需要等待结果返回才能继续运行就是同步</li>
<li>不要等待结果返回就能继续运行就是同步</li>
</ol>
<p>Java多线程的同步：让多个线程步调一致</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol>
<li>在单核CPU下，多线程并不能提高实际的效率，只是为了在不同的任务之间转换，不同线程轮流使用CPU，避免单线程工作，其他线程等待。</li>
<li>对于多核CPU而言，处理任务是否可以拆分，是否需要拆分都需要根据实际情况确定。</li>
<li>IO操作是不占用CPU的，但是如果使用<strong>阻塞IO</strong>，相当于线程虽然不用CPU，但是需要一直等待IO操作结束，没有充分的利用线程，所以才有后面的<strong>非阻塞IO</strong>和<strong>异步IO</strong>（NIO）.</li>
</ol>
<h2 id="JAVA线程基础"><a href="#JAVA线程基础" class="headerlink" title="JAVA线程基础"></a>JAVA线程基础</h2><h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><h4 id="方法1：使用Thread（继承Threada类，重写run-方法）"><a href="#方法1：使用Thread（继承Threada类，重写run-方法）" class="headerlink" title="方法1：使用Thread（继承Threada类，重写run()方法）"></a>方法1：使用Thread（继承Threada类，重写run()方法）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建线程对象</span><br><span class="hljs-comment">//使用匿名内部类的方式创建Thread，因为只用一次，直接在new的时候覆盖run()方法。</span><br>Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        log.debug(<span class="hljs-string">&quot;thread1 run&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//交给任务调度器调度分配时间片，由CPU执行。</span><br>t1.start();<br></code></pre></td></tr></table></figure>

<h4 id="方法2；使用Runnable配合Thread"><a href="#方法2；使用Runnable配合Thread" class="headerlink" title="方法2；使用Runnable配合Thread"></a>方法2；使用Runnable配合Thread</h4><ol>
<li>把线程和任务分离</li>
<li>Tread表示线程，Runnable表示可运行的任务，线程要执行的代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable task = <span class="hljs-keyword">new</span> Runnable()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        log.debug(<span class="hljs-string">&quot;task run&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//也可以交给线程池处理</span><br>Thread t2 = Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure>

<h5 id="新知识"><a href="#新知识" class="headerlink" title="新知识"></a>新知识</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Runnable接口源码</span><br><span class="hljs-meta">@FunctionlInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>@FunctionalInterface注解使用在仅有一个抽象方法的接口上，在Java8 以上的版本中可以使用lambda表达式简写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable task = () -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;task run&quot;</span>);<br>&#125;<br><span class="hljs-comment">//也可以交给线程池处理</span><br>Thread t2 = Thread(task, <span class="hljs-string">&quot;t2&quot;</span>);<br>t2.start();<br></code></pre></td></tr></table></figure>

<h4 id="方法3：FutureTssk配合Thread（）"><a href="#方法3：FutureTssk配合Thread（）" class="headerlink" title="方法3：FutureTssk配合Thread（）"></a>方法3：FutureTssk配合Thread（）</h4><p>从Runnable接口源码可以看出，Runnable接口的run()方法没有返回值，无法进行线程间数据的传输共享。</p>
<p><img src="https://i.loli.net/2021/10/17/5kzyDTlpFstjhu6.png" srcset="/img/loading.gif" lazyload alt="image-20211017171615846"></p>
<p>FutureTask类可以返回线程的执行结果，它的继承关系如图：</p>
<p><img src="https://i.loli.net/2021/10/17/ZH2raKA4k6JvITS.png" srcset="/img/loading.gif" lazyload alt="image-20211017172252995"></p>
<p>继承的Future接口中有get()方法，能实现返回，除此之外，FutureTask需要搭配Callable接口（有返回值）：</p>
<p><img src="https://i.loli.net/2021/10/17/kqhrBep91x4o85i.png" srcset="/img/loading.gif" lazyload alt="image-20211017172157201"></p>
<p>一个代码示例（之前在尚硅谷记的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableThtread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//3.create the instance of call class</span><br>        NumberThresd numberThresd = <span class="hljs-keyword">new</span> NumberThresd();<br>        <span class="hljs-comment">//4.use the futuretask tool</span><br>        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(numberThresd);<br>        <span class="hljs-comment">//5.create new thread</span><br>        <span class="hljs-keyword">new</span> Thread(futureTask).start();<br>        <span class="hljs-comment">//6.call get method if you need the return value of call</span><br>        Object o = futureTask.get();<br>        System.out.println(o);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//1.create a class implements Callable interface and Override call method</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThresd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//2.return Object, Integer is the subclass of Object, int sum is turned into Integer automatically</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                sum += i;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>关于为什么使用Future命名，从官方对Future的解释可以看出，get()方法可能需要阻塞等待执行结果(未来的结果)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready.<br></code></pre></td></tr></table></figure>

<h3 id="线程和进程的查看"><a href="#线程和进程的查看" class="headerlink" title="线程和进程的查看"></a>线程和进程的查看</h3><p>在Windows下提供了查看所有进程与线程的cmd命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tasklist   //显示所有任务<br>taskkill   //通过pid杀死某个进程<br>tasklist | findstr java    //通过管道方法搜索带有java字段的任务<br></code></pre></td></tr></table></figure>

<p>Linus下对线程的查看操作更为丰富</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -fe | grep java    //管道筛选所有Java字段的进程<br>kill pid              //杀死进程<br>top					//动态采集进程运行情况，包括CPU占用和MER占用<br>top -H -p pid		 //显示进程中所有线程的信息(-H 表示查看线程)<br></code></pre></td></tr></table></figure>



<p>JDK也提供了一套可以用来专门查看Java线程的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jps       //查看所有java进程<br></code></pre></td></tr></table></figure>

<h3 id="线程的运行底层原理"><a href="#线程的运行底层原理" class="headerlink" title="线程的运行底层原理"></a>线程的运行底层原理</h3><p>Java Virtual Machine Stacks(Java 虚拟机栈)</p>
<p><img src="https://i.loli.net/2021/10/17/OjnMUfIxRTkZlLc.png" srcset="/img/loading.gif" lazyload alt="image-20211017200109319"></p>
<p>JVM是由堆，栈，方法区组成，其中栈时线程私有的，每个线程启动，虚拟机都会为其分配一块栈内存，</p>
<p>每个栈由多个栈帧(Frame)组成，对应这每次方法调用时所占用的内存。</p>
<p>每个线程只有一个活动的栈帧，对应着当前正在执行的那个方法。</p>
<p>单个线程的运行时栈内存和栈帧内存的使用情况：</p>
<p><img src="https://i.loli.net/2021/10/17/5HFDiwARtGZXpNB.png" srcset="/img/loading.gif" lazyload alt="image-20211017194407325"></p>
<p>多个线程的情况下，各个线程之间有各自的占内存，栈帧是相互独立的.</p>
<p><img src="https://i.loli.net/2021/10/22/TRUks3jOmY12VKv.png" srcset="/img/loading.gif" lazyload alt="image-20211022110139621"></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14763079/what-are-the-xms-and-xmx-parameters-when-starting-jvm">https://stackoverflow.com/questions/14763079/what-are-the-xms-and-xmx-parameters-when-starting-jvm</a></p>
<p>The flag <code>Xmx</code> specifies the maximum memory allocation pool for a Java Virtual Machine (JVM), while <code>Xms</code> specifies the initial memory allocation pool.</p>
<p>This means that your JVM will be started with <code>Xms</code> amount of memory and will be able to use a maximum of <code>Xmx</code> amount of memory. For example, starting a JVM like below will start it with 256 MB of memory and will allow the process to use up to 2048 MB of memory:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java -Xms256m -Xmx2048m<br></code></pre></td></tr></table></figure>

<p>The memory flag can also be specified in different sizes, such as kilobytes, megabytes, and so on.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xmx1024k<br>-Xmx512m<br>-Xmx8g<br></code></pre></td></tr></table></figure>

<p>The <code>Xms</code> flag has no default value, and <code>Xmx</code> typically has a default value of 256 MB. A common use for these flags is when you encounter a <code>java.lang.OutOfMemoryError</code>.</p>
<p>When using these settings, keep in mind that these settings are for the JVM’s <em>heap</em>, and that the JVM can and will use more memory than just the size allocated to the heap. From <a target="_blank" rel="noopener" href="http://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html">Oracle’s documentation</a>:</p>
<blockquote>
<p>Note that the JVM uses more memory than just the heap. For example Java methods, thread stacks and native handles are allocated in memory separate from the heap, as well as JVM internal data structures.</p>
</blockquote>
<h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收 有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能</li>
</ul>
<p>上下文切换的具体情况：</p>
<p><img src="https://i.loli.net/2021/10/17/hYEj1pHd9OZxJyA.png" srcset="/img/loading.gif" lazyload alt="image-20211017201009754"></p>
<h3 id="线程常用方法讲解"><a href="#线程常用方法讲解" class="headerlink" title="线程常用方法讲解"></a>线程常用方法讲解</h3><h4 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h4><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p>
<h4 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h4><p><strong>sleep</strong> (使线程阻塞)</p>
<ol>
<li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p>
</li>
<li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p>
</li>
<li><p>睡眠结束后的线程未必会立刻得到执行</p>
</li>
<li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span><br>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//休眠一分钟</span><br>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<p>yield （让出当前线程）</p>
<ol>
<li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能(机会)被执行），然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ol>
<h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><ul>
<li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p>
</li>
<li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p>
</li>
<li><p>设置方法：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-regexp">//</span>设置为优先级最高<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h4><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p>
<p>如在主线程中调用t1.join()，则是主线程等待t1线程结束</p>
<p>join() 方法可用于<strong>线程的同步</strong></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>();<br><span class="hljs-comment">//等待thread线程执行结束</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>();<br><span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br><span class="hljs-keyword">thread</span>.<span class="hljs-keyword">join</span>(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>

<h4 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h4><p>当<strong>阻塞</strong>(sleep wait join…)的线程被打断，实际是阻塞状态被终止。</p>
<p>所以sleep()方法需要添加异常处理，被打断后会抛出异常并且立刻执行进入运行状态。</p>
<ul>
<li>如果一个线程在在运行中被打断，打断标记会被置为true。</li>
<li>如果是打断因sleep wait join方法而被阻塞的线程，只是打断了当前的阻塞状态，会继续执行之后的代码，打断标记置为false</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>用于查看打断标记，返回值被boolean类型<br>t1.isInterrupted();<br></code></pre></td></tr></table></figure>

<p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>) &#123;<br>        break;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="https://i.loli.net/2021/10/21/i3pkemhWc6UvSBr.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<p><strong>代码</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> &#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>		Monitor monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Monitor</span>();<br>		monitor.<span class="hljs-built_in">start</span>();<br>		Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">3500</span>);<br>		monitor.<span class="hljs-built_in">stop</span>();<br>	&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> &#123;</span><br><br>	Thread monitor;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 启动监控器线程</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span><br>		monitor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>() &#123;<br>			@Override<br>			<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br>				<span class="hljs-comment">//开始不停的监控</span><br>				<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">//判断当前线程是否被打断了</span><br>					<span class="hljs-keyword">if</span>(Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">isInterrupted</span>()) &#123;<br>						System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;处理后续任务&quot;</span>);<br>                        <span class="hljs-comment">//终止线程执行</span><br>						<span class="hljs-keyword">break</span>;<br>					&#125;<br>					System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;监控器运行中...&quot;</span>);<br>					<span class="hljs-keyword">try</span> &#123;<br>						<span class="hljs-comment">//线程休眠</span><br>						Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>					&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (InterruptedException e) &#123;<br>						e.<span class="hljs-built_in">printStackTrace</span>();<br>						<span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br>						Thread.<span class="hljs-built_in">currentThread</span>().<span class="hljs-built_in">interrupt</span>();<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;;<br>		monitor.<span class="hljs-built_in">start</span>();<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 	用于停止监控器线程</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//打断线程</span><br>		monitor.<span class="hljs-built_in">interrupt</span>();<br>	&#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure>

<h4 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h4><ul>
<li>stop方法 停止线程运行（可能造成共享资源锁无法被释放，其他线程无法使用这些共享资源）</li>
<li>suspend（暂停线程）/resume（恢复线程）方法</li>
</ul>
<h4 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h4><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p>
<p>所以守护线程就像一个其他线程的守护者，别人不结束我就一直干，别人结束了我就立刻放弃自己的所有任务（感人了）</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//将线程设置为守护线程, 默认为<span class="hljs-literal">false</span><br><span class="hljs-literal">monitor</span>.setDaemon(<span class="hljs-literal">true</span>);Copy<br></code></pre></td></tr></table></figure>

<p><strong>守护线程的应用</strong></p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li>
</ul>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><h4 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h4><p>这是从 <strong>操作系统</strong> 层面来描述的</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="https://i.loli.net/2021/10/21/UhMp4cRNVS9GPmK.png" srcset="/img/loading.gif" lazyload alt="img"></a></p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h4 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h4><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p>
<p><img src="https://i.loli.net/2021/10/22/yuk689JfSLjoZHQ.png" srcset="/img/loading.gif" lazyload alt="image-20211022223937573"></p>
<ul>
<li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li>
<li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li>
<li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li>
<li><strong>TERMINATED</strong> 当线程代码运行结束</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/18/dp/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">动态规划</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/06/20211006/">
                        <span class="hidden-mobile">20211006</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
