

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="说明： 本题解主要是写给对 回溯算法 还比较陌生的朋友，所以会介绍得很详细；如果看题解觉得比较冗长，可以先观看我投稿给「力扣」 官方题解 的视频；本文还在持续更新，由于个人水平和精力有限，没法一下子表达出所有想表达的意思，还请大家见谅。补充说明（2020 年 8 月 31 日补充）：请大家做了一些回溯算法的问题以后顺便思考一下：深度优先遍历、递归、栈，它们三者的关系，我个人以为它们背后统一的逻辑都">
<meta property="og:type" content="article">
<meta property="og:title" content="回溯算法&lt;临时&gt;">
<meta property="og:url" content="http://example.com/2021/10/23/%E8%AF%B4%E6%98%8E%EF%BC%9A/index.html">
<meta property="og:site_name" content="Lunfee&#39;s Blog">
<meta property="og:description" content="说明： 本题解主要是写给对 回溯算法 还比较陌生的朋友，所以会介绍得很详细；如果看题解觉得比较冗长，可以先观看我投稿给「力扣」 官方题解 的视频；本文还在持续更新，由于个人水平和精力有限，没法一下子表达出所有想表达的意思，还请大家见谅。补充说明（2020 年 8 月 31 日补充）：请大家做了一些回溯算法的问题以后顺便思考一下：深度优先遍历、递归、栈，它们三者的关系，我个人以为它们背后统一的逻辑都">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-10-23T14:03:00.000Z">
<meta property="article:modified_time" content="2021-10-23T14:04:23.375Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="回溯">
<meta name="twitter:card" content="summary_large_image">
  
  <title>回溯算法&lt;临时&gt; - Lunfee&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"7obVAznQopJVH3YGJxCxCIHJ-gzGzoHsz","app_key":"R0q46NL7EQiPzt9DDQi4nuNC","server_url":"https://7obvaznq.lc-cn-n1-shared.com","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lunfee</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/IDR_THEME_NTP_BACKGROUND.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="回溯算法&lt;临时&gt;">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-23 22:03" pubdate>
        October 23, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      32 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">回溯算法&lt;临时&gt;</h1>
            
            <div class="markdown-body">
              <p>说明：</p>
<p>本题解主要是写给对 回溯算法 还比较陌生的朋友，所以会介绍得很详细；<br>如果看题解觉得比较冗长，可以先观看我投稿给「力扣」 官方题解 的视频；<br>本文还在持续更新，由于个人水平和精力有限，没法一下子表达出所有想表达的意思，还请大家见谅。<br>补充说明（2020 年 8 月 31 日补充）：请大家做了一些回溯算法的问题以后顺便思考一下：深度优先遍历、递归、栈，它们三者的关系，我个人以为它们背后统一的逻辑都是「后进先出」。完成练习有助于我们深刻理解算法思想，我们加油！</p>
<p>回溯算法与深度优先遍历<br>以下是维基百科中「回溯算法」和「深度优先遍历」的定义。</p>
<p>回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<p>找到一个可能存在的正确的答案；<br>在尝试了所有可能的分步方法后宣告该问题没有答案。<br>深度优先搜索 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p>
<p>我刚开始学习「回溯算法」的时候觉得很抽象，一直不能理解为什么递归之后需要做和递归之前相同的逆向操作，在做了很多相关的问题以后，我发现其实「回溯算法」与「 深度优先遍历 」有着千丝万缕的联系。</p>
<p>个人理解<br>「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。至于广度优先遍历为什么没有成为强大的搜索算法，我们在题解后面会提。</p>
<p>在「力扣」第 51 题的题解《回溯算法（第 46 题 + 剪枝）》 中，展示了如何使用回溯算法搜索 44 皇后问题的一个解，相信对大家直观地理解「回溯算法」是有帮助。</p>
<p>搜索与遍历<br>我们每天使用的搜索引擎帮助我们在庞大的互联网上搜索信息。搜索引擎的「搜索」和「回溯搜索」算法里「搜索」的意思是一样的。</p>
<p>搜索问题的解，可以通过 遍历 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 搜索一个问题的所有的解 ，通过深度优先遍历的思想实现。</p>
<p>与动态规划的区别<br>共同点<br>用于求解多阶段决策问题。多阶段决策问题即：</p>
<p>求解一个问题分为很多步骤（阶段）；<br>每一个步骤（阶段）可以有多种选择。<br>不同点<br>动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；<br>回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。<br>从全排列问题开始理解回溯算法<br>我们尝试在纸上写 33 个数字、44 个数字、55 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。</p>
<p>先写以 11 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；<br>再写以 22 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；<br>最后写以 33 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。<br>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够做到 不重不漏。这样的思路，可以用一个树形结构表示。</p>
<p>看到这里的朋友，建议先尝试自己画出「全排列」问题的树形结构。</p>
<p>说明：</p>
<p>每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；<br>使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；<br>深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；<br>深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。<br>使用编程的方法得到全排列，就是在这样的一个树形结构中完成 遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p>
<p>设计状态变量<br>首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；<br>递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；<br>布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。<br>这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p>
<p>代码实现<br>参考代码 1：</p>
<p>注意：下面的代码是错误的，希望读者能运行测试用例，发现原因，然后再阅读后面的内容。</p>
<p>JavaPython</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>public class Solution {</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;
    int len = nums.length;
    // 使用一个动态数组保存所有可能的全排列
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if (len == 0) &#123;
        return res;
    &#125;

    boolean[] used = new boolean[len];
    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();

    dfs(nums, len, 0, path, used, res);
    return res;
&#125;

private void dfs(int[] nums, int len, int depth,
                 List&lt;Integer&gt; path, boolean[] used,
                 List&lt;List&lt;Integer&gt;&gt; res) &#123;
    if (depth == len) &#123;
        res.add(path);
        return;
    &#125;

    // 在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。
    for (int i = 0; i &lt; len; i++) &#123;
        if (!used[i]) &#123;
            path.add(nums[i]);
            used[i] = true;

            dfs(nums, len, depth + 1, path, used, res);
            // 注意：下面这两行代码发生 「回溯」，回溯发生在从 深层结点 回到 浅层结点 的过程，代码在形式上和递归之前是对称的
            used[i] = false;
            path.remove(path.size() - 1);
        &#125;
    &#125;
&#125;

public static void main(String[] args) &#123;
    int[] nums = &#123;1, 2, 3&#125;;
    Solution solution = new Solution();
    List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);
    System.out.println(lists);
&#125;
</code></pre>
<p>}<br>执行 main 方法以后输出如下：</p>
<p>[[], [], [], [], [], []]<br>原因出现在递归终止条件这里：</p>
<p>JavaPython</p>
<p>if (depth == len) {<br>    res.add(path);<br>    return;<br>}<br>变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表。</p>
<p>在 Java 中，参数传递是 值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 66 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。</p>
<p>修改的部分：</p>
<p>JavaPython</p>
<p>if (depth == len) {<br>    res.add(new ArrayList&lt;&gt;(path));<br>    return;<br>}<br>此时再提交到「力扣」上就能得到通过了，完整代码请见下文「参考代码 2」。</p>
<p>复杂度分析：（初学回溯算法的时候可以暂时跳过。）</p>
<p>回溯算法由于其遍历的特点，时间复杂度一般都比较高，有些问题分析起来很复杂。一些回溯算法解决的问题，剪枝剪得好的话，复杂度会降得很低，因此分析最坏时间复杂度的意义也不是很大。但还是视情况而定。</p>
<p>时间复杂度：O(N \times N!)O(N×N!)<br>非叶子结点的个数，依次为（按照层数来）：</p>
<p>1 + A_N^1 + A_N^2 + \cdots + A_N^{N-1} = 1 + \cfrac{N!}{(N - 1)!} + \cfrac{N!}{(N - 2)!} + \cdots + N!<br>1+A<br>N<br>1</p>
<p> +A<br>N<br>2</p>
<p> +⋯+A<br>N<br>N−1</p>
<p> =1+<br>(N−1)!<br>N!</p>
<ul>
<li><p>(N−2)!<br>N!</p>
</li>
<li><p>⋯+N!</p>
</li>
</ul>
<p>说明：根结点为 11，计算复杂度的时候忽略；A_N^1A<br>N<br>1</p>
<p>  表示排列数，计算公式为 A_n^m = \cfrac{n!}{(n - m)!}A<br>n<br>m</p>
<p> =<br>(n−m)!<br>n!</p>
<p> 。</p>
<p>在第 1 层，结点个数为 NN 个数选 1 个的排列，故为 A_N^1A<br>N<br>1</p>
<p> ；</p>
<p>在第 2 层，结点个数为 NN 个数选 2 个的排列，故为 A_N^2A<br>N<br>2</p>
<p> 。</p>
<p>\cfrac{N!}{(N - 1)!} + \cfrac{N!}{(N - 2)!} + \cdots + N! = N! \left( \cfrac{1}{(N - 1)!} + \cfrac{1}{(N - 2)!} + \cdots + 1 \right) \le N! \left( 1 + \cfrac{1}{2} + \cfrac{1}{4} + \cdots + \cfrac{1}{2^{N - 1}} \right) &lt; 2N!<br>(N−1)!<br>N!</p>
<ul>
<li><p>(N−2)!<br>N!</p>
</li>
<li><p>⋯+N!=N!(<br>(N−1)!<br>1</p>
</li>
<li><p>(N−2)!<br>1</p>
</li>
<li><p>⋯+1)≤N!(1+<br>2<br>1</p>
</li>
<li><p>4<br>1</p>
</li>
<li><p>⋯+<br>2<br>N−1</p>
</li>
</ul>
<p>1</p>
<p> )&lt;2N!</p>
<p>将常系数 22 视为 11，每个内部结点循环 NN 次，故非叶子结点的时间复杂度为 O(N \times N!)O(N×N!)；</p>
<p>最后一层共 N!N! 个叶节点，在叶子结点处拷贝需要 O(N)O(N)，叶子结点的时间复杂度也为 O(N \times N!)O(N×N!)。</p>
<p>空间复杂度：O(N \times N!)O(N×N!)。<br>递归树深度 \log NlogN；<br>全排列个数 N!N!，每个全排列占空间 NN。取较大者。<br>理解回溯<br>从 [1, 2, 3] 到 [1, 3, 2] ，深度优先遍历是这样做的，从 [1, 2, 3] 回到 [1, 2] 的时候，需要撤销刚刚已经选择的数 3，因为在这一层只有一个数 3 我们已经尝试过了，因此程序回到上一层，需要撤销对 2 的选择，好让后面的程序知道，选择 3 了以后还能够选择 2。</p>
<p>执行深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做「状态重置」，即「回到过去」、「恢复现场」，我们举一个例子。</p>
<p>月光宝盒<br>只有撤销上一次的选择，重置现场，才能够回到 完全一样 的过去，再开始新的尝试才会是有效的。</p>
<p>《大话西游》里有这样的情节，至尊宝要对着「月光宝盒」喊一声「波若菠萝蜜」，时间就可以回到回去（所有的人物、事物都得一样，才能叫「回到过去」），他才能救人。这个道理其实和这里的「撤销选择」是一模一样的。</p>
<p>理解回溯比较困难的是理解「回到过去」，现实世界里我们无法回到过去，但是在算法的世界里可以。</p>
<p>通过打印输出观察<br>参考代码 2：</p>
<p>Java</p>
<p>import java.util.ArrayDeque;<br>import java.util.ArrayList;<br>import java.util.Deque;<br>import java.util.List;</p>
<p>public class Solution {</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;
    int len = nums.length;
    // 使用一个动态数组保存所有可能的全排列
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if (len == 0) &#123;
        return res;
    &#125;

    boolean[] used = new boolean[len];
    Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(len);

    dfs(nums, len, 0, path, used, res);
    return res;
&#125;

private void dfs(int[] nums, int len, int depth,
                 Deque&lt;Integer&gt; path, boolean[] used,
                 List&lt;List&lt;Integer&gt;&gt; res) &#123;
    if (depth == len) &#123;
        res.add(new ArrayList&lt;&gt;(path));
        return;
    &#125;

    for (int i = 0; i &lt; len; i++) &#123;
        if (!used[i]) &#123;
            path.addLast(nums[i]);
            used[i] = true;

            System.out.println(&quot;  递归之前 =&gt; &quot; + path);
            dfs(nums, len, depth + 1, path, used, res);

            used[i] = false;
            path.removeLast();
            System.out.println(&quot;递归之后 =&gt; &quot; + path);
        &#125;
    &#125;
&#125;

public static void main(String[] args) &#123;
    int[] nums = &#123;1, 2, 3&#125;;
    Solution solution = new Solution();
    List&lt;List&lt;Integer&gt;&gt; lists = solution.permute(nums);
    System.out.println(lists);
&#125;
</code></pre>
<p>}<br>控制台输出：</p>
<p>  递归之前 =&gt; [1]<br>  递归之前 =&gt; [1, 2]<br>  递归之前 =&gt; [1, 2, 3]<br>递归之后 =&gt; [1, 2]<br>递归之后 =&gt; [1]<br>  递归之前 =&gt; [1, 3]<br>  递归之前 =&gt; [1, 3, 2]<br>递归之后 =&gt; [1, 3]<br>递归之后 =&gt; [1]<br>递归之后 =&gt; []<br>  递归之前 =&gt; [2]<br>  递归之前 =&gt; [2, 1]<br>  递归之前 =&gt; [2, 1, 3]<br>递归之后 =&gt; [2, 1]<br>递归之后 =&gt; [2]<br>  递归之前 =&gt; [2, 3]<br>  递归之前 =&gt; [2, 3, 1]<br>递归之后 =&gt; [2, 3]<br>递归之后 =&gt; [2]<br>递归之后 =&gt; []<br>  递归之前 =&gt; [3]<br>  递归之前 =&gt; [3, 1]<br>  递归之前 =&gt; [3, 1, 2]<br>递归之后 =&gt; [3, 1]<br>递归之后 =&gt; [3]<br>  递归之前 =&gt; [3, 2]<br>  递归之前 =&gt; [3, 2, 1]<br>递归之后 =&gt; [3, 2]<br>递归之后 =&gt; [3]<br>递归之后 =&gt; []<br>输出 =&gt; [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]<br>几点说明帮助理解「回溯算法」<br>每一次尝试都「复制」，则不需要回溯<br>如果在每一个 非叶子结点 分支的尝试，都创建 新的变量 表示状态，那么</p>
<p>在回到上一层结点的时候不需要「回溯」；<br>在递归终止的时候也不需要做拷贝。<br>这样的做法虽然可以得到解，但也会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。为了验证上面的说明，我们写如下代码进行实验：<br>参考代码 3：</p>
<p>JavaPython</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>public class Solution {</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;
    // 首先是特判
    int len = nums.length;
    // 使用一个动态数组保存所有可能的全排列
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

    if (len == 0) &#123;
        return res;
    &#125;

    boolean[] used = new boolean[len];
    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();

    dfs(nums, len, 0, path, used, res);
    return res;
&#125;

private void dfs(int[] nums, int len, int depth,
                 List&lt;Integer&gt; path, boolean[] used,
                 List&lt;List&lt;Integer&gt;&gt; res) &#123;
    if (depth == len) &#123;
        // 3、不用拷贝，因为每一层传递下来的 path 变量都是新建的
        res.add(path);
        return;
    &#125;

    for (int i = 0; i &lt; len; i++) &#123;
        if (!used[i]) &#123;
            // 1、每一次尝试都创建新的变量表示当前的&quot;状态&quot;
            List&lt;Integer&gt; newPath = new ArrayList&lt;&gt;(path);
            newPath.add(nums[i]);

            boolean[] newUsed = new boolean[len];
            System.arraycopy(used, 0, newUsed, 0, len);
            newUsed[i] = true;

            dfs(nums, len, depth + 1, newPath, newUsed, res);
            // 2、无需回溯
        &#125;
    &#125;
&#125;
</code></pre>
<p>}<br>这就好比我们在实验室里做「对比实验」，每一个步骤的尝试都要保证使用的材料是一样的。我们有两种办法：</p>
<p>每做完一种尝试，都把实验材料恢复成做上一个实验之前的样子，只有这样做出的对比才有意义；<br>每一次尝试都使用同样的新的材料做实验。<br>在生活中做实验对材料有破坏性，这个过程通常不可逆。而在计算机的世界里，「恢复现场」和「回到过去」是相对容易的。</p>
<p>在一些字符串的搜索问题中，有时不需要回溯的原因是这样的：字符串变量在拼接的过程中会产生新的对象（针对 Java 和 Python 语言，其它语言我并不清楚）。如果您使用 Python 语言，会知道有这样一种语法：[1, 2, 3] + [4] 也是创建了一个新的列表对象，我们已经在「参考代码 2」中展示这种写法。</p>
<p>为什么不是广度优先遍历<br>首先是正确性，只有遍历状态空间，才能得到所有符合条件的解，这一点 BFS 和 DFS 其实都可以；<br>在深度优先遍历的时候，不同状态之间的切换很容易 ，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 11 处，因此回退非常方便，这样全局才能使用一份状态变量完成搜索；<br>如果使用广度优先遍历，从浅层转到深层，状态的变化就很大，此时我们不得不在每一个状态都新建变量去保存它，从性能来说是不划算的；<br>如果使用广度优先遍历就得使用队列，然后编写结点类。队列中需要存储每一步的状态信息，需要存储的数据很大，真正能用到的很少 。<br>使用深度优先遍历，直接使用了系统栈，系统栈帮助我们保存了每一个结点的状态信息。我们不用编写结点类，不必手动编写栈完成深度优先遍历。<br>不回溯可不可以<br>可以。搜索问题的状态空间一般很大，如果每一个状态都去创建新的变量，时间复杂度是 O(N)O(N)。在候选数比较多的时候，在非叶子结点上创建新的状态变量的性能消耗就很严重。</p>
<p>就本题而言，只需要叶子结点的那个状态，在叶子结点执行拷贝，时间复杂度是 O(N)O(N)。路径变量在深度优先遍历的时候，结点之间的转换只需要 O(1)O(1)。</p>
<p>最后，由于回溯算法的时间复杂度很高，因此在遍历的时候，如果能够提前知道这一条分支不能搜索到满意的结果，就可以提前结束，这一步操作称为 剪枝。</p>
<p>剪枝<br>回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；<br>提示：剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。</p>
<p>由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。<br>总结<br>做题的时候，建议 先画树形图 ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p>
<p>在画图的过程中思考清楚：</p>
<p>分支如何产生；<br>题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？<br>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？<br>练习<br>下面提供一些我做过的「回溯」算法的问题，以便大家学习和理解「回溯」算法。</p>
<p>题型一：排列、组合、子集相关问题<br>提示：这部分练习可以帮助我们熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件， 为什么有的时候用 used 数组，有的时候设置搜索起点 begin 变量，理解状态变量设计的想法。</p>
<ol start="46">
<li>全排列（中等）</li>
<li>全排列 II（中等）：思考为什么造成了重复，如何在搜索之前就判断这一支会产生重复；</li>
<li>组合总和（中等）</li>
<li>组合总和 II（中等）</li>
<li>组合（中等）</li>
<li>子集（中等）</li>
<li>子集 II（中等）：剪枝技巧同 47 题、39 题、40 题；</li>
<li>第 k 个排列（中等）：利用了剪枝的思想，减去了大量枝叶，直接来到需要的叶子结点；</li>
<li>复原 IP 地址（中等）<br>题型二：Flood Fill<br>提示：Flood 是「洪水」的意思，Flood Fill 直译是「泛洪填充」的意思，体现了洪水能够从一点开始，迅速填满当前位置附近的地势低的区域。类似的应用还有：PS 软件中的「点一下把这一片区域的颜色都替换掉」，扫雷游戏「点一下打开一大片没有雷的区域」。</li>
</ol>
<p>下面这几个问题，思想不难，但是初学的时候代码很不容易写对，并且也很难调试。我们的建议是多写几遍，忘记了就再写一次，参考规范的编写实现（设置 visited 数组，设置方向数组，抽取私有方法），把代码写对。</p>
<ol start="733">
<li>图像渲染（Flood Fill，中等）</li>
<li>岛屿数量（中等）</li>
<li>被围绕的区域（中等）</li>
<li>单词搜索（中等）<br>说明：以上问题都不建议修改输入数据，设置 visited 数组是标准的做法。可能会遇到参数很多，是不是都可以写成成员变量的问题，面试中拿不准的记得问一下面试官</li>
</ol>
<p>题型三：字符串中的回溯问题<br>提示：字符串的问题的特殊之处在于，字符串的拼接生成新对象，因此在这一类问题上没有显示「回溯」的过程，但是如果使用 StringBuilder 拼接字符串就另当别论。<br>在这里把它们单独作为一个题型，是希望朋友们能够注意到这个非常细节的地方。</p>
<ol start="17">
<li><p>电话号码的字母组合（中等），题解；</p>
</li>
<li><p>字母大小写全排列（中等）；</p>
</li>
<li><p>括号生成（中等） ：这道题广度优先遍历也很好写，可以通过这个问题理解一下为什么回溯算法都是深度优先遍历，并且都用递归来写。<br>题型四：游戏问题<br>回溯算法是早期简单的人工智能，有些教程把回溯叫做暴力搜索，但回溯没有那么暴力，回溯是有方向地搜索。「力扣」上有一些简单的游戏类问题，解决它们有一定的难度，大家可以尝试一下。</p>
</li>
<li><p>N 皇后（困难）：其实就是全排列问题，注意设计清楚状态变量，在遍历的时候需要记住一些信息，空间换时间；</p>
</li>
<li><p>解数独（困难）：思路同「N 皇后问题」；</p>
</li>
<li><p>祖玛游戏（困难）</p>
</li>
<li><p>扫雷游戏（困难）<br>（欢迎大家补充。）</p>
</li>
</ol>
<p>参考资料<br>liuyubobobo 老师在慕课网上开设的课程《玩转算法面试》代码仓库。<br>不好意思，这里给自己做一个宣传，我最近在「力扣」上推出了自己的 LeetBook：使用「力扣」学习算法与数据结构，主要面向 转行 、零基础 的朋友，讲解算法与数据结构的基础知识。（2020.08.23）</p>
<p>说明：</p>
<p>该 LeetBook 的前两章（ 时间复杂度、二分查找）是免费阅读的，后面的章节 需要付费 观看，中、高阶用户请谨慎购买；<br>可以在站内或者是我的其他社交账号向我咨询课程内容。不管是否购买课程，我都会尽量回答我所知道的问题（时间允许，能力范围之内）。感谢大家一直以来，一如既往对我的支持。有建议和意见也欢迎大家与我交流。。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%9B%9E%E6%BA%AF/">回溯</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/25/JVM/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM虚拟机</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/18/dp/">
                        <span class="hidden-mobile">动态规划</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
